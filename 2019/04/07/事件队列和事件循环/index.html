<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="事件队列和事件循环, DangoSky">
    <meta name="description" content=" JavaScript是单线程的&amp;emsp;&amp;emsp;JavaScript 从出生以来就是单线程的，这可能和 JavaScript 一切从简有关，毕竟是人家只花了10天就开发出的语言。也可能是受限于 JavaScript 的用途，Java">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>事件队列和事件循环 | DangoSky</title>
    <link rel="icon" type="image/jpeg" href="/favicon.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <span class="logo-span">DangoSky</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <div class="logo-name">DangoSky</div>
        <div class="logo-desc">
            
            但愿日子清净，抬头遇见的都是柔情。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/7.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        事件队列和事件循环
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JavaScript/" target="_blank">
                                <span class="chip bg-color">JavaScript</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JavaScript/" class="post-category" target="_blank">
                                JavaScript
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-04-07
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        5.2k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        18 分
                    </div>
                    
                
				
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <script src="/assets/js/APlayer.min.js"> </script><h1 id="JavaScript是单线程的"><a href="#JavaScript是单线程的" class="headerlink" title="JavaScript是单线程的"></a>JavaScript是单线程的</h1><p>&emsp;&emsp;JavaScript 从出生以来就是单线程的，这可能和 JavaScript 一切从简有关，毕竟是人家只花了10天就开发出的语言。也可能是受限于 JavaScript 的用途，JavaScript 作为脚本语言控制着页面的行为，如果有多个线程同时对页面的某一个元素进行操作，比如对同一个 DOM 元素进行增删操作，那浏览器要听哪个线程的？所以如果是多线程的话，浏览器在响应时就会变得很复杂了。（难道要像多进程那样引入锁？？）</p>
<p>&emsp;&emsp;而单线程意味着主线程只能一次执行一个任务，不能同时执行多个，这就导致了像 http 请求等耗时长的任务很可能会长时间占用着主线程，堵塞了执行栈中其他任务的执行。互联网上有一个八秒准则（当然这个八秒也只是一个虚数而已），即用户在执行操作后如果页面在 8s 之内没有得到响应，进入假死状态，则用户会失去耐心直接关闭页面（不知道你们会不会这样，反正我就是这样的，不过可能我耐心好一点所以我会等上个十几秒）。所以考虑到主线程堵塞的问题，JavaScript 异步操作就应运而生了。异步任务不会在执行期间长时间占用主线程，而是会先被主线程挂起，等达到一定条件比如 http 请求得到响应或到了代码指定的延迟时间后，通过调用回调函数的方式来回头完成代码的执行，而在这段时间内主线程就可以去执行其他的任务了，这样即使 http 请求花费了很长时间甚至是一直没有响应也不会堵塞到其他任务的执行。</p>
<h1 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h1><p>&emsp;&emsp;当程序在执行过程中遇到异步任务时会先把异步任务挂起，交由其他相关的浏览器线程处理。注意，这里指的是浏览器线程，<a href="https://imweb.io/topic/58e3bfa845e5c13468f567d5" target="_blank" rel="noopener">引用一下相关的描述</a>：</p>
<blockquote>
<p> 浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>
<ul>
<li>GUI 渲染线程</li>
<li>JavaScript引擎线程</li>
<li>定时触发器线程</li>
<li>事件触发线程</li>
<li>异步http请求线程</li>
</ul>
<p>GUI渲染线程：<br>&emsp;&emsp;GUI渲染线程负责渲染浏览器界面HTML元素，当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行。在Javascript引擎运行脚本期间，GUI渲染线程都是处于挂起状态的，也就是说被“冻结”了（与 JavaScript 引擎线程互斥，即两个线程不能同时运行）。</p>
<p>Javascript引擎线程：<br>&emsp;&emsp;Javascript 引擎，也可以称为JS内核，主要负责处理 Javascript 脚本程序，例如V8引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。</p>
<p>定时触发器线程：<br>&emsp;&emsp;浏览器定时计数器并不是由 JavaScript 引擎计数的， 因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确， 因此通过单独线程来计时并触发定时是更为合理的方案。</p>
<p>事件触发线程：<br>&emsp;&emsp;当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p>
<p>异步http请求线程：<br>&emsp;&emsp;在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。</p>
</blockquote>
<p>&emsp;&emsp;以<code>setTimeout</code>为例，当Javascript引擎运行到<code>setTimeout</code>时，因为<code>setTimeout</code>是一个异步事件，所以会将<code>setTimeout</code>交由相关的<strong>定时触发器线程</strong>进行计时操作。在<code>setTimeout</code>被挂起的这段时间之内，主线程依然会马不停蹄地接着往下执行代码而不会等待<code>setTimeout</code>。当定时触发器线程计时达到<code>setTimeout</code>指定的延迟时间后，就会把<strong>setTimeout的回调函数</strong>推入到事件队列中。注意，这里只是把回调函数推入到事件队列，并不意味着会马上执行它，<strong>只有等到执行栈中所有的同步事件都执行完毕后，才会去读取事件队列中的事件并将其放到执行栈中执行</strong>（既然是一个队列，事件队列自然就有 queue <strong>先进先出</strong>的特性了）。因为得先执行完执行栈中所有的同步事件才会去读取事件队列中的事件，所以这也决定了<strong>setTimeout 指定的执行延迟时间是不准确的</strong>，这发生在执行栈中所有事件执行完毕的所需时间大于延迟时间的时候，因此 HTML5 也规定了<code>setTimeout</code>的最小延迟时间不能小于 4ms（当然并不是所有的浏览器都遵循了这个标准）。我们可以用代码说话：</p>
<pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> time <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"执行定时器的事件"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> time <span class="token operator">&lt;</span> <span class="token number">2000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/* 
  start 2019-04-07T11:56:51.537Z
  end 2019-04-07T11:56:53.541Z
  执行定时器的事件 2019-04-07T11:56:53.542Z
*/</span>
</code></pre>
<p>&emsp;&emsp;我们可以分析一下上面代码的执行过程，JavaScript引擎开始解析代码，先生成全局执行上下文并把它压入到执行栈中（当然其中还有生成 VO、确定 this 指向和建立作用域链的环节，这不是本文重点就略过不提了。遇到<code>console.log(&quot;start&quot;, new Date())</code>发现这是一个同步事件后马上执行并输出 start 和当前的时间点。接着给 time 变量赋值后（注意是赋值，而不是声明，因为在创建全局执行上下文的时候就已经变量提前声明了）遇到了<code>setTimeout</code>事件，因为这是一个异步事件所以 JavaScript 引擎会把它挂起交由定时触发器线程进行计时操作。接着进入到 while 循环，我们手动地给 while 循环的持续时间设定为 2000ms，而在这 2000ms 内定时触发器线程已经完成了对<code>setTimeout</code>事件的计时并把它的回调函数放入到事件队列中了。但这时候因为执行栈中还有 while 循环在执行，所以<code>setTimeout</code>的回调函数还是留在事件队列中没能进入执行栈。2000ms 过后 JavaScript引擎继续向下解析，输出 end 和当前的时间点，之后执行栈中所有的同步事件便都执行完毕了，开始读取事件队列发现有<code>setTimeout</code>便把它取出放到执行栈中执行，所以最后输出“执行定时器的事件”和当前的时间点。</p>
<p>&emsp;&emsp;通过上面的分析以及输出的三个时间点，我们可以发现<code>setTimeout</code>指定的执行延迟时间确实是不确切的，这依赖于执行栈中所有同步事件执行完毕所需的时间，执行<code>setTimeout</code>回调函数的延迟时间只会大于指定的延迟时间而不会小于延迟时间。</p>
<p>&emsp;&emsp;在我写这篇博客的时候，我还有一个疑惑。我看到许多的博客说的都是异步事件的回调函数进入事件队列后，是等执行栈为空的时候才会取出事件队列中的事件放入到执行栈中去执行，不知到各位看客对此有没有什么疑问。<strong>如果事件队列中的事件是否进入执行栈的判断标准是执行栈是否为空的话，那就涉及到执行栈是否会为空了？</strong>想必大家都知道执行上下文吧，其中全局执行上下文在程序一开始执行就被创建，并且会被压入到执行栈中并一直存在执行栈底直到页面被关闭。是的，全局执行上下文一直存在执行栈底，这点应该没有什么争议。既然如此，是否意味着执行栈一直非空呢？这样的话事件队列中的事件还怎么通过判断执行栈是否为空来进入执行栈，不就一直进入不了执行栈了吗，这两者就冲突了啊！如果按执行栈是否为空为标准来判断事件队列中的事件是否进入执行栈，则势必要理清执行栈到底会不会为空的问题，如果不会为空的话怎么解释事件队列中的事件只有等到执行栈为空时才会进入执行栈中，如果会为空的话怎么解释全局执行上下文会一直存在执行栈栈底？所以我觉得以执行栈是否为空为标准来判断事件队列中的事件是否进入执行栈并不恰当，而是<strong>以执行栈中的同步事件是否都执行完毕为标准来判断</strong>（只剩下全局执行上下文）会更容易理解，这样就没有上面说的和全局执行上下文一直存在执行栈底的冲突了。</p>
<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>&emsp;&emsp;事件循环是建立在事件队列的基础上的，当执行栈中所有的同步事件都执行完毕后就会去读取事件队列中的事件，如果事件队列中有事件存在则取出放到执行栈中执行，否则的话就继续读取事件队列，这样不断地读取、执行、读取、执行的周而复始就成了事件循环。</p>
<p>&emsp;&emsp;引用一张经典的图辅助吧：<br><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png" alt></p>
<p>&emsp;&emsp;上图中，执行栈执行其中的同步任务，若代码中调用了外部异步的 Web API 如 DOM 事件、<code>Ajax请求</code>和<code>setTimeout</code>等，就将它们的回调函数放入到事件队列中，等执行栈中的同步事件都执行完毕后就读取事件队列，取出其中的事件到执行栈中执行，在执行栈和事件队列之间不断循环。不过我觉得这图里缺少了异步事件的回调函数是如何放到事件队列中的过程，比如<code>setTimeout</code>和<code>Ajax 请求</code>，<code>setTimeout</code>事件是马上就被放入到事件队列中的，还是等到了指定的延迟时间后才会推入到事件队列。如果是后者的话，在到达指定的延迟时间这段时间之内，<code>setTimeout</code>事件既然不在执行栈也不在事件队列中那是在哪里，是怎么进行计时的？（前文有解释到，定时触发器线程负责了<code>setTimeout</code>事件的计时，到达指定事件后就把其回调函数推入到事件队列中）</p>
<p>&emsp;&emsp;要声明的是，上述的事件循环是指浏览器环境下的事件循环，跟 nodeJS 的事件循环机制是不一样的。而 nodeJS 的事件循环是怎样的，我现在也还不清楚，就等以后我再写一篇博客介绍吧。</p>
<h1 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h1><p>&emsp;&emsp;其实异步任务还有再细分为两种的，分别是宏任务（macro task）和微任务（micro task）。其中宏任务主要有<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>I/O</code>和<code>UI rendering</code>等， 微任务主要有<code>Promise</code>、<code>process.nextTick</code>（process 是只存在于 Node 环境中的全局变量）和<code>MutationObserver</code>。前文介绍的是，异步事件的回调函数会被推入到事件队列中，但实际上还会根据这个异步事件的类型再推入到相应的宏任务事件队列或微任务事件队列中去。当执行栈中所有的同步事件都执行完毕后主线程会先读取微任务事件队列，如果其中有事件存在则会依次将它们放入到执行栈中去执行，接着才会去读取宏任务队列中的事件（即<strong>同一次事件循环中微任务永远在宏任务之前执行</strong>），如此周而复始慢慢循环。我们总结一下事件循环的执行过程就是，在一趟事件循环中：</p>
<ol>
<li>把执行栈中所有的同步任务都执行完。</li>
<li>先处理<strong>所有</strong>微任务事件队列中的事件。</li>
<li>在宏任务事件队列中取出<strong>一个</strong>事件放入到执行栈中执行。</li>
<li>不断重复 2、3 的过程。</li>
</ol>
<p>&emsp;&emsp;我还看到一个点：<strong>浏览器是在每一次事件循环之间渲染页面的</strong>。不过这点我也不知道怎么验证，就暂且先记着吧。</p>
<h2 id="Node10-x-和浏览器环境下的不同"><a href="#Node10-x-和浏览器环境下的不同" class="headerlink" title="Node10.x 和浏览器环境下的不同"></a>Node10.x 和浏览器环境下的不同</h2><p>&emsp;&emsp;说完宏任务和微任务的运行机制后就要敲黑板了：<strong>上面所述是针对浏览器环境而言的！上面所述是针对浏览器环境而言的！上面所述是针对浏览器环境而言的！</strong>重要的事情说三次！为什么说是针对浏览器环境而言呢？因为<strong>在 node 环境下，宏任务和微任务的运行机制是不同的！</strong>这里的 node 环境指的是 node10.x，node10 以下的我就不清楚了（原谅我缺乏打破砂锅问到底的精神就不回退版本去验证了Orz，有兴趣的看客可以自行验证，不过我估计跟 node10.x 是一样的）。当前 node 最新版本是 node11.x，<strong>在 node11.x 就将宏任务和微任务的运行机制统一得跟浏览器环境一样了</strong>。</p>
<p>&emsp;&emsp;强调完宏任务和微任务的运行机制在浏览器环境和 node10.x中不一样后，我们再来看看究竟有何不同。前面我们说到当执行栈中的同步任务都执行完毕后，会先清空微任务事件队列中的所有事件，再从宏任务事件队列中取出<strong>一个</strong>事件放到执行栈中执行，这是在浏览器环境下的。而在 node10.x 环境下，清空微任务事件队列中的所有事件后，有时候会跟浏览器环境一样再从宏任务事件队列中取出一个事件执行，<strong>有时候则是清空宏任务事件队列中的所有事件</strong>。你没有看错，就是<strong>有时候</strong>，具体采取哪一种运行机制我也不知道（不过根据多次的运行结果，node10.x <strong>采取后者的概率要比前者大得多</strong>），这也造成了同一段代码在 node 环境下运行结果有时候会是不一样的。我们先看一段简单的代码吧。</p>
<pre class=" language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"timer1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"timer2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;我们分别在浏览器环境和 node 环境去运行上面的代码，可以看到在浏览器环境下无论你运行多少次，结果输出的顺序都只会是 timer1 promise1 timer2 promise2 。而在 node10.x 环境下，输出的结果往往会是 timer1 timer2 promise1 promise2，但如果你多运行几次的话就会发现结果有时候跟在浏览器环境下是一样的，这也证明了 node10.x 环境下对宏任务和微任务采取的运行机制后者比前者要大得多（发现这点的时候我其实是 Orz 的，一个程序的结果还能有不确定性的，真的是 too young to simple）。</p>
<p>&emsp;&emsp;简要解释一下node 环境下为什么会输出 timer1 timer2 promise1 promise2 吧，浏览器环境下的结果应该没什么好解释的了，前面应该说的够清楚了吧。node10.x 环境下在清空执行栈中所有的同步任务并清空所有的微任务后，有时候只是从宏任务队列中取出一个事件放到执行栈中执行而已（这也是浏览器下的运行机制，node11.x 也是如此），但更多时候并不只是取出一个事件，而是会执行完宏任务事件队列中的所有事件。也就是说取出第一个<code>setTimeout</code>定时器执行完，并不会马上执行 Promise 的回调函数，而是会继续执行<strong>同轮循环</strong>下其他的宏任务，所有在输出 timer1 后就跟着输出了 timer2，最后才去清空微任务事件队列。</p>
<h2 id="process-nextTick具有优先权"><a href="#process-nextTick具有优先权" class="headerlink" title="process.nextTick具有优先权"></a>process.nextTick具有优先权</h2><p>&emsp;&emsp;process是 node 环境下的全局变量，浏览器环境下是不具有的，因此<code>process.nextTick</code>自然也只能在 node 环境下使用了。上文有说到，<code>process.nextTick</code>是属于微任务事件队列的，但需要注意的是，在 node 环境下<strong>process.nextTick 在微任务事件队列中的优先级会大于其他的微任务</strong>，即清空微任务事件队列时会先执行所有的<code>process.nextTick</code>事件。我们实践一下：</p>
<pre class=" language-js"><code class="language-js">Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;上面的代码不管是在 node10.x 还是在 node11.x 都会先执行 process.nextTick 再执行 promise 的回调函数！</p>
<h2 id="setTimeout-和-setImmediate-的优先顺序"><a href="#setTimeout-和-setImmediate-的优先顺序" class="headerlink" title="setTimeout 和 setImmediate 的优先顺序"></a>setTimeout 和 setImmediate 的优先顺序</h2><p>&emsp;&emsp;<code>setImmediate</code>的功能和<code>setTimeout</code>其实是一样的，不同点在于<code>setImmediate</code>会马上调用，相当于设置了 0ms 延迟的 setTimeout。其中的坑点在于：<code>setImmediate</code>和设置 0ms 延迟的<code>setTimeout</code>的执行顺序是不确定的。</p>
<pre class=" language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;上面的代码，可能先输出 timeout 也可能先输出 immediate，node 10.x 和 node11.x 都是如此。不过好像有一个规律是：当 script 整体代码执行完的时候，如果已经过了<code>setTimeout</code>指定的延迟时间的话则会先执行<code>setTimeout</code>，即使<code>setImmediate</code>出现在<code>setTimeout</code>之前，反之若整体代码执行完后<code>setTimeout</code>还没有到指定的延迟时间，则会先执行<code>setImmediate</code>。我们修改一下上面的代码试试。</p>
<pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"耗时:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// for(let i=1; i&lt;=1000000; i++) {}</span>
console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"耗时:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;emmm，好像只有在执行完 script 所有代码所需的时间和 <code>setTimeout</code>的指定延迟时间相差较大（差不多得差上 5ms 左右吧）时，上述的规律才会成立，我们可以使用一个空的 for 循环来增加执行 script 所有代码所需的时间。不过这所谓的规律也只是猜想而已，不一定正确，具体的还是得去看 node 的源码啊Orz。等以后有时间了再去看吧，感觉现在还不太适合去看源码，更何况还是 node 的源码。现阶段还是先继续把 JS 的基础打好，毕竟框架啥的也都是离不开 JS 的，基础还是很重要滴，不能只会调用 api 只知概念而不知原理吧。</p>
<hr>
<p>&emsp;&emsp;最后再留下一段代码当做课后习题吧，各位看客有兴趣的可以自个先分析后再上机跑一下结果。提醒一下，浏览器环境和 node10.x 环境结果是不一样的。如果你在浏览器中跑这段代码得到将会是<code>Uncaught ReferenceError: process is not defined</code>，至于原因看客们自己想想，想不到就把这篇博客再看一遍吧。要验证浏览器环境下的输出，看客可以使用 node11.x 的环境运行，前面也有提到，node11.x 和 浏览器环境下的运行机制是统一的。</p>
<pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'7'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'11'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'12'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>

            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="http://blog.dangosky.com" class="b-link-green">DangoSky</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2019/04/07/事件队列和事件循环/" class="b-link-green">事件队列和事件循环</a>
                </p>
            </div>
        </div>
    </div>

    

    

    
        <div class="disqus-card card" data-aos="fade-up">
    <div id="disqus_thread" class="card-content">
        <noscript>Please enable JavaScript to view the
            <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
    </div>
</div>

<script type="text/javascript">
    disqus_config = function () {
        this.page.url = 'http://blog.dangosky.com/2019/04/07/事件队列和事件循环/';
        this.page.identifier = '/2019/04/07/事件队列和事件循环/';
        this.page.title = '事件队列和事件循环';
    };
    let disqus_shortname = 'dangosky';

    (function () { // DON'T EDIT BELOW THIS LINE
        let d = document, s = d.createElement('script');
        // 如：s.src = 'https://blinkfox.disqus.com/embed.js';
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/04/12/事件模型和事件委托/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="事件模型和事件委托">
                        
                        <span class="card-title">事件模型和事件委托</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary"> &emsp;&emsp;这回说的是事件模型，跟上篇博客说的事件循环关系不大。事件循环主要是同异步事件在内部环境的执行过程，而事件模型主要是涉及到事件的生成过程，在实践中的应用比较多，比如说常见的事件委托（也叫做事件代理）。
事件模型&em</div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-04-12
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JavaScript/" class="post-category" target="_blank">
                                    JavaScript
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JavaScript/" target="_blank">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                    <a href="/tags/前端基础/" target="_blank">
                        <span class="chip bg-color">前端基础</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/04/01/深拷贝实现/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="深拷贝的实现">
                        
                        <span class="card-title">深拷贝的实现</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary"> 浅拷贝和深拷贝&emsp;&emsp;先用简单的两句话概括深拷贝和浅拷贝的区别吧。&emsp;&emsp;浅复制：只将对象的各个属性进行一层复制，因此对于引用数据类型而言复制的是对象地址，导致了“牵一发而动全身”。&emsp;&emsp;</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-04-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JavaScript/" class="post-category" target="_blank">
                                    JavaScript
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JavaScript/" target="_blank">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">74.7k</span>
            

            <!-- <p id="timeDate">DangoSky的博客诞生已经</p><p id="times">载入时分秒...</p> -->
            <!-- <p>DangoSky的博客已经诞生<strong><i><span id="day"></span><span id="hour"></span></span><span id="minutes"></span><span id="seconds"></span> </strong><i></p> -->
                <p id="timeDate"></p>

            <!-- 
			 -->
        </div>
        <div class="col s12 m4 l4 social-link ">

    <a href="mailto:1341514988@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>



   <a href="https://github.com/DangoSky" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
    <i class="fa fa-github"></i>
</a>



    <a href="http://notes.dangosky.com/" class="tooltipped" target="_blank" data-tooltip="浏览我的笔记" data-position="top" data-delay="50">
     <i class="fa fa-book"></i>
 </a>
 
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<script type="text/javascript">
    function computed(){
        let sum = new Date()-new Date(2018,9,3,23,3,38)
        sum = parseInt(sum / 1000);
        let d = zero(parseInt(sum / 3600 / 24));
        let h = zero(parseInt(sum / 3600 % 24));
        let m = zero(parseInt(sum / 60 % 60));
        let s = zero(parseInt(sum % 60));
        document.getElementById("timeDate").innerHTML = "DangoSky的博客已经诞生<strong>" + d + "</strong>天<strong>" + h + "</strong>小时<strong>" + m + "</strong>分钟<strong>" + s + "</strong>秒了。"; 
    }
    function zero(i){
        if(i < 10)  {
            i = "0" + i;
        }
        return i;
    }
    setInterval("computed();",1000);
</script>

<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-shizuku"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body>
</html>