<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="从浏览器的渲染机制谈起, DangoSky">
    <meta name="description" content=" 前言&amp;emsp;&amp;emsp;大家应该都知道在前端有一道极其著名的题目：从输入 url 到页面加载完成的过程中发生了什么？不得不说这的确是一道覆盖面很广的题目，从计算机网络到浏览器缓存和渲染等内容几乎都包括在其内，更别提还可以引申出去再谈谈">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>从浏览器的渲染机制谈起 | DangoSky</title>
    <link rel="icon" type="image/jpeg" href="/favicon.jpg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <span class="logo-span">DangoSky</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <div class="logo-name">DangoSky</div>
        <div class="logo-desc">
            
            但愿日子清净，抬头遇见的都是柔情。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        从浏览器的渲染机制谈起
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JavaScript/" target="_blank">
                                <span class="chip bg-color">JavaScript</span>
                            </a>
                        
                            <a href="/tags/性能优化/" target="_blank">
                                <span class="chip bg-color">性能优化</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JavaScript/" class="post-category" target="_blank">
                                JavaScript
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-04-19
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        5.5k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        19 分
                    </div>
                    
                
				
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;大家应该都知道在前端有一道极其著名的题目：<strong>从输入 url 到页面加载完成的过程中发生了什么？</strong>不得不说这的确是一道覆盖面很广的题目，从计算机网络到浏览器缓存和渲染等内容几乎都包括在其内，更别提还可以引申出去再谈谈性能优化了，估计单单这一道题，从广度和深度挖下去就足以撑起一场面试了。不过本文只涉及到浏览器渲染方面的内容，从服务器返回响应开始讲起，而此前的内容等以后我理清楚了再分别写几篇博客谈谈。</p>
<h1 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h1><h2 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h2><p>&emsp;&emsp;在计算机网络中传输的内容都是以字节的形式传输的，当浏览器接受到（或者从本地磁盘读取到）这些字节数据（也就是HTML文档）时，会先根据指定的编码方式（如 utf-8）把它们解码成字符串。然后通过<a href="https://zh.wikipedia.org/wiki/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90" target="_blank" rel="noopener">词法分析</a>把字符串识别成一个个词语（此处词法分析会识别并跳过空格和换行等无关的字符），再利用这些词语生成节点，而这些节点根据原本的文档结构便构建成了一颗 DOM 树。</p>
<p>&emsp;&emsp;其中词法分析是按一定的语言规则将字符串转化成一个个浏览器可以识别的词语（即 <strong>token</strong>），每一个 token 会标识出当前的 token 是“开始标签”、“结束标签”还是“文本”等信息。对于词法分析的过程，我猜可能是利用到正则表达式 + 栈来实现的，类似于 <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">Leetcode</a> 上一道算法题，匹配括号判断字符串是否有效，也可能是我想的太简单了。（对于 HTML 字符串如何解析成词语和节点，本文就不深入探讨了，看客有兴趣可以参考《<strong>WebKit技术内幕</strong>》这本书的 5.2 章。难道我会告诉你其实我也不是很清楚吗？还是等之后我深入理解了后再补充这部分的知识点吧，在这里立个 flag）</p>
<p><img src="/2019/04/19/从浏览器的渲染机制谈起/1.png" alt></p>
<h2 id="构建-CSSOM-树"><a href="#构建-CSSOM-树" class="headerlink" title="构建 CSSOM 树"></a>构建 CSSOM 树</h2><p>&emsp;&emsp;CSSOM 树的构建过程和 DOM 树的构建过程很相似，先是解析 CSS 生成 token，再由这些 token 生成节点构建出 CSSOM 树。</p>
<blockquote>
<p>在这一过程中浏览器会确定每一个节点的样式到底是什么，而这一过程其实是很消耗时间的。因为样式可以自行设置给某个节点，也可以通过继承父节点获得。所以浏览器得递归 CSSOM 树，才能确定元素的具体样式。</p>
</blockquote>
<p><img src="/2019/04/19/从浏览器的渲染机制谈起/2.png" alt></p>
<p>&emsp;&emsp;需要注意的是，上图的 CSSOM 树并不是完整的 CSSOM 树，因为它只显示出了我们在样式表中给定的样式。但除此之外每一个浏览器都会为每一个标签提供默认的样式信息的，比如<code>font-size</code>和<code>margin</code>等，CSSOM 树中显示的只是我们用来替换默认样式的信息而已。</p>
<p>&emsp;&emsp;不知道诸位看客从上图中有没有发现一个问题，上图的 CSSOM 树是由一个个标签名构建而成的，但往往我们的 CSS 样式表中是通过 class 和 id 来设置样式的，既然如此那 CSSOM 树要如何单单根据 class 和 id 就构建出有父子关系层层嵌套的树呢？（emmm，这个其实我也不知道Orz）</p>
<p>&emsp;&emsp;既然说到了 CSSOM 树，就顺道提一下 CSS 匹配规则吧。我们知道 CSS 匹配节点样式时是从右往左的。举个例子，对于<code>.box div</code>这个 CSS 选择器会先去查找所有的 div 标签，再去匹配这些 div 标签的父元素是否有 box 这个类。所以根据这个匹配规则我们应该尽量使用 id 和 class 选择器，让 CSS 匹配可以更高效，避免使用标签选择器过度嵌套。当然这里面还牵涉到<strong>选择器优先级</strong>的问题，不过这里就不过多说这些题外话啦，有兴趣的看客就自行 Google 吧。</p>
<h2 id="合成渲染树"><a href="#合成渲染树" class="headerlink" title="合成渲染树"></a>合成渲染树</h2><p>&emsp;&emsp;构建完 DOM 树和 CSSOM 树后就会合并两者，根据 DOM 上的节点及其对应的样式生成一颗渲染树（render tree）。在合并的过程中渲染树只会包含可见的节点，对于设置了<code>display: none</code>的节点和<code>&lt;head&gt;</code>、<code>&lt;script&gt;</code>这些节点是不会被渲染出来的。作为对比，设置<code>visible: hidden</code>的节点虽然不可见，但依旧会占据空间，还是会出现在渲染树中被渲染出来。</p>
<p><img src="/2019/04/19/从浏览器的渲染机制谈起/3.png" alt></p>
<h2 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h2><p>&emsp;&emsp;有了渲染树就可以对应起每一个节点和相应的样式信息，但这时候每一个节点在文档中所处的位置还是不确定的。所以就需要根据渲染树中的节点及其样式在页面上<strong>自上而下，从左到右</strong>地计算各个节点所处的位置和大小，也就是布局（有没有联想到什么？每一个节点其实都代表了一个个盒模型啊）。</p>
<h2 id="绘制（Painting）"><a href="#绘制（Painting）" class="headerlink" title="绘制（Painting）"></a>绘制（Painting）</h2><p>&emsp;&emsp;顾名思义，就是根据渲染树中的节点和对应的样式，以及计算得到的位置信息等将各个节点转换为页面上的实际像素并绘制出来。</p>
<p>&emsp;&emsp;用一张图总结一下浏览器渲染的五个过程。</p>
<p><img src="/2019/04/19/从浏览器的渲染机制谈起/4.png" alt></p>
<p>&emsp;&emsp;在以上的五个过程中有两个地方需要注意到。</p>
<ol>
<li><p>上述这五个步骤并不是同步的，而是逐步完成的。DOM 并不需要等 HTML 文档完全解析完再开始构建，而是<strong>边解析 HTML 边构建 DOM 树</strong>的。而且现在的浏览器为了达到更好的用户体验，渲染引擎会尽可能快的将内容渲染到屏幕上，它不会等到整个 HTML 文档都解析完成之后再去构建 render 树和布局渲染，而是同样解析完一部分内容就显示一部分内容（这是一个<strong>渐进</strong>的过程）。</p>
</li>
<li><p>现代一些浏览器在开始解析 HTML 的时候会有一个<strong>预解析</strong>的优化操作，即一开始就会<strong>并行</strong>去加载 HTML 文档中需要加载到的外部资源（JS 脚本、CSS 样式表以及图片等），而不必等 DOM 构建到它们相应的那个节点（我猜应该是通过正则表达式去匹配它们对应的标签名来实现的吧）。这样当 DOM 构建到相应的标签时，由于外部资源已经预加载好了，所以就可以立即执行而不用再等待资源加载从而避免进一步阻塞页面渲染（预解析并不改变 DOM 树）。</p>
</li>
</ol>
<p><img src="/2019/04/19/从浏览器的渲染机制谈起/6.png" alt></p>
<h1 id="JS-脚本和-CSS-样式表对-DOM-的阻塞"><a href="#JS-脚本和-CSS-样式表对-DOM-的阻塞" class="headerlink" title="JS 脚本和 CSS 样式表对 DOM 的阻塞"></a>JS 脚本和 CSS 样式表对 DOM 的阻塞</h1><h2 id="JS-会阻塞-DOM-的解析和页面渲染"><a href="#JS-会阻塞-DOM-的解析和页面渲染" class="headerlink" title="JS 会阻塞 DOM 的解析和页面渲染"></a>JS 会阻塞 DOM 的解析和页面渲染</h2><p>&emsp;&emsp;在构建 DOM 树时，如果遇到了<code>&lt;script&gt;</code>加载 JS 脚本，那么 DOM 树会暂停构建，先执行 JS 代码。如果 JS 脚本是通过外部引入的，则是等待 JS 先下载再执行。为什么 JS 脚本会阻塞到 DOM 树的构建呢？看客应该都知道，JavaScript的一个强大之处在于它可以操纵页面中的每一个节点并对其进行增删改查操作，其中也包括修改节点对应的 CSS 样式信息。所以<strong>为了防止要执行的 JS 代码和正在构建的 DOM 树起冲突</strong>，DOM 树的构建是会先被挂起的，等到 JS 代码执行完毕才会继续构建 DOM 树。如果 JS 脚本加载时间很长，页面无法继续渲染下去就会造成浏览器失去响应处于假死状态。（不知道看客们有没有联想到什么？<a href="http://blog.dangosky.com/2019/04/07/%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">前面一篇讲事件循环的博客</a>里有提到浏览器的两个线程：<strong>GUI 线程</strong>和 <strong>JavaScript</strong> 引擎线程。这两个线程是互斥的，其中原因和 JS 代码阻塞 DOM 是一样的）。平时我们常说不要把 JS 文件放在<code>&lt;head&gt;</code>头部而要放到<code>&lt;body&gt;</code>尾部防止首屏加载时间过长，就是基于 JS 会阻塞 DOM 的解析和渲染这一个原因。JS 文件放到了<code>&lt;body&gt;</code>的尾部，这样即使 JS 代码长时间加载也不会影响到首屏显示，因为这时候页面已经渲染完毕了。如果有一些 JS 代码必须先行加载（放在<code>&lt;head&gt;</code>头部）的话，最好直接将代码写在页面中而不是以外联载入的形式，这样可以节省加载 JS 文件所消耗的时长（不过 JS 代码放在<code>&lt;body&gt;</code>前面好像没什么用处吧，这时候页面还没有渲染又不能获取到 DOM 节点，通过 CDN 加载第三方库除外）。</p>
<p>&emsp;&emsp;如果页面中有多个<code>&lt;script&gt;</code>标签要加载 JS 文件，例如：</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"a.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"b.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>&emsp;&emsp;那么浏览器会并行下载这两个 JS 文件，但执行的时候会保证先执行 a.js，再执行 b.js，即使后者先加载完毕。也就是说，脚本的执行顺序由它们在页面中的出现顺序决定，不过页面的渲染还是得等它们都加载并执行完毕才会继续。</p>
<h2 id="CSS-不会阻塞-DOM-的解析，但会阻塞页面渲染"><a href="#CSS-不会阻塞-DOM-的解析，但会阻塞页面渲染" class="headerlink" title="CSS 不会阻塞 DOM 的解析，但会阻塞页面渲染"></a>CSS 不会阻塞 DOM 的解析，但会阻塞页面渲染</h2><p>&emsp;&emsp;<strong>DOM 树和 CSSOM 树的构建是两个独立的过程</strong>，彼此不会互相依赖，所以 CSS 加载也就不会影响到 DOM 的解析。然而<strong>渲染树得依赖于 DOM 树和 CSSOM 树</strong>来合成的，所以页面的渲染也就得等待 CSSOM 构建了。也就是说 CSS 不会阻塞 DOM 的解析，但会阻塞页面的渲染。换个角度想想也是，如果页面不等待 CSS 加载完成就渲染，而若正在加载的 CSS 文件修改到页面上已经渲染完成的节点的话，那就得造成页面重绘了，造成很多无谓的消耗。如果还引起页面重排的话那就更消耗性能了，所以等待 CSS 加载完成再继续渲染页面反倒能优化性能。</p>
<p>&emsp;&emsp;如果遇到 JS 脚本时还有未加载完成的 CSS 样式文件，那 CSS 的加载还会阻塞到 JS 的执行。原因也同上面说的，JS 可以增删改查到 DOM 节点，自然也就能读取或修改到 DOM 节点的 CSS 样式信息。为了防止 JS 文件读取读取到不完整的 CSS 信息或是修改时和前面的 CSS 样式表起冲突，所以 JS 文件会等待前面的 CSS 资源加载完成才执行。而 JS 又会阻塞到后面 DOM 的解析和页面渲染，双重阻塞下页面就变得更卡顿了。这也是我们平时常说的不要把 JS 文件放在 CSS 样式表之后的原因。</p>
<h1 id="异步加载-JS-脚本"><a href="#异步加载-JS-脚本" class="headerlink" title="异步加载 JS 脚本"></a>异步加载 JS 脚本</h1><p>  &emsp;&emsp;在<code>&lt;script&gt;</code>标签中可以设置两个属性，分别是<code>defer</code>和<code>async</code>，设置了<code>defer</code>和<code>async</code>的 JS 脚本相当于异步加载 JS 文件。在普通的<code>&lt;script&gt;</code>下，JS 的加载会暂停后续 DOM 的解析，而设置<code>defer</code>和<code>async</code>的<code>&lt;script&gt;</code>可以<strong>边加载 JS 文件，边进行 DOM 解析</strong>，这两个过程是并行发生的。需要注意的是，这两个属性只能作用于外部引入的脚本，对于内联脚本是不起作用的。</p>
<p>  &emsp;&emsp;两者的区别在于，<code>defer</code>加载的 JS 脚本会延迟执行，等到该 JS 脚本加载完毕并且 DOM 也解析完成后才会执行该 JS 代码。而<code>async</code>则是一旦加载完成 JS 脚本就会马上执行，如果这时候 DOM 还没有解析完成也是会先暂停解析先等待 JS 执行完毕的（同样会阻塞）。如果使用<code>defer</code>加载多个 JS 脚本，那 JS 脚本会按照它们在代码中的先后顺序执行。而<code>async</code>因为是 JS 脚本一加载完成就马上执行，所以并不能保证 JS 脚本的执行顺序，这取决于哪个 JS 脚本先加载完成。下面这张图很直观地展示了三者的区别。</p>
<p>  <img src="/2019/04/19/从浏览器的渲染机制谈起/5.jpg" alt></p>
<p>&emsp;&emsp;需要注意的是，<strong><code>defer</code>脚本会在<code>DOMContentLoaded</code>监听函数之前（相当于 jQuery 的 ready 事件）执行</strong>。而<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded" target="_blank" rel="noopener">什么是 DOMContentLoaded 事件</a>，用一句话概括就是，<code>DOMContentLoaded</code>会在 DOM 构建完毕后触发，此时<code>&lt;link&gt;</code>和<code>&lt;img&gt;</code>等外部资源可能还没有加载完成。和<code>DOMContentLoaded</code>相似的还有一个<code>load</code>事件，这个大家应该比较熟悉了。<code>load</code>事件不仅得等待 DOM 构建完成，还得等页面上其他的资源如图片音频和视频等都加载完后才触发，所以<code>load</code>事件是在<code>DOMContentLoaded</code>事件之后才触发的。至于<code>async</code>则情况会复杂一点，并不能确保<code>async</code>与<code>DOMContentLoaded</code>的执行先后顺序（但会在<code>load</code>之前执行）。这是因为<code>async</code>脚本一加载完毕就会马上执行，所以<code>async</code>与<code>DOMContentLoaded</code>的执行先后顺序取决于<code>async</code>脚本的加载完成时间。如果<code>async</code>脚本在 DOM 解析完成之前就加载完毕了，那么<code>async</code>脚本会先于<code>DOMContentLoaded</code>执行，反之则是<code>DOMContentLoaded</code>先于<code>async</code>脚本执行。（不知道看客们会不会有一个疑问，<code>defer</code>脚本不是构建完 DOM 才执行的吗，而<code>DOMContentLoaded</code>也是在构建完 DOM 完后就执行，那<code>defer</code>脚本怎么就一定会先于<code>DOMContentLoaded</code>执行呢？其实我也不知道，因为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script#%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">MDN</a> 就是这么写的。）</p>
<p>&emsp;&emsp;除了使用<code>defer</code>和<code>async</code>异步加载 JS 脚本外，我们还可以动态加载脚本，即在页面加载完成后才导入 JS 脚本，这样也可以避免阻塞页面渲染。</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>
  window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ele<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span><span class="token punctuation">;</span>
    ele<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'test.js'</span><span class="token punctuation">;</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<h1 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h1><h2 id="何时发生重排和重绘"><a href="#何时发生重排和重绘" class="headerlink" title="何时发生重排和重绘"></a>何时发生重排和重绘</h2><p>&emsp;&emsp;前面在说浏览器渲染的五个阶段的时候，后两个阶段分别是布局和绘制，其实对应的就是重排（也叫做回流）和重绘，而重排和重绘常常是影响页面性能的主因之一。我们先说说什么时候会触发重排和重绘。当页面中某一个元素的几何属性如大小位置等发生变化时，浏览器就需要重新计算该元素的几何属性，并且页面中的其他元素也都会受到影响，所以这时候就会对页面进行重新布局。造成重排的操作包括但不限于：</p>
<ul>
<li>页面首屏初始化加载。</li>
<li>添加或删除可见的 DOM 元素（包括设置元素的<code>display: none</code>属性）。</li>
<li>改变元素的位置。</li>
<li>改变元素的大小，如外边距、边框、内边距、宽高等。</li>
<li>内容改变导致元素的大小改变，如改变图片大小或是将图片替换成另一张不同尺寸的图片。</li>
<li>改变浏览器窗口大小。</li>
</ul>
<blockquote>
<p>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改根节点。</p>
</blockquote>
<p>&emsp;&emsp;而重绘则相对友好一些，不会导致页面重新布局，只是重新绘制受影响的部分元素。常见的造成重绘的操作除了上述的操作外还有：修改元素的背景颜色、字体的颜色和修改元素的外观显示<code>outline</code>等。由此我们也可以发现重排和重绘之间的关系：<strong>重排一定会造成重绘，但重绘不一定会重排</strong>。</p>
<h2 id="如何减小重排和重绘"><a href="#如何减小重排和重绘" class="headerlink" title="如何减小重排和重绘"></a>如何减小重排和重绘</h2><p>&emsp;&emsp;重排和重绘很消耗性能，所以我们在编写代码的时候应该有意识地去避免一些造成重排和重绘的发生（我们常常被建议不要去操作 DOM，因为操作 DOM 慢，而慢的原因就是因为操作 DOM 常常会引起重排和重绘）。</p>
<h3 id="合并对样式的修改"><a href="#合并对样式的修改" class="headerlink" title="合并对样式的修改"></a>合并对样式的修改</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'box'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token string">'100px'</span><span class="token punctuation">;</span>
ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token string">'100px'</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;我们常常会使用诸如上面示例的方法去修改 DOM 节点的样式，但上面这样的修改方式操作到了两次 DOM ，更糟糕的是导致了浏览器发生两次重排。所以我们可以通过<code>cssText</code>来合并对同一个 DOM 节点的多次修改，从而把操作 DOM 和重排的次数降为 1，优化页面性能。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'box'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">=</span> <span class="token string">'top: 100px; left: 100px'</span><span class="token punctuation">;</span>
ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'width: 100px; height: 100px;'</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;需要一提的是，<code>cssText</code>会覆盖掉之前设置好的样式，比如示例中如果不使用<code>+=</code>来拼接样式信息的话，则显示出来的元素会丢失原先设置好的<code>left</code>和<code>right</code>样式。当然，除了使用<code>cssText</code>外，我们还可以通过增加或修改元素的<code>class</code>来控制元素的样式显示（在 Vue 中不就常这么干）。</p>
<p>&emsp;&emsp;不过现在大多数浏览器会尽量把所有的样式变动都集中到一起，形成一个队列再批量处理，从而来避免页面多次重排。比如上面对<code>left</code>和<code>right</code>样式的修改，浏览器会把两次修改集中到一起再执行，这样就能只重排一次了。但<strong>一些操作会阻止浏览器对样式修改进行批量修改，强制页面马上重新渲染</strong>。比如以下方法:</p>
<ul>
<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>
<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>
<li>clientTop、clientLeft、clientWidth、clientHeight</li>
<li>getComputedStyle()</li>
</ul>
<p>&emsp;&emsp;以上这些操作要求浏览器返回最新的页面信息，所以浏览器不得不马上渲染已修改了的样式信息，造成页面多次重排。所以平时应该尽量少的去使用上述的属性，或者尽量不要把样式的写操作和读操作放在同一个语句里，可以先使用一个变量存储元素的上述的一些样式信息再进行写操作。</p>
<h3 id="批量修改-DOM"><a href="#批量修改-DOM" class="headerlink" title="批量修改 DOM"></a>批量修改 DOM</h3><p>&emsp;&emsp;有时候 DOM 节点并不是静态的，而需要我们去动态添加并进行一系列操作。比如在页面中给<code>ul</code>插入 N 个<code>li</code>，如果我们只是常规地在一个 for 循环中创建节点再添加的话，会对 DOM 操作 N 次并造成 N 次重排，这样对性能的影响可想而知。所以我们可以先让要操作到的元素脱离文档流再进行批量操作，最后再将元素添加回文档流中，这样就可以大大减小页面重排的次数。常用的方法有：</p>
<ol>
<li>使用<code>display: none</code>隐藏元素</li>
</ol>
<p>&emsp;&emsp;利用设置了<code>display: none</code>的元素在文档流中不占空间，所以我们可以先改变<code>ul</code>的<code>display</code>属性，再在<code>ul</code>上添加<code>li</code>，最后再恢复原先<code>ul</code>的<code>display</code>属性即可。</p>
<ol start="2">
<li>使用文档片段</li>
</ol>
<p>&emsp;&emsp;使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createDocumentFragment" target="_blank" rel="noopener">document.createDocumentFragment()</a>来创建一个文档片段，而因为文档片段存在于内存中，所以将子元素插入到文档片段时并不会对 DOM 树造成任何影响，因此自然就不会造成多余的重排了。只要将操作完后的文档片段添加到<code>ul</code>后即可，而这整个过程只会造成一次重排。</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span>
  <span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">"ul"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>
  <span class="token operator">&lt;</span>script<span class="token operator">></span>
    <span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      li<span class="token punctuation">.</span>innerText <span class="token operator">=</span> i<span class="token punctuation">;</span>
      fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ul<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
</code></pre>
<ol start="3">
<li>克隆原节点修改后再替换</li>
</ol>
<p>&emsp;&emsp;使用<code>cloneNode</code>克隆要进行修改的节点，在克隆的节点（副本）上进行操作后再使用<code>replaceChild</code>替换掉原先的节点。</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">"ul"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>
  <span class="token operator">&lt;</span>script<span class="token operator">></span>
    <span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> clone <span class="token operator">=</span> ul<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      li<span class="token punctuation">.</span>innerText <span class="token operator">=</span> i<span class="token punctuation">;</span>
      clone<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ul<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>clone<span class="token punctuation">,</span> ul<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
</code></pre>
<blockquote>
<p>对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载6～20个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。</p>
</blockquote>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>&emsp;&emsp;这篇博客页只是对浏览器的渲染过程做了一个大致的分析而已，如果对浏览器渲染的五个步骤进行深究下去其实还可以挖出很多细节的东西（前端就这样，原理的东西可以一个劲地深挖下去，而且还涉及的很广）。碍于个人所学有限，就先做一个简单的分析，等以后有了更深入的认识我再回来补充吧。或者看客有兴趣的话可以阅读下面这几篇深度好文做详细了解（超级长文预警）。</p>
<p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn" target="_blank" rel="noopener">构建对象模型</a><br><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a><br><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#The_parsing_algorithm" target="_blank" rel="noopener">How browsers work</a><br><a href="https://blog.csdn.net/riddle1981/article/details/90756332" target="_blank" rel="noopener">从渲染原理谈前端性能优化</a></p>

            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="http://blog.dangosky.com" class="b-link-green">DangoSky</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2019/04/19/从浏览器的渲染机制谈起/" class="b-link-green">从浏览器的渲染机制谈起</a>
                </p>
            </div>
        </div>
    </div>

    

    

    
        <div class="disqus-card card" data-aos="fade-up">
    <div id="disqus_thread" class="card-content">
        <noscript>Please enable JavaScript to view the
            <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
    </div>
</div>

<script type="text/javascript">
    disqus_config = function () {
        this.page.url = 'http://blog.dangosky.com/2019/04/19/从浏览器的渲染机制谈起/';
        this.page.identifier = '/2019/04/19/从浏览器的渲染机制谈起/';
        this.page.title = '从浏览器的渲染机制谈起';
    };
    let disqus_shortname = 'dangosky';

    (function () { // DON'T EDIT BELOW THIS LINE
        let d = document, s = d.createElement('script');
        // 如：s.src = 'https://blinkfox.disqus.com/embed.js';
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/05/03/Puzzle-Game/">
                    <div class="card-image">
                        
                        <img src="https://github.com/DangoSky/puzzle-game/blob/master/image/bg.jpg?raw=true" class="responsive-img" alt="Puzzle Game">
                        
                        <span class="card-title">Puzzle Game</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary"> 前言&emsp;&emsp;会做这个 Puzzle Game，还是应前几天 lightyears 的一次提议，模仿的是鹰脚网络首页左下角那个拼图小游戏。那天晚上睡觉的时候在床上想了一下，大致 get 到了它内部实现的原理，于是就干脆动手实</div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-05-03
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Web-Project/" class="post-category" target="_blank">
                                    Web Project
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JavaScript/" target="_blank">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                    <a href="/tags/Web-Project/" target="_blank">
                        <span class="chip bg-color">Web Project</span>
                    </a>
                    
                    <a href="/tags/Vue/" target="_blank">
                        <span class="chip bg-color">Vue</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/04/12/事件模型和事件委托/">
                    <div class="card-image">
                        
                        <img src="https://github.com/DangoSky/practices-for-web/blob/master/images/3.jpg?raw=true" class="responsive-img" alt="事件模型和事件委托">
                        
                        <span class="card-title">事件模型和事件委托</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary"> &emsp;&emsp;这回说的是事件模型，跟上篇博客说的事件循环关系不大。事件循环主要是同异步事件在内部环境的执行过程，而事件模型主要是涉及到事件的生成过程，在实践中的应用比较多，比如说常见的事件委托（也叫做事件代理）。
事件模型&em</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-04-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JavaScript/" class="post-category" target="_blank">
                                    JavaScript
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JavaScript/" target="_blank">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                    <a href="/tags/前端基础/" target="_blank">
                        <span class="chip bg-color">前端基础</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">70.4k</span>
            

            <!-- <p id="timeDate">DangoSky的博客诞生已经</p><p id="times">载入时分秒...</p> -->
            <!-- <p>DangoSky的博客已经诞生<strong><i><span id="day"></span><span id="hour"></span></span><span id="minutes"></span><span id="seconds"></span> </strong><i></p> -->
                <p id="timeDate"></p>

            <!-- 
			 -->
        </div>
        <div class="col s12 m4 l4 social-link ">

    <a href="mailto:1341514988@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>



   <a href="https://github.com/DangoSky" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
    <i class="fa fa-github"></i>
</a>



    <a href="http://notes.dangosky.com/" class="tooltipped" target="_blank" data-tooltip="浏览我的笔记" data-position="top" data-delay="50">
     <i class="fa fa-book"></i>
 </a>
 
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<script type="text/javascript">
    function computed(){
        let sum = new Date()-new Date(2018,9,3,23,3,38)
        sum = parseInt(sum / 1000);
        let d = zero(parseInt(sum / 3600 / 24));
        let h = zero(parseInt(sum / 3600 % 24));
        let m = zero(parseInt(sum / 60 % 60));
        let s = zero(parseInt(sum % 60));
        document.getElementById("timeDate").innerHTML = "DangoSky的博客已经诞生<strong>" + d + "</strong>天<strong>" + h + "</strong>小时<strong>" + m + "</strong>分钟<strong>" + s + "</strong>秒了。"; 
    }
    function zero(i){
        if(i < 10)  {
            i = "0" + i;
        }
        return i;
    }
    setInterval("computed();",1000);
</script>

<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-shizuku"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false});</script></body>
</html>