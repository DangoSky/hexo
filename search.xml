<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>跨域解决方案实践</title>
    <url>/2020/01/10/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><ul>
<li><p>什么时候会跨域：协议、域名、端口号三者有一个不同就是跨域。</p>
</li>
<li><p>对跨域的辨析：跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起并到达目标服务器，但是服务器返回的结果会被浏览器拦截。</p>
</li>
</ul>
<p>先来看一下不进行额外处理的跨域请求。</p>
<pre class=" language-js"><code class="language-js">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  url<span class="token punctuation">:</span> <span class="token string">'http://10.92.191.223:3000/test'</span><span class="token punctuation">,</span>
  success<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>意料之中的是，控制台会报 CORS 跨域的错误。</p>
<p><img src="/2020/01/10/跨域解决方案实践/1.png" alt></p>
<h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><ul>
<li><p>原理：<code>&lt;script&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;img&gt;</code> 引入的资源不受同源策略限制，并且动态载入的 script 脚本会自动执行。所以以请求 script 脚本的方式来调用 api 即可（但需要后端配合格式化返回的数据）。</p>
</li>
<li><p>优点：兼容性很好。</p>
</li>
<li><p>缺点：</p>
<ul>
<li>只支持 GET 请求它（因为 script 脚本的请求方式就是 GET）。</li>
<li>只支持跨域 HTTP 请求，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题。</li>
</ul>
</li>
<li><p>实现流程：创建一个 <code>&lt;script&gt;</code> 并载入页面中，src 是跨域的 api 接口地址，但后面需要带上一个标记有回调函数的请求参数，如 <code>http://10.92.191.223:3000/test/?callback=handleCallback</code>。后端接受到请求后需要进行特殊的处理，将回调函数名和数据拼接成一个函数调用的形式返回给前端，如 <code>handleCallback({&quot;status&quot;: &quot;success&quot;, &quot;message&quot;: &quot;跨域成功&quot;})</code>。因为是 script 脚本，所以前端请求到这个脚本后会立即执行这个脚本内容，即调用这个回调函数。</p>
</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 前端代码</span>
<span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"?"</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    url <span class="token operator">+</span><span class="token operator">=</span> <span class="token template-string"><span class="token string">`?callback=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callback<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    url <span class="token operator">+</span><span class="token operator">=</span> <span class="token template-string"><span class="token string">`&amp;callback=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callback<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  script<span class="token punctuation">.</span>src <span class="token operator">=</span> url<span class="token punctuation">;</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">handleCallback</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'成功拿到后端返回的数据，并执行回调函数'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 后端代码</span>
<span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'Hello World!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/test'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'handleCallback({"status": "success", "message": "跨域成功"})'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Example app listening on port 3000!'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<h4 id="jQuery-的-JSONP"><a href="#jQuery-的-JSONP" class="headerlink" title="jQuery 的 JSONP"></a>jQuery 的 JSONP</h4><p>jQuery 也已经封装好了 JSONP ，而且使用十分简单，不需要我们再去写 JSONP 函数。使用方式如下。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 前端代码</span>
$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  url<span class="token punctuation">:</span> <span class="token string">'http://10.92.191.223:3000/test'</span><span class="token punctuation">,</span>
  dataType<span class="token punctuation">:</span> <span class="token string">'jsonp'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 指定服务器返回的数据类型</span>
  <span class="token comment" spellcheck="true">// 不使用 jsonpCallback 指定回调函数名时，jQuery 会生成一个随机串来充当回调函数名，此时直接在 seccess 中处理返回的数据即可</span>
  success<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"请求成功后的回调函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 后端代码</span>
app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/test'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>callback <span class="token operator">+</span> <span class="token string">'({"status": "success", "message": "跨域成功"})'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">MDN</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p>
</blockquote>
<ul>
<li>原理：在服务端设置 <code>Access-Control-Allow-Origin</code> 响应头，允许哪些域名可以访问资源。</li>
</ul>
<pre class=" language-js"><code class="language-js">res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Origin"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h4 id="与跨源有关的响应头字段"><a href="#与跨源有关的响应头字段" class="headerlink" title="与跨源有关的响应头字段"></a>与跨源有关的响应头字段</h4><ul>
<li><p><code>Access-Control-Allow-Origin</code>：指定了允许访问该资源的外域 URI，设置为通配符 * 则表示所有网站都可以访问该资源。</p>
</li>
<li><p><code>Access-Control-Expose-Headers</code>：指定浏览器可以使用或读取 response 中的 哪些响应头。在跨域访问时，XMLHttpRequest 对象的 getResponseHeader 方法只能拿到 6 个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>，如果要获取其他头部信息则需要服务器设置本响应头。</p>
</li>
<li><p><code>Access-Control-Allow-Headers</code>：指明了实际请求中所允许携带的头部字段。</p>
</li>
<li><p><code>Access-Control-Allow-Methods</code>：指明了实际请求中所允许使用的 HTTP 方法。</p>
</li>
<li><p><code>Access-Control-Allow-Credentials</code>：表示是否允许浏览器发送 Cookie。该字段只能设置为 true， 表示服务器明确许可。如果服务器不允许浏览器发送 Cookie，删除该字段即可。</p>
</li>
<li><p><code>Access-Control-Max-Age</code>：指定了预请求的请求结果能够被缓存多久，在此有效期内可以直接发起实际请求而不用先通过预请求确认。</p>
</li>
</ul>
<h4 id="Cookie-相关"><a href="#Cookie-相关" class="headerlink" title="Cookie 相关"></a>Cookie 相关</h4><p>默认情况下 CORS 请求不会携带 Cookie，如果要带 Cookie 的话，则需要满足以下几个要求才行：</p>
<ol>
<li>服务器同意接受 Cookie，设置了 <code>Access-Control-Allow-Credentials: true</code> 字段。</li>
<li>服务器的 <code>Access-Control-Allow-Origin</code> 字段不能设置为通配符 *，必须指定为和请求网页一致的域名。</li>
<li>请求头需要设置 <code>withCredentials: true</code> 和 <code>crossDomain: true</code>。</li>
<li>浏览器 Cookie 依然遵循同源政策，需要将 Domain 属性设置为相应服务器的域名。</li>
</ol>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ul>
<li><p>满足以下两个请求就是简单请求，反之则是非简单请求：</p>
<ul>
<li>请求方法是以下三种方法之一：<code>HEAD</code>、<code>GET</code>、<code>POST</code>。</li>
<li>HTTP的头信息不超出以下几个字段：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Last-Event-ID</code>、<code>Content-Type</code>（只限于这几个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）</li>
</ul>
</li>
<li><p>简单请求的流程：</p>
<ul>
<li>浏览器直接发出 CORS 请求，也就是在请求头之中，增加一个 Origin 字段，表示本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</li>
<li>如果 Origin 指定的源不在许可范围内，服务器会返回一个正常的 HTTP 回应。但浏览器发现响应头中没有包含 <code>Access-Control-Allow-Origin</code> 字段，浏览器就知道发生了跨域错误，于是抛出一个错误被 <code>XMLHttpRequest</code> 的 <code>onerror</code> 回调函数捕获（也就是我们跨域时在控制台看到的那个报错）。注意这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。</li>
<li>如果 Origin 指定的域名在许可范围内，服务器返回的响应头就必须包含 <code>Access-Control-Allow-Origin</code> 字段，以及上述一些可选的其他字段。</li>
</ul>
</li>
</ul>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><ul>
<li><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或者 <code>Content-Type</code> 字段的类型是 <code>application/json</code>。</p>
</li>
<li><p>非简单请求的流程：</p>
<ul>
<li>非简单请求的 CORS 请求会在正式通信之前增加一次 HTTP 查询请求，也就是<strong>预请求</strong>。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和请求头。只有得到肯定答复后浏览器才会发出正式的 <code>XMLHttpRequest</code> 请求，否则就报错。</li>
<li>预请求使用的是 OPTIONS 请求方法（用来从服务器获取更多信息，不会对服务器资源产生影响），其中包含了 <code>Origin</code>、<code>Access-Control-Request-Method</code>、<code>Access-Control-Request-Headers</code> 等几个请求头，分别表示请求的来源、稍后的 CORS 正式请求使用的请求方法和使用到的请求头。</li>
<li>服务器收到预请求以后，基于上述的几个请求头来判断是否接受稍后的实际请求，确认允许本次跨域请求后就作出回应，包括：<code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>，以及上述一些其他的可选字段。如果服务器否定了预请求，则返回一个正常的 HTTP 请求，但没有任何 CORS 相关的头信息字段，此时浏览器就会抛出 CORS 请求被拒绝的错误。</li>
</ul>
</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul>
<li>原理：WebSocket 是一种双向通信协议，在建立连接之后 server 与 client 都能主动向对方发送或接收数据，并且不受同源策略限制。</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 前端代码</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://cdn.bootcss.com/socket.io/2.3.0/socket.io.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> socket <span class="token operator">=</span> <span class="token function">io</span><span class="token punctuation">(</span><span class="token string">'ws://localhost:3000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  socket<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'connect'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'客户端和服务端建立起连接'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  socket<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'onclient'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'客户端响应服务端的触发事件'</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  socket<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'onserver'</span><span class="token punctuation">,</span> <span class="token string">'onserver'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 后端代码</span>
<span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> socket <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'socket.io'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Example app listening on port 3000!'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

socket<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'connection'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>client<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务端监测到有客户端连接'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  client<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'onserver'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务端响应客户端的触发事件'</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  client<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'onclient'</span><span class="token punctuation">,</span> <span class="token string">'onclient'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<h2 id="中间件服务器"><a href="#中间件服务器" class="headerlink" title="中间件服务器"></a>中间件服务器</h2><ul>
<li>原理：同源策略只是对浏览器的限制，服务器之间的请求不受同源策略的影响。所以可以开启一个中间件服务器，前端将 HTTP 请求发送到这个中间服务器上，由这个中间件转发请求到目标服务器上，再将收到的响应数据转发给请求主机。</li>
</ul>
<p>下面的示例中，目标服务器是 <code>http://10.92.191.223:3000</code>，中间服务器是 <code>http://10.92.191.223:3001</code>。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* 前端请求代码 */</span>
<span class="token function">getApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">axios</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    method<span class="token punctuation">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span>
    url<span class="token punctuation">:</span> <span class="token string">'http://10.92.191.223:3001/test'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/* 中间服务器 */</span>
<span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http-proxy-middleware'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 中间服务器需要开启 CORS，否则请求到中间服务器也会有跨域问题</span>
  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Origin"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 路径是 /test 的请求会被转发</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'/test'</span><span class="token punctuation">,</span> <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  target<span class="token punctuation">:</span> <span class="token string">'http://10.92.191.223:3000'</span><span class="token punctuation">,</span>
  changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3001</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Example app listening on port 3001!'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">/* 目标服务器 */</span>
<span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'Hello World!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/test'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"status"</span><span class="token punctuation">:</span> <span class="token string">"success"</span><span class="token punctuation">,</span> <span class="token string">"message"</span><span class="token punctuation">:</span> <span class="token string">"跨域成功"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Example app listening on port 3000!'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
]]></content>
      <categories>
        <category>前端基础</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hook 中的闭包问题</title>
    <url>/2019/11/16/React-Hook-%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="React-Hook-中的闭包问题"><a href="#React-Hook-中的闭包问题" class="headerlink" title="React Hook 中的闭包问题"></a>React Hook 中的闭包问题</h1><p>本文不对 React Hook 做过多的介绍，只是记录笔者在学习过程中遇到的问题。关于 React Hook 的介绍请参考<a href="https://react.docschina.org/docs/hooks-intro.html" target="_blank" rel="noopener">官方文档</a>，或者也可以看我的<a href="http://notes.dangosky.com/React/Hook.html" target="_blank" rel="noopener">个人笔记</a>。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>直接开门见山，通过代码来看问题。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'You clicked on: '</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">></span>
      <span class="token operator">&lt;</span>p<span class="token operator">></span>You clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span><span class="token operator">></span>print count<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面这段代码看着并没有问题，两个 button 都可以正常工作。但如果我们先点击 print count 按钮，再点击 count + 1 按钮，就会发现打印出来的是点击 print count 按钮时的 count 值，而不是当前的 count 值。我们回顾下什么是闭包，说简单了就是在一个函数里包含了另一个函数，并且内层函数使用了外层函数的变量。说官方点就是<strong>闭包是由函数以及创建该函数的词法环境组合而成</strong>。这里的坑在于闭包的这个词法环境的有效期是多少，它包含的值会不会随之后变量的改变而改变？</p>
<p>答案是不会，这个词法环境包含了该闭包<strong>创建时</strong>所能访问的所有局部变量。划重点是闭包创建时的变量值，<strong>闭包创建之后即使这些变量值改变了也不会影响到闭包内保存的这个变量</strong>。所以在我们点击 print count 按钮时，就创建了一个闭包，它保存了这时候这一刻的 count 值 0，之后即使我们点击 count + 1 按钮使其增加到 1，之后打印出的也是刚才闭包内保存的 count 值 0，而不是 1（这也是我们可以使用闭包来保存循环变量的原因，还记得那道题么）。</p>
<p>下面是测试例子，</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createIncrement</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value <span class="token operator">+</span><span class="token operator">=</span> i<span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> message <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Current value is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">logValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> inc <span class="token operator">=</span> <span class="token function">createIncrement</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> log <span class="token operator">=</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>
<span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 2</span>
<span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 3</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// "Current value is 1"</span>
</code></pre>
<h2 id="Hook-中的闭包"><a href="#Hook-中的闭包" class="headerlink" title="Hook 中的闭包"></a>Hook 中的闭包</h2><p>看过了基本的闭包，我们再来看 Hook 中对闭包的应用。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Count is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>官方原话是：useEffect、useMemo、useCallback都是自带闭包的。每一次组件的渲染，它们都会捕获当前组件函数上下文中的状态(state, props)，所以每一次这三种hooks的执行，反映的也都是当前的状态，你无法使用它们来捕获上一次的状态。</p>
</blockquote>
<p>什么意思呢？就是上述三个 Hook 创建出来的闭包所包含的变量是创建该闭包时的变量值，不受后续该变量变化的影响。又因为我们给 useEffect 指定的依赖项是空的，所以 useEffect 只会在页面第一次加载时执行而已，即定时器的闭包只创建了一次。所以这就造成了每次都是打印  Count is: 0，并且因为闭包中的 count 保持了初始值 0，所以 setCount 执行的一直是 <code>setCount(0+1)</code>，于是页面显示的 count 值就一直是 1 了。</p>
<p>上述代码可以<a href="https://codesandbox.io/embed/interesting-robinson-xmgy0?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener">在这里测试</a>。</p>
<h2 id="对-Hook-过时闭包的解决办法"><a href="#对-Hook-过时闭包的解决办法" class="headerlink" title="对 Hook 过时闭包的解决办法"></a>对 Hook 过时闭包的解决办法</h2><h3 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h3><p>Hook 中的闭包问题主要是因为我们没有在 Hook 中添加依赖项，导致闭包没有更新始终保持着初始值。所以我们只要给 useEffect 指定 count 这个依赖，则每当依赖项改变时都会重新生成一个新的闭包，而新闭包保存的 count 值也就随着自然更新了。</p>
<p>当然直接去掉依赖项（不传 useEffect 的第二个参数）也是可以解决闭包过时问题的，然而我们只要 useEffect 在依赖值变化时更新就够了，其他数据和这个 useEffect 没有半毛钱关系，改变了也完全不需要执行 useEffect。但如果不传依赖项的话只要组件的数据一有变化 useEffect 就会重新执行并返回新的闭包，造成了没必要的消耗。（注意<strong>依赖项为空和不传依赖项是两个概念，前者是传了依赖项但它是一个空数组，后者是直接不传这个参数。前者只有依赖项改变时才会执行函数，后者只要组件数据改变了就执行</strong>。）</p>
<h3 id="以函数的形式更新state"><a href="#以函数的形式更新state" class="headerlink" title="以函数的形式更新state"></a>以函数的形式更新state</h3><p>添加依赖项固然可以解决闭包过时问题，但每次生成新的闭包函数时都会执行 useEffect 的代码，包括重新生成一个定时器和打印定时器的 ID。然而在这里我们并不需要反复生成定时器，如果我们忘记在 useEffect 里返回一个函数来清除定时器的话，还会造成多个定时器累加从而让页面直接崩溃掉。</p>
<p>解决办法是以函数的形式更新state，同 react 的 setState 一样，useState Hook 也可以通过函数的形式来修改 state，并且使用当前的 state 值作为函数参数。这样打印出来的 count 值虽然依旧是闭包初始化时保存的 0，但 count 不再是在它的初始值上更新，而是在当前 count 值的基础上更新的，所以页面显示的 count 能保持一个新的值。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 以函数的形式更新state</span>
<span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span>curCount<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> curCount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="使用useRef"><a href="#使用useRef" class="headerlink" title="使用useRef"></a>使用useRef</h3><p>通过 useRef 生成的对象来绑定 state，这样更新 state 的时候就可以不用依赖于该 state，而是直接在该绑定对象上的基础上更新即可。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Flow3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> countRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  countRef<span class="token punctuation">.</span>current <span class="token operator">=</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将useRef生成的对象和count绑定在一起</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>countRef<span class="token punctuation">.</span>current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="使用useReducer"><a href="#使用useReducer" class="headerlink" title="使用useReducer"></a>使用useReducer</h3><p>useReducer 可以达到和使用函数形式更新的 useState 一样的效果，也是在更新时在当前的 state 基础上进行操作。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">reducer</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'add'</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> count <span class="token operator">+</span> action<span class="token punctuation">.</span>gap<span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> count<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>type<span class="token punctuation">:</span> <span class="token string">'add'</span><span class="token punctuation">,</span> gap<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="收官"><a href="#收官" class="headerlink" title="收官"></a>收官</h2><p>本文只是大致介绍了几种避免获取旧的 state 的方法，对于其中原理并没有太多解释，等之后有时间再去研究研究 React Hook 的原理和源码吧。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>文本溢出截断的几种方案</title>
    <url>/2019/11/12/%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E6%88%AA%E6%96%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="文本溢出截断的几种方案"><a href="#文本溢出截断的几种方案" class="headerlink" title="文本溢出截断的几种方案"></a>文本溢出截断的几种方案</h1><h2 id="单行截断"><a href="#单行截断" class="headerlink" title="单行截断"></a>单行截断</h2><p>单行截断只需要使用 CSS 就可以实现，并且省略号位置和文本衔接得很好，也不存在兼容性问题。</p>
<pre class=" language-css"><code class="language-css"><span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span>
<span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
<span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>
</code></pre>
<h2 id="多行截断"><a href="#多行截断" class="headerlink" title="多行截断"></a>多行截断</h2><p>多行截断比较戳中痛点，那就是兼容性不好，先看看官方的多行截断方法。</p>
<pre class=" language-css"><code class="language-css"><span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span>
<span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
<span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span>
</code></pre>
<p>之前在公司使用到多行截断，在 Chrome、Firefox 和 safari 上都可以得到良好的支持，但在 IE11 上就不行了。因为 IE 识别不了 <code>-webkit-line-clamp</code> 这个 css 属性（详情看<a href="https://caniuse.com/#search=-webkit-line-clamp" target="_blank" rel="noopener">这里</a>），所以只能通过其他方式来模拟一下多行截断了。</p>
<p><img src="/2019/11/12/文本溢出截断的几种方案/1.png" alt></p>
<h3 id="伪元素-绝对定位"><a href="#伪元素-绝对定位" class="headerlink" title="伪元素 + 绝对定位"></a>伪元素 + 绝对定位</h3><p>通过伪元素 + 绝对定位来模拟多行截断原理其实很简单，就只是使用伪元素来表示省略号… ，并通过定位来将它放到文末就行了。但还需要固定文本框的高度来控制要显示的行数。</p>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.ie-polyfills</span> </span><span class="token punctuation">{</span>
    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">4.5</span>rem<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">word-break</span><span class="token punctuation">:</span> break-all<span class="token punctuation">;</span>
  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector"><span class="token class">.ie-polyfills</span><span class="token pseudo-element">::after</span> </span><span class="token punctuation">{</span>
    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">'...'</span><span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token property">padding-left</span><span class="token punctuation">:</span> <span class="token number">15</span>px<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">18</span>px<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* 使用渐变让 ... 过渡地自然点 */</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">0</span><span class="token punctuation">)</span>, <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">50%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>使用这种方法来模拟多行截断缺点也很明显，就是因为是手动控制 … 的位置，所以文本和 … 之间的过渡就没有原生方法那么自然，文字可能还会漏出一点出来。并且无法识别文本的长短，无论文本是否溢出都会显示省略号。</p>
<p>所以必须保证文本一定会溢出才行。</p>
<p><img src="/2019/11/12/文本溢出截断的几种方案/2.png" alt></p>
<p>目前只发现在 IE 上无法识别 <code>-webkit-line-clamp</code>，所以我们大可不必只为了兼容 IE 就放弃原生的多行截断方法。我们可以判断当前用户使用的浏览器来选择使用哪种截断方式。如果是 IE 浏览器（<code>navigator.userAgent.indexOf(&#39;Trident&#39;) &gt; -1</code>) 的话，我们就采用模拟截断的 CSS 样式，否则就使用原生的截断方法。</p>
<h3 id="伪元素-float"><a href="#伪元素-float" class="headerlink" title="伪元素 + float"></a>伪元素 + float</h3><p>利用浮动的特性，当文本高度不超过指定最大高度时，省略号（右浮动）会位于文本的下方，因为超出隐藏所以省略号不可见。但文本高度超过指定最大高度时，省略号向右浮动贴着文本的左边线，此时再通过定位把省略号拉到文本右边即可。通过这种方法的好处在于可以根据文本超出与否来控制是否显示省略号，缺点也是文本和省略号之间过渡不好。</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>多行截断多行截断多行截断多行截断多行截断多行截断多行截断多行截断多行截断多行截断多行截断多行截断多行截断多行截断多行截断多行截断多行截断<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
</code></pre>
<pre class=" language-css"><code class="language-css"><span class="token selector">p </span><span class="token punctuation">{</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.app</span> </span><span class="token punctuation">{</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">max-height</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span>
  <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>
  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.app</span><span class="token pseudo-element">::before</span></span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.app</span> <span class="token class">.text</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">20</span>px<span class="token punctuation">;</span>
  <span class="token property">word-break</span><span class="token punctuation">:</span> break-all<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.app</span><span class="token pseudo-element">::after</span></span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span>right<span class="token punctuation">;</span>
  <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">'...'</span><span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span><span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-<span class="token number">100%</span>,-<span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">0</span><span class="token punctuation">)</span>, <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">255</span>, <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">50%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="js截断文本并拼接省略号"><a href="#js截断文本并拼接省略号" class="headerlink" title="js截断文本并拼接省略号"></a>js截断文本并拼接省略号</h3><p>通过 js 来模拟截断，主要是要判断文本字符串在哪个位置超出了限定的行数，并在该位置上截取出字符串并拼接省略号。通过 <code>getComputedStyle</code> 获取文本单行的宽度，并除以文本的字体大小，就可以得到每行可以容纳的字数，再乘上要显示的行数就是在限定的行数内可以显示的最多字体数了。</p>
<p>这种方法可以避免文本和省略号过渡不自然的问题，并且只有在文本超出的时候才会显示省略号进行截断。然而缺陷在于中英文的字体大小即使保持一致（假设是16px），但中英文的字体宽度不一样，导致计算后英文每行实际的显示字数比计算值大很多，省略号显示的位置会有所偏差。可以在<a href="https://codesandbox.io/s/angry-hooks-tioby?fontsize=14" target="_blank" rel="noopener">这里</a>进行实验。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'text'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> text <span class="token operator">=</span> ele<span class="token punctuation">.</span>innerText<span class="token punctuation">;</span>
<span class="token keyword">const</span> totalTextLen <span class="token operator">=</span> text<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">formatStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> lines <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 要显示的行数</span>
  <span class="token keyword">const</span> fontSize <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">getComputedStyle</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">.</span>fontSize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 字体大小</span>
  <span class="token comment" spellcheck="true">// 单行文本的长度，使用getComputedStyle计算出来的长度带了单位，需要去掉单位</span>
  <span class="token keyword">const</span> lineWidth <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">getComputedStyle</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">const</span> lineStrNum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>lineWidth <span class="token operator">/</span> fontSize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 一行可容纳的字数(不区分中英文)</span>
  <span class="token keyword">let</span> content <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> totalStrLen <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>lineStrNum <span class="token operator">*</span> lines<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lines行可以容纳的字数</span>
  <span class="token comment" spellcheck="true">// 文本的长度超出了lines行可以容纳的字数长度，则在超出的地方进行截断，并拼接上省略号</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>totalTextLen <span class="token operator">></span> totalStrLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    content <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> totalStrLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    content <span class="token operator">=</span> text<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  ele<span class="token punctuation">.</span>innerText <span class="token operator">=</span> content<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">formatStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span>onresize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token function">formatStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="Clamp-js"><a href="#Clamp-js" class="headerlink" title="Clamp.js"></a>Clamp.js</h2><p>对文本进行截断的工具：<a href="https://github.com/josephschmitt/Clamp.js" target="_blank" rel="noopener">Clamp.js</a>，可以选择对指定的行数进行截断、截断后插入的字符 / HTML代码。</p>
<p><a href="https://www.bootcdn.cn/Clamp.js/" target="_blank" rel="noopener">CDN引入</a>。</p>
<p>基本使用方法：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'text'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">$clamp</span><span class="token punctuation">(</span>ele<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  clamp<span class="token punctuation">:</span> <span class="token string">'2'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
</code></pre>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2019/09/03/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在头条实习的这八周里，刚开始没少因为我对 Git 掌握严重不足而挨 mentor 训过，所以在这里记录一些比较常用的 Git 操作。</p>
<h1 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h1><p>假如我们现在在本地仓库提了3个 commit，就像这样：</p>
<p><img src="/2019/09/03/Git常用命令/1.png" alt></p>
<p>如果我们直接这样 push 的话，会产生三个提交记录，但在工作中我们都会把同一个 feature 的 commit 合并成一个再 push 到远端，所以这时候我们就需要把 test：one、test：two、test：three 这三个提交合并成一个了。具体操作是：</p>
<ol>
<li><code>git rebase -i cbd7376f88cab83c2913a4e5cf6fa3066ac973b9</code></li>
</ol>
<p>这里的 commitID 是指我们想要开始合并的前一个 commit（不参与到本次的合并操作中）。</p>
<ol start="2">
<li>接着进入到命令模式:</li>
</ol>
<p><img src="/2019/09/03/Git常用命令/2.png" alt></p>
<p>前面几行是我们要进行合并的 commit 信息，以 # 开头则表示是注释。这里我们只需要使用到两个命令：</p>
<ul>
<li><code>pick</code>：表示这个 commit 将会被提交。</li>
<li><code>squash</code>：表示这个 commit 会被合并到前一个 commit 中去。</li>
</ul>
<p>在修改之前，得先按 <strong>i 键</strong> 进入到编辑模式，根据需要修改要合并的 commit 前面的命令即可。修改完成后按 <strong>esc</strong> 键回到命令模式，输入 <strong>:wq</strong> 保存并退出。</p>
<ol start="3">
<li>最后会进入到 commit message 的编辑界面：</li>
</ol>
<p><img src="/2019/09/03/Git常用命令/3.png" alt></p>
<p>默认情况下，新生成的 commit message 包含了要合并的 commit 的 commit message，如果不想这样的话可以进入到编辑模式修改，之后再保存退出即可。操作完毕后再使用 git log 查看你就可以发现这三个 commit 已经被合并成一个了！</p>
<p><img src="/2019/09/03/Git常用命令/4.png" alt></p>
<h1 id="查看操作日志"><a href="#查看操作日志" class="headerlink" title="查看操作日志"></a>查看操作日志</h1><p><code>git reflog</code> 和 <code>git log</code> 都可以用来查看日志，但各有侧重。git log 更多是用来查看我们的提交记录，比如提交日期、commit message 等。而 <code>git reflog</code> 更多是用来查看操作记录，记录我们使用了什么命令做了什么事，借此可以查看已经被删除的 commit 记录和 reset 的操作。假如我们想撤销之前的某次操作，我们就可以通过 <code>git reflog</code> 找到那次操作的 commitId，再使用 <code>git reset</code> 回退回去。</p>
<p><img src="/2019/09/03/Git常用命令/5.png" alt></p>
<h1 id="暂存修改"><a href="#暂存修改" class="headerlink" title="暂存修改"></a>暂存修改</h1><p>在每次 commit 和 push 之前我们都需要先 <code>git pull</code> 以防后续的提交和远端仓库产生冲突，但这时候会报 <code>error: cannot pull with rebase: You have unstaged changes</code> 的错误，它会提示我们在拉取代码之前需要先 commit 或者 stash 代码。这时候我们就需要先暂存一下代码了，执行 <code>git stash</code> 让其回到上次 commit 时的状态，等拉取完成后再恢复我们刚才暂存的代码 <code>git stash pop</code>。我们可以暂存多次代码，所以我们也可以通过 <code>git stash list</code> 查看暂存区的暂存情况，并由 <code>git stash apply stash@{该次暂存对应的标号}</code> 来取出特定的暂存内容。（有时候我们开发到一半需要紧急开发另一个 feature 或是修某个 bug，也可以 <code>git stash</code> 暂存目前写一半的代码，等紧急情况处理完成后再恢复暂存继续开发）</p>
<h1 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h1><p>有时候我们把代码改乱了，想要直接恢复到之前的状态的话，就可以使用 <code>git checkout -- &lt;文件名&gt;</code> 来删除某个文件中的更改内容，使其回到上一次提交时的状态。但这只适用于我们还没有把代码提交到暂存区（也就是还没有 <code>git add</code>）的情况。如果我们已经把代码提交到了暂存区的话，就需要先使用 <code>git reset HEAD &lt;文件名&gt;</code> 撤销该文件的暂存，再执行 <code>git checkout -- &lt;文件名&gt;</code> 命令。</p>
<h1 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h1><ul>
<li><p>如果只是提了 commit 还没有 push 的话，我们只需要 <code>git reset &lt;版本号&gt;</code> 回到提交前的状态就可以了。但默认下 <code>git reset</code> 只是撤销了这次提交记录而已，如果我们还需要在 IDE 中也删除该次提交的代码，就要使用到 <code>git reset --hard &lt;版本号&gt;</code> 了。</p>
</li>
<li><p>如果该 commit 也 push 到了远端仓库的话，我们先 <code>git reset --hard &lt;版本号&gt;</code> 撤销了本地的提交后，还需要撤销远端的提交。我们可能会直接使用 <code>git push origin &lt;分支名&gt;</code> 来覆盖掉远端的提交记录，但这样会提示本地的版本落后于远端的版本而无法成功 push，所以就需要 <code>git push origin &lt;分支名&gt; --force</code> 来强制 push，完成后就可以看到远端的该次提交和相关的代码修改都已经被撤销了。</p>
</li>
</ul>
<h1 id="补充提交"><a href="#补充提交" class="headerlink" title="补充提交"></a>补充提交</h1><p>如果使用 Gerrit 的话，我们在提交代码后往往都会让其他人 review，确认没有问题后才把提交合进 master，如果有问题的话则要继续修改代码。当我们修改完代码后常常是使用 <code>git commit --amend</code> 把修改的内容追加在之前的提交上，最后形成一个完整的提交就可以了。如果提 <code>commit --amend</code> 时不需要修改 commit message 的话，可以直接 <code>git commit --amend --no-edit</code> 来跳过后续修改 commit message 的过程。除此之外，我们还可以通过 <code>commit --amend</code> 来修改提交的 commit message，即 <code>git commit --amend -m “新提交消息”</code>。</p>
<h1 id="提取提交"><a href="#提取提交" class="headerlink" title="提取提交"></a>提取提交</h1><p>在团队合作中，通常每一个 feature / bug 都需要新开一个分支，各个分支相互独立互不相干。然而有一次我把两个 feature 都 commit 在了同一个分支上，这时候就需要先撤销提交再重新创建分支提交了。撤销提交的操作在上面已经说到了，接着我们就需要把旧分支上的提交提取到新分支上。虽然旧分支上的提交已经被我们删除掉了，但我们可以通过 <code>git reflog</code> 找到它的 commitId，之后在新分支上执行 <code>git cherry-pick &lt;commitId&gt;</code> 就可以把对应的提交提取到该分支上了。</p>
<h1 id="其他一些常用命令"><a href="#其他一些常用命令" class="headerlink" title="其他一些常用命令"></a>其他一些常用命令</h1><ul>
<li><p>分支</p>
<ul>
<li>创建本地分支: <code>git branch 分支名</code></li>
<li>查看本地分支: <code>git branch</code></li>
<li>查看远端分支: <code>git branch -a</code></li>
<li>切换分支: <code>git checkout 分支名</code></li>
<li>创建并切换分支: <code>git checkout -b branchName</code></li>
<li>删除本地分支: <code>git branch -d 分支名</code></li>
<li>合并本地分支: <code>git merge 分支名（将该分支合并到当前分支）</code></li>
<li>本地分支重命名: <code>git branch -m oldName newName</code></li>
<li>将本地分支推送到远端分支: <code>git push &lt;远端仓库&gt; &lt;本地分支&gt;:&lt;远端分支&gt;</code></li>
</ul>
</li>
<li><p>pull</p>
<ul>
<li>将远端指定分支 拉取到 本地指定分支上: <code>git pull origin &lt;远端分支名&gt;:&lt;本地分支名&gt;</code></li>
<li>将与本地当前分支同名的远端分支 拉取到 本地当前分支上(需先关联远端分支): <code>git pull origin</code></li>
</ul>
</li>
<li><p>push</p>
<ul>
<li>将本地当前分支 推送到 远端指定分支上: <code>git push origin &lt;本地分支名&gt;:&lt;远端分支名&gt;</code></li>
<li>将本地当前分支 推送到 与本地当前分支同名的远端分支上(需先关联远端分支): <code>git push origin</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>如果要 pull / push 的本地分支和远端分支同名的话，可以简写为 <code>git pull/push origin &lt;分支名&gt;</code></p>
</blockquote>
<hr>
<p>未完待续。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue双向数据绑定原理</title>
    <url>/2019/08/17/Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Vue双向数据绑定原理"><a href="#Vue双向数据绑定原理" class="headerlink" title="Vue双向数据绑定原理"></a>Vue双向数据绑定原理</h1><p>完整的实现代码<a href="https://github.com/DangoSky/MVVM" target="_blank" rel="noopener">戳这里</a>。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>Vue 通过数据劫持来实现数据绑定，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty()</a> 来劫持各个数据的 <code>get</code> 和 <code>set</code> 方法。当使用到某一个数据时会触发该数据的 <code>get</code> 方法，所以我们可以在 <code>get</code> 方法中将使用到该数据的指令收集起来（这些就是该数据的依赖）；当修改到这个数据的值时会触发该数据的 <code>set</code> 方法，我们再在 <code>set</code> 方法中去逐个触发这些依赖的更新函数，从而就可以达到 model / view 双向更新的效果。</p>
<p>理解了实现思路后，我们再从这个思路出发，想想实现过程中会遇到什么问题：</p>
<ul>
<li><p><strong>依赖是什么：</strong> 比如 <code>&lt;input type=&quot;text v-model=&quot;inputVal&quot;&gt;</code>，<code>inputVal</code> 是 <code>mvvm</code> 实例中的一个 <code>data</code> 属性，而这个 <code>input</code> 输入框的 <code>v-model</code> 指令使用到了它。所以这个输入框就成了 <code>inputVal</code> 的依赖，当 <code>inputVal</code> 的值改变时，这个依赖也要随着做出相应的改变。因为可能会有多个元素节点多条指令使用到同一个数据，所以数据的依赖是会有多个的。</p>
</li>
<li><p><strong>如何收集：</strong> 是否是某个数据的依赖取决于这个元素节点有没有使用到某个数据，可能是通过 <code>v-</code> 指令，也可能是通过 { {} }。所以就需要我们去遍历整个 <code>Dom</code> 树，判断每一个元素节点 / 文本节点上是否有使用到相关的指令，以及指令上使用到了什么数据。这也就是 <code>compiler.js</code> 的工作——解析各个节点上的指令，并根据不同的指令使用、绑定不同的更新方法。</p>
</li>
<li><p><strong>收集在哪里：</strong> 顾名思义，依赖是依赖于数据而言的，所以我们可以为每一个数据建立一个对象，用一个独一无二的 <code>id</code> 来表示这个数据，用一个 <code>subs</code> 属性（数组）来存放该数据的所有依赖，也就是 <code>observer.js</code> 中的 <code>Dep</code> 构造器。</p>
</li>
</ul>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><pre><code>MVVM
|—— index.html 入口文件
|—— js
|   |—— mvvm.js      构造 MVVM，实现数据代理
|   |—— observer.js  进行数据劫持，构造 Dep 来收集依赖
|   |—— compiler.js  解析、处理指令
|   |—— watcher.js   订阅相关属性的变化并更新视图
</code></pre><h2 id="预期实现"><a href="#预期实现" class="headerlink" title="预期实现"></a>预期实现</h2><ul>
<li style="list-style: none"><input type="checkbox" checked> 可以解析 <code>v-model</code> 指令进行双向数据绑定。</li>
<li style="list-style: none"><input type="checkbox" checked> view / model 改变时，model / view 自动进行更新。</li>
<li style="list-style: none"><input type="checkbox" checked> 可以解析一些简单的指令：{ {} }, <code>v-text</code>, <code>v-class</code>, <code>v-html</code>, <code>v-on</code>。</li>
</ul>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="构建-MVVM"><a href="#构建-MVVM" class="headerlink" title="构建 MVVM"></a>构建 MVVM</h3><p>刚开始写一个 <code>mvvm</code> 的时候会有些无法从下手的感觉，因为看到的都是 <code>observer</code>、<code>compiler</code> 和 <code>watcher</code>。虽然这些是 <code>mvvm</code> 的重要组成部分，也是 Vue 双向数据绑定原理的精髓，但并不是 <code>mvvm</code> 的入口。如果一开始就从 <code>observer</code> 等写起的话，很可能会陷入不知道怎么写、接下来不知道写什么的局面。所以我们需要先把 <code>mvvm</code> 建立好，有了地基后才好有方向指引我们接下来要写什么。</p>
<p>我们可以模仿 Vue 那样，先创建一个 <code>MVVM</code> 实例。</p>
<pre class=" language-js"><code class="language-js">index<span class="token punctuation">.</span>html

<span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MVVM</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  method<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>有了一个 <code>mvvm</code> 实例，我们才可以往里面定义各个 <code>data</code> 属性和 <code>method</code> 函数，像使用 Vue 那样去构建我们的项目。为了能够正常使用这个 <code>vm</code> 实例，我们需要先定义 <code>MVVM</code> 构造器。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">MVVM</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// vue实例的data</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_data <span class="token operator">=</span> options<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// vue实例的各个属性，data、method等</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>options <span class="token operator">=</span> options<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>到这里一个基本的空架子就有了，接下来我们就需要按照先前的实现思路一步步在上面添砖加瓦。不过为了后续操作 <code>data</code> 的方便，我们可以先实现数据代理。先解释一下什么是数据代理吧，比如我们可以通过 a 来操作 c，但由于这种方法比较麻烦，所以我们通过 b 来操作 c，而 b 在这里就是起到了代理的作用。回到 <code>mvvm</code>，我们每次要使用到 <code>data</code> 中的数据时，都得通过 <code>vm._data.xxx</code> 来获取数据，所以我们可以使用 <code>vm</code> 来代理 <code>vm._data</code>，之后我们只需要通过 <code>vm.xxx</code> 就能获取到 <code>vm._data.xxx</code> 了。可能当前这个数据代理的好处不是很明显，但在后续的 <code>observer.js</code> 等文件中操作 <code>data</code> 时就会很方便了。具体的实现也是利用 <code>Object.defineProperty()</code> 改写 <code>get</code> 和 <code>set</code> 方法，当读写 <code>vm.xxx</code> 时，操作 <code>vm._data.xxx</code> 就可以了。</p>
<h3 id="指令解析"><a href="#指令解析" class="headerlink" title="指令解析"></a>指令解析</h3><p>我们暂时先不去写数据劫持的代码，因为涉及到了 <code>Dep</code> 和 <code>Watcher</code>。我们可以先写指令解析和相关的更新操作，把页面渲染出来先。</p>
<p>在解析指令时，因为会频繁操作到 <code>DOM</code>，所以为了提高性能，我们先创建文档片段，在这个文档片段上进行 <code>DOM</code> 操作后再将其插入回 <code>DOM</code> 中。</p>
<pre class=" language-js"><code class="language-js"><span class="token function">nodeToFragment</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> child<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>child <span class="token operator">=</span> node<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> fragment<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>此处的 <code>node</code> 是指我们挂载 <code>MVVM</code> 实例的元素节点，也就是我们初始化时绑定的 <code>el</code>。可能会有人不理解这个 while 循环（包括我），<code>while(child = node.firstChild)</code> 不是一直将 <code>el</code> 的第一个子节点赋值给 child 吗？不会导致死循环吗？这个问题的关键在于，使用 <code>appendChid</code> 方法将原 <code>DOM</code> 树中的节点添加到 <code>DocumentFragment</code> 中时，会同时删除掉原来 <code>DOM</code> 树中的节点！所以当把 <code>el</code> 的所有子节点都添加到文档片段中时，自然也就结束循环了。</p>
<p>有了 <code>el</code> 的文档片段后，我们就可以遍历上面的每一个节点了。此处还要区分节点的类型，HTML 的节点有分为元素节点、文本节点和注释节点等。我们需要通过 <code>nodeType</code> 对元素节点和文本节点都进行判断，</p>
<ol>
<li><p>对于元素节点，我们要遍历节点上的每一个属性，若存在指令（以 <code>v-</code> 开头的属性），则根据不同的指令名进行相应的处理，比如 <code>v-text</code> 指令就进行节点文本替换，<code>v-class</code> 指令则增加节点的 class，<code>v-on</code> 指令就给节点绑定相关的监听函数。</p>
</li>
<li><p>而对于文本节点，我们只需要去匹配它的文本是否具有 { {} }，有的话则将文本内容替换成相应的 <code>data</code> 属性的数据。</p>
</li>
</ol>
<p>这里有几个需要注意的点：</p>
<ul>
<li><p>遍历节点时，需要递归遍历每一个节点。</p>
</li>
<li><p>对于 { {} } 和 <code>v-text</code> 指令，需要考虑到有嵌套对象的情况，比如 a.b.c，要一步步从 <code>data</code> 解析下去获取相应的属性值。</p>
</li>
</ul>
<p>完成到这一步后，我们已经能够使用 <code>MVVM</code> 的指令和数据成功渲染出一个页面了，只不过现在的页面还是静态的，还差最最关键的数据绑定部分。</p>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>我们先捋清楚几个点：</p>
<ul>
<li><p>数据和指令是什么关系：在数据绑定中，指令使用到了 <code>data</code> 中的数据，所以指令是依赖于数据的。当 <code>data</code> 中的数据发生变化时，就需要通知所有依赖于它的指令去进行相关的更新操作。（数据相当于发布者，指令相当于订阅者）</p>
</li>
<li><p>数据和指令的对应关系：这里的对应关系是指一对一，一对多，多对一，多对多这些。一个数据可以被多条指令使用到，所以数据对应于指令，是一对多的关系。一条指令可能使用到多个数据，比如它使用到的数据是 a.b.c，这样的话该指令就成了 a、b、c 三者的依赖，所以指令对应数据，也是一对多的关系。</p>
</li>
</ul>
<p>既然两者对应于彼此都是一对多的关系，那我们就可以为两者都建立一个对象（分别为 <code>Dep</code> 和 <code>Watcher</code>），其中分别用一个 <code>subs</code> 数组和一个 <code>depIds</code> 来收集它们使用到的依赖（指令和数据）。</p>
<h4 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h4><p>现在我们来写数据劫持的代码，我们需要遍历 <code>data</code> 中的每一个数据，注意还需要递归遍历，以防有 a.b.c 这种嵌套的对象。每遍历一个数据时，我们就实例化一个 <code>Dep</code> 用来添加依赖。那么我们什么时候需要添加依赖呢？之前说过我们在 <code>get</code> 方法中添加依赖，当我们解析指令的时候，会去获取这个指令使用到的数据，这时候就触发到了该数据的 <code>get</code> 方法，我们便在此时把依赖添加进 <code>dep</code> 实例中。为了在 <code>observer.js</code> 中能够获取到 <code>watcher.js</code> 中正在解析的指令，所以我们给 <code>Dep</code> 建立一个静态属性 <code>Dep.target</code> 并初始化为 <code>null</code>， 表示当前需要添加到 <code>dep</code> 实例中的依赖。当 <code>Dep.target</code> 不为空时，就把依赖添加到 <code>dep</code> 中的 <code>subs</code> 数组。而在 <code>set</code> 方法中，我们则去更新依赖，遍历 <code>dep</code> 的 <code>subs</code> 数组，执行依赖的更新函数，从而更新视图，这也就到达了 数据 -&gt; 视图 的效果了。</p>
<pre class=" language-js"><code class="language-js"><span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> curVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 递归劫持该对象里面的每一个属性（针对属性值是对象的时候）</span>
  <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>curVal<span class="token punctuation">)</span><span class="token punctuation">;</span>

  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 初始化数据劫持的时候Dep.target为null</span>
      <span class="token comment" spellcheck="true">// 解析指令时，需要为指令对应的每个数据的dep添加watcher，此时Dep.target为该watcher</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 先回到watcher中，把这个dep添加到Dep.target的depIds中，之后再回来</span>
        Dep<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">addDep</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> curVal<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>newVal <span class="token operator">===</span> curVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      curVal <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 监听newVal（针对newVal是对象的时候）</span>
      <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 通知相关的订阅者(watcher)更新</span>
      dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>理清了 <code>Dep</code> 的逻辑，我们再来看 <code>Watcher</code>。其实 <code>Watcher</code> 就是指令，我们使用一个 <code>watcher</code> 实例来表示它，去封装它的指令值、使用到的数据以及更新函数，以便在触发数据的 <code>set</code> 方法时去更新视图。在实例化一个 <code>watcher</code> 的时候，我们需要先把 <code>Dep.target</code> 设置为当前的指令，并根据指令值去 <code>data</code> 中取一遍数据，以便触发数据的 <code>get</code> 方法从而将 <code>watcher</code> 添加进数据的 <code>subs</code> 中。</p>
<p>在上面的代码中，其实并没有直接在 <code>get</code> 方法中给 <code>dep</code> 添加依赖，而是先给 <code>watcher</code> 实例添加 <code>dep</code>， 也就是这句 <code>Dep.target.addDep(dep)</code>。我们先弄清楚一点，<code>Dep</code> 中有一个 <code>subs</code> 数组，用来存储使用到该数据的依赖（数组元素就是 <code>watcher</code> 实例），<code>Watcher</code> 中有一个 <code>depIds</code> 对象，用来存储该指令使用到的数据（对象属性就是 <code>dep</code> 实例，由一个 <code>id</code> 来标志每一个 <code>dep</code>， 使用对象可以避免 <code>depIds</code> 里加入重复的 <code>dep</code>）。所以当一个数据和一个指令产生联系的时候，我们既需要把 <code>dep</code> 添加进 <code>watcher</code> 的 <code>depIds</code> 中，还需要把 <code>watcher</code> 添加进 <code>dep</code> 的 <code>subs</code> 中。而 <code>dep</code> 和 <code>watcher</code> 分属在两个js 文件里，为了能够在 <code>watcher.js</code> 中获取当前的 <code>dep</code>，所以我们需要先在 <code>observer.js</code> 的 <code>get</code> 方法中触发当前 <code>watcher</code> 即 <code>Dep.target</code> 的 <code>addDep</code> 方法，并将当前的 <code>dep</code> 传递过去，再在 <code>addDep</code> 方法中调用 <code>dep</code> 的 <code>addSub</code> 方法。这样就能将 <code>dep</code> 和 <code>watcher</code> 都收集起来了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>MVVM</code> 的实现思路就如上面所述了，现在我们再总结一下整个流程。</p>
<p>我们先创建一个 <code>MVVM</code> 实例，并由 <code>Observer</code> 实现数据劫持，<code>Compiler</code> 实现指令解析。劫持对象时为每个数据创建 <code>Dep</code> 实例作为发布者，解析指令时则为每个指令创建 <code>Watcher</code> 实例，并订阅相应的 <code>Dep</code>（在数据的 <code>get</code> 方法中完成）。当数据变化时，<code>Dep</code> 就通知它的所有订阅者执行它绑定的更新函数来更新视图（在数据的 <code>set</code> 方法中完成）。</p>
<p><img src="https://raw.githubusercontent.com/DMQ/mvvm/master/img/2.png" alt="mvvm实现流程图"></p>
<h2 id="存在的问题（toDo）"><a href="#存在的问题（toDo）" class="headerlink" title="存在的问题（toDo）"></a>存在的问题（toDo）</h2><ul>
<li><p>{ {} } 当作数据绑定处理并有其他文本信息出现时，解析之后其他的文本信息会丢失。</p>
<p>  例如： <code>&lt;p&gt;hello &lt;/p&gt;</code>。</p>
<p>  解决方案：使用正则匹配大括号，只对 { {} } 之间的内容进行更新。但需要考虑到有多个大括号的情况。</p>
</li>
<li><p>在纯文本里面 { {} } 也会被解析成是数据绑定，从而丢失了原来的文本信息。</p>
<p> 例如： <code>&lt;p&gt;这只是一个单纯的&lt;/p&gt;</code>。</p>
<p>   解决方案：解析到 { {} } 时，判断 { {} } 里面的内容是否为 <code>data</code> 中的属性，是的话则处理为数据绑定；没有的话则不进行解析，当作纯文本内容处理。</p>
</li>
<li><p>在同一个标签里无法解析多个 { {} }。</p>
<p> 例如：<code>&lt;p&gt; &lt;/p&gt;</code>。</p>
<p> 解决方案：使用正则匹配 { {} } 之间的内容，改用数组的形式传递给处理指令的函数，批量更新。</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="https://www.bilibili.com/video/av24099073/?p=49" target="_blank" rel="noopener">尚硅谷_Vue核心技术</a></p>
</li>
<li><p><a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener">mvvm</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>elementUI级联选择器踩坑</title>
    <url>/2019/06/14/elementUI%E7%BA%A7%E8%81%94%E9%80%89%E6%8B%A9%E5%99%A8%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>&emsp;&emsp;今天使用 <code>elementUI</code> 的时候踩到坑了，期望的效果如下图所示。每一栋教学楼都有 1-7 层，每一层的教室都为 03-22，以此来选择不同的教室。</p>
<p><img src="/2019/06/14/elementUI级联选择器踩坑/1.png" alt></p>
<p>&emsp;&emsp;参照<a href="https://element.eleme.io/#/zh-CN/component/cascader" target="_blank" rel="noopener">官方文档</a>，我写了如下的级联数据项。</p>
<pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>el-cascader</span>
    <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form.address<span class="token punctuation">"</span></span>
    <span class="token attr-name">:options</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>addressOptions<span class="token punctuation">"</span></span>
    <span class="token attr-name">:props</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{expandTrigger: <span class="token punctuation">'</span>hover<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span>
    <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span>
  <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-cascader</span><span class="token punctuation">></span></span>
</code></pre>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 返回一个 1-7 楼，每楼有 03-22 教室的数组</span>
<span class="token keyword">function</span> <span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> floor <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    floor<span class="token punctuation">.</span>value <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>
    floor<span class="token punctuation">.</span>label <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>
    floor<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token number">22</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
      obj<span class="token punctuation">.</span>value <span class="token operator">=</span> j <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">?</span> <span class="token template-string"><span class="token string">`0</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>j<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span> <span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>j<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
      obj<span class="token punctuation">.</span>label <span class="token operator">=</span> j <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">?</span> <span class="token template-string"><span class="token string">`0</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>j<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span> <span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>j<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
      floor<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>floor<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  addressOptions<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      value<span class="token punctuation">:</span> <span class="token string">'文清楼'</span><span class="token punctuation">,</span>
      label<span class="token punctuation">:</span> <span class="token string">'文清楼'</span><span class="token punctuation">,</span>
      children<span class="token punctuation">:</span> <span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      value<span class="token punctuation">:</span> <span class="token string">'文新楼'</span><span class="token punctuation">,</span>
      label<span class="token punctuation">:</span> <span class="token string">'文新楼'</span><span class="token punctuation">,</span>
      children<span class="token punctuation">:</span> <span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      value<span class="token punctuation">:</span> <span class="token string">'文俊楼'</span><span class="token punctuation">,</span>
      label<span class="token punctuation">:</span> <span class="token string">'文俊楼'</span><span class="token punctuation">,</span>
      children<span class="token punctuation">:</span> <span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      value<span class="token punctuation">:</span> <span class="token string">'文逸楼'</span><span class="token punctuation">,</span>
      label<span class="token punctuation">:</span> <span class="token string">'文逸楼'</span><span class="token punctuation">,</span>
      children<span class="token punctuation">:</span> <span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;从显示上看，上面的代码确实能够起到视角上的效果。但当我点击的时候，却发现不管我怎么选择，只有第三级的数据有显示变化，第一级和第二级的数据并不会随之改变。（下图使用的是我另外在 <a href="https://jsfiddle.net/DangoSky/7osfp265/1/" target="_blank" rel="noopener">jsfiddle</a> 测试时的数据图，所以和上面代码中的数据不一样）</p>
<p><img src="/2019/06/14/elementUI级联选择器踩坑/2.gif" alt></p>
<p>&emsp;&emsp;在查错的时候，我发现更奇怪的现象，如果我给第三级数据加上一个参数（此处是第一级的数据），则第一级数据就会随之改变了，但第二级数据还是原样。</p>
<p><img src="/2019/06/14/elementUI级联选择器踩坑/3.gif" alt></p>
<p>&emsp;&emsp;看着这么神奇的结果，我以为我发现了 <code>elementUI</code> 的 bug，所以我直接给它提了 <a href="https://github.com/ElemeFE/element/issues/16068" target="_blank" rel="noopener">issues</a>，不过还没有人解答。后来我又在 <a href="https://stackoverflow.com/questions/56594223/not-displayed-correctly-in-elementui-cascader" target="_blank" rel="noopener">StackOverflow</a> 提问，终于有人提出了猜想。我总结下就是：所以当我选择 Shanghai / 3 / 03 时，<strong>elementUI 会自上而下搜索 03 这个值所在的位置</strong>，而 03 在 Beijing / 1 中已经存在了，所以会直接显示为 Beijign / 1 / 03，而不会再继续向下搜索 Shanghai 这个数据项（如果 Beijing / 1 中没有 03 这个值，则以此向下搜索 Beijing / 2 、Beijing / 3，如果到最后一项 Beijing / 22 还没有找到的话，再搜索 Shanghai 中的数据）。读者可以在我上面给出的 jsfiddle 链接中测试。</p>
<p>&emsp;&emsp;同理，当我给第三级数据加上一个参数比如第一级的数据时，现在我选择 Shanghai / 3 / 03Shanghai，<code>elementUI</code> 继续从上而下搜索 03Shanghai 这个值，在 Beijing 这个数据项中没有找到，就向下找 Shanghai 这个数据项中是否存在 03Shanghai 这个值。在 Shanghai / 1 中已经找到了 03Shanghai，所以就直接结束搜索，返回的结果就是 Shanghai / 1 / 03Shanghai。</p>
<p>&emsp;&emsp;elementUI 官方文档中并没有注明<strong>级联选择器的搜索方式</strong>，而又刚好我使用的级联数据中第二级和第三级数据是一样的，所以这个坑就被我踩上了（下午谷歌了一个多小时貌似也没有发现遇到这个坑的人）。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>&emsp;&emsp;知道了问题的根源在于级联的数据项是一样的后，我们只要<strong>让每一项的值唯一</strong>就好了。比如第二级的数据带上第一级的数据做为唯一标记，第三级的数据带上第二级的数据做为唯一标记。注意，<strong>是每一项的 value 带上标记，label只是作为视图的显示数据，不需要带上标记</strong>。修改后的代码如下。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getOptions</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> floor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 第二级选项的value带上第一级的数据标记</span>
    floor<span class="token punctuation">.</span>value <span class="token operator">=</span> val <span class="token operator">+</span> <span class="token string">"+"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>
    floor<span class="token punctuation">.</span>label <span class="token operator">=</span> i<span class="token punctuation">;</span>
    floor<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token number">22</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 第三级选项的value带上第二级的数据标记</span>
      obj<span class="token punctuation">.</span>value <span class="token operator">=</span> j <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">?</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">+</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">+0</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>j<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span> <span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">+</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">+</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>j<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
      obj<span class="token punctuation">.</span>label <span class="token operator">=</span> j <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">?</span> <span class="token template-string"><span class="token string">`0</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>j<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span> <span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>j<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
      floor<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>floor<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;到这里上面所描述的 bug 就解决了，级联选择器的结果会随着选择的路径而动态改变。jsfiddle 测试链接<a href="https://jsfiddle.net/n365ecuk/" target="_blank" rel="noopener">在这里</a>。</p>
<p><img src="/2019/06/14/elementUI级联选择器踩坑/4.gif" alt></p>
<p>&emsp;&emsp;接下来还需要解决的问题是，如何把所选择的数据项结果简化成我们想要的格式。我们得到的数据项是 <code>[&quot;理科南教学楼&quot;, &quot;理科南教学楼+6&quot;, &quot;理科南教学楼+6+06&quot;]</code>， 而我们想要的结果是理科南606。一开始我是直接使用 <code>substr</code> 进行字符串截取的，但这样有个问题，不同的教学楼名称长度不同，截取的开始点不能确定。所以我采用正则表达来截取字符串。</p>
<pre class=" language-js"><code class="language-js"><span class="token function">formattingAddress</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>form<span class="token punctuation">.</span>address<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 第一级数据直接获取</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span>  str <span class="token operator">+</span><span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 第二级数据过滤掉第一级的数据</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      str <span class="token operator">+</span><span class="token operator">=</span> val<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/^[\u4e00-\u9fa5]+\+/g</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 第三级数据过滤掉第二级的数据</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      str <span class="token operator">+</span><span class="token operator">=</span> val<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/^[\u4e00-\u9fa5]+\+[0-9]+\+/g</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>form<span class="token punctuation">.</span>address <span class="token operator">=</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;至此，<code>elementUI</code> 级联选择器的使用就照常了，完结撒花。</p>
]]></content>
      <categories>
        <category>踩坑指南</category>
      </categories>
      <tags>
        <tag>踩坑指南</tag>
      </tags>
  </entry>
  <entry>
    <title>面试总结| 字节跳动前端实习</title>
    <url>/2019/06/01/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>&emsp;&emsp;持续了一个小时，全程都在问 CSS 和 JS。</p>
<ul>
<li><p>介绍 flex 布局，flex 是什么属性的缩写<br>&emsp;&emsp;flex属性是 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 的简写，当时我只答出了前两个。</p>
</li>
<li><p>CSS 怎么画一个大小为父元素宽度一半的正方形</p>
<ul>
<li>width 设置百分比</li>
<li>padding 撑高</li>
<li>伪元素设置 <code>margin-top: 100%</code>撑高（这个当时没想到，只答了前两个）</li>
<li>如果只是要相对于 body 而言的话，还可以使用 vw 和 vh</li>
</ul>
</li>
<li><p>实现两栏布局的方式</p>
<ul>
<li>flex</li>
<li>grid</li>
<li>table</li>
<li>float + 负 margin</li>
</ul>
</li>
<li><p>css 的动画有哪些</p>
<ul>
<li>animation</li>
<li>transition</li>
</ul>
</li>
<li><p>transform 的属性设置顺序可以改变吗<br>&emsp;&emsp;不可以，比如 translate 和 rotate，因为旋转后 x 轴和 y 轴也会跟着旋转，所以先平移后旋转，和先旋转后平移得到的结果是不一样的。<br>&emsp;&emsp;既然提到了 transform，我就顺带说了 transform 的副作用。子元素的属性比如宽高等单位设置为百分比，是相对于它第一个带有定位的父元素而言的。而如果它的父元素没有设置定位但设置了 transform 的话，也能起到类似定位的效果。因此如果设置了固定定位的元素的父元素带有 transform 的话，此时它的固定定位不再是相对于浏览器视口而言的，而是相对于这个带 transform 的父元素。</p>
</li>
<li><p>防抖和节流的区别，手写简易版本的防抖和节流</p>
</li>
<li><p>事件委托，手写代码<br>&emsp;&emsp;给出一个函数 <code>fn(parent, targetTag, event, handle)</code>，parent 是要绑定事件的父元素，targetTag 是要触发事件的目标元素，event 是要监听的事件类型，handle 是监听函数。这里的主要问题在于触发元素可能是 targetTag 的子孙元素（比如 DOM 结构是 ul &gt; li &gt; div &gt; span，parent 是 ul， targetTag 是 div，触发 span 也得执行 handle），所以不能单单用 <code>e.target.tagName.toLowerCase() === targetTag</code> 来判断，需要循环或者递归去寻找 targetTag 是否 是 e.target 的父亲节点或祖先结点。</p>
</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> targetTag<span class="token punctuation">,</span> event<span class="token punctuation">,</span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  parent<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    e <span class="token operator">=</span> e <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
    <span class="token keyword">let</span> ele <span class="token operator">=</span> e<span class="token punctuation">.</span>target <span class="token operator">||</span> e<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">search</span><span class="token punctuation">(</span>ele<span class="token punctuation">,</span> targetTag<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 向上寻找父亲祖先节点</span>
<span class="token keyword">function</span> <span class="token function">search</span><span class="token punctuation">(</span>ele<span class="token punctuation">,</span> targetTag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>ele<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">'body'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ele<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> targetTag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ele <span class="token operator">=</span> ele<span class="token punctuation">.</span>parentNode<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;<a href="https://jsfiddle.net/DangoSky/0qwkrp6a/2/" target="_blank" rel="noopener">可以戳这里进行实验</a>。</p>
<ul>
<li>模拟实现一个简易的 jQuery 的 $ 函数来获取 DOM 节点，例如 <code>$(&#39;#a .b p&#39;)</code>，需要取到相应的 p 标签</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 获取DOM结点</span>
<span class="token comment" spellcheck="true">// 或者直接使用 querySelector</span>
<span class="token keyword">function</span> <span class="token keyword">get</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> ele<span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'#'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token punctuation">{</span>
    ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ele<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 查找target是否是parent的子孙元素</span>
<span class="token keyword">function</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 先在document中找到所有的target，再判断它们的父亲祖先元素是否位parent</span>
  <span class="token keyword">let</span> nodes <span class="token operator">=</span> <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 使用id获取结点时得到的是单个结点，使用class获取时则是一个节点集合，所以统一转换为集合的形式方便遍历</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>nodes<span class="token punctuation">.</span>length <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    nodes <span class="token operator">=</span> <span class="token punctuation">[</span>nodes<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token operator">=</span>nodes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> cur <span class="token operator">=</span> nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 层层遍历cur的父亲祖先节点</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token string">'body'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>cur <span class="token operator">===</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>parentNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> undefined<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_$</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> ele <span class="token operator">=</span> <span class="token keyword">get</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ele <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>ele<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ele <span class="token operator">===</span> undefined<span class="token punctuation">)</span>  <span class="token keyword">return</span> undefined<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ele<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;面试的时候我回答的思路大致如上，不过当时没有考虑很多，写的代码还有一些细节错误 Orz。当时面试官提出的问题是，比如 <code>#a .b p</code>，如果这个 p 标签是 .c 的孙节点的话怎么办。我就说循环或递归去找 p 标签的父亲节点，判断 .c 是否是 p 标签的祖先节点。但是面试官说如果 DOM 节点一多的话这样会很耗性能，问有没有其他的方法，我想了一会没想出来就直接说我不会了。结束的时候面试官说了句其实不用那么麻烦，只用 XXX 就够了，当时那句话我没听清楚，以为有什么 api 可以直接获取一个 DOM 节点的所有父级元素。然而现在才发现这道题其实根本不用写那么多，只需要短短的 <code>return document.querySelector(str)</code> 就可以了！！！ <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector#%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8" target="_blank" rel="noopener">querySelector</a> 完全可以实现 jQuery 中 $ 的效果。我… </p>
<p><img src="/2019/06/01/面试总结-字节跳动前端实习/1.png" alt></p>
<h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>&emsp;&emsp;一面之后隔了十分钟左右二面的面试官就上线了，只进行了四十分钟（感觉凉凉）。一来先是常规的自我介绍（一面的时候没有自我介绍），介绍完之后直接问除了前端之外还有没有学其他的，计算机组成会吗（Orz）。我直接回答只会那么一点点，仅限于了解而已。然后面试官开始出题，<code>0.1 + 0.2</code> 等于多少，这个还好我之前写过一篇博客捣鼓过就直接答出来并解释一下为什么，还好面试官后面就没有再问计算机组成方面的问题了，不然可 hold 不住。</p>
<ul>
<li>JS 的数据类型</li>
<li>JS 的整数是怎么表示的<br>&emsp;&emsp;听到这个问题我有些懵，虽然问题很明确，但就是不知道这个问题是考察哪方面的问题。所以我只能牛头不对马嘴地说 JS 是弱语言类型不区分整数和浮点数云云的，结果自然是被面试官戳穿了我是在转移话题。我老实回答我 get 不到这个问题的点（因为我真的不知道要怎么回答啊，二进制？），但是面试官表示他觉得他问得已经足够明确了（听到这句话我就觉得我要凉了 Orz），如果我不知道怎么回答可以直接说不会，他接着问下一题就行。于是我就直接表示我不了解了。</li>
<li>闭包</li>
<li><code>symbol</code> 有什么用处<br>&emsp;&emsp;可以用来表示一个独一无二的变量防止命名冲突。但是面试官问还有吗？我没想出其他的用处就直接答我不知道了，还可以利用 <code>symbol</code> 不会被常规的方法（除了 <code>Object.getOwnPropertySymbols</code> 外）遍历到，所以可以用来模拟私有变量。</li>
<li>ES6 的遍历器了解吗，<code>symbol.iterator</code> 是用来做什么的<br>&emsp;&emsp;主要用来提供遍历接口，布置了 <code>symbol.iterator</code> 的对象才可以使用 <code>for···of</code> 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。</li>
<li><code>localstorage</code>、<code>sessionstorage</code>、<code>indexDB</code> 的区别</li>
<li>为什么用 <code>canvas</code><br>&emsp;&emsp;因为简历上写了之前用 <code>jQuery</code> 做的中国象棋，棋盘是用 canvas 画的。我就回答说当时想着顺带实践一下 <code>canvas</code>，所以就没有使用 border 来画棋盘。然而面试官说 <code>jQuery</code> 已经被淘汰了问我为什么还要学 <code>jQuery</code>，我解释说因为上学期开始学的时候还什么都不会，经常看到 <code>jQuery</code> 这个名字就顺带学了一点，但现在已经没用 <code>jQuery</code> 了。</li>
<li>手写 bind</li>
<li>区间排序<br>&emsp;&emsp;面试官给了一个情景，大致的意思就是给了一个二维数组，比如 <code>[[20, 30], [1, 10], [10, 20]]</code>，每个数组元素表示一个区间，区间之间不重叠。要求写一个函数来排序这个二维数组，使得这个二维数组表示的区间有序，例如 <code>[[1, 10], [10, 20], [20, 30]]</code>。</li>
</ul>
<p>&emsp;&emsp;面试的时候我的思路是先将每一个数组元素的第一个值作为下标存储进一个临时数组，值为它所在原数组的索引，之后再遍历数组根据值从小到大排序。然而当时我遇到的问题是，数组元素的值是被我作为下标存进临时数组的，要怎么给这个临时数组排序？用 map ？当时我就这里想了许久也没想出来，最后因为面试官给的例子中区间的间隔是 10，所以我就赖着头皮直接从 0 开始每次累加 10 了。结果自然是被面试官戳破了，他说其实就是简单的排序而已（想桶排序那样）。然而我以为他是在考冒泡这些排序算法就往十大排序上去想解决方法，不过没想出来 Orz。之后面试官就问我有没有什么想问的，我问了我表现得怎么样有什么需要改进的吗。面试官说我面试得还不错（估计是安慰吧，我觉得我答得很糟糕啊啊啊），不过对问题的解决方法有点单一，思维没能转过来。直到现在我才理解面试官这句话的意思，因为现在我重新看这道区间排序，没想多久就想出方法了啊，直接一个 <code>sort</code> 函数排序就可以了啊啊啊。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">39</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">999</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">79</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">fn</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;为什么当时就是没有想到 sort 函数啊 Orz，在那里瞎折腾那么久。估计也是因为这个所以二面只持续了四十分钟吧。当天下午（2019.5.31）六点多 HR 就打电话过来进行了几分钟的沟通，说我通过了前面两轮技术面，接着问了一些个人情况啥的。我问还有下一轮面试吗，HR 说没有，不过等下周会有进一步的沟通（应该是 HR 面？）。虽然是这么说，但我感觉有些虚啊，我看网上一些字节跳动的面经有好些实习生就挂在 HR 面的，评论说是综合前面的技术面才会被挂的，或者是公司找到了更合适的人选。前面两轮技术面虽然是过了，但自我感觉还有很多不足啊，特别是那两三道手写代码的题，简直了（简单的方法没想到，就想到复杂的解法 Orz）。哎，还是等下周 HR 面后看结果吧，估计也还得等一个多星期才能出最后结果，到时再来补充吧（但愿能过 🙏）。</p>
<h1 id="人生中的第二个offer"><a href="#人生中的第二个offer" class="headerlink" title="人生中的第二个offer"></a>人生中的第二个offer</h1><p>2019.6.3：</p>
<p>&emsp;&emsp;啦啦啦，本来以为这周会有 HR 面的，结果中午刚放学就接到了 HR 的电话。看到那从北京打来的电话号码的时候我心一紧，以为是 HR 面来了。结果刚接电话 HR 就问我有没有时间，要进行五分钟左右的沟通。我有些惊讶于 HR 面难道只需要五分钟。结果就被 HR 接下来的一句 “你已经通过了 offer 审批，现在准备发录取邮件” 给吓到了。没有 HR 面的？？接着就确定了下入职时间，本来预期 7 月 6 号入职的，不过因为公司周末不办入职手续，所以就推到 8 号星期一再入职啦。接着又询问了一些信息就愉快又兴奋地结束通话啦。</p>
<p>&emsp;&emsp;下午又给 HR 发信息问了一些情况，待遇、上班时间啥的，不得不说字节跳动的待遇真的好好啊啊啊！！弄得我都不想回来上学只想在那边实习了。预计会实习三个月左右吧，应该会请一个月的假，大概国庆假期过后就回学校，目前我是这么打算的，HR 也说需要实习三个月。开心过后麻烦就来了，在北京那租房好像很麻烦啊，押一付三啥的，还要找人合租，不然一个人住房租可 hold 不住。希望可以尽快找到合适的房子和室友啊！不然到时还没找到房子就更麻烦了。</p>
<p>&emsp;&emsp;这个七月，帝都 🛫🛫🛫 </p>
<p>&emsp;&emsp;真是让人期待啊~</p>
<p>&emsp;&emsp;冲鸭！！！</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript：十大排序的算法思路和代码实现</title>
    <url>/2019/05/28/JavaScript%EF%BC%9A%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%9A%84%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%E5%92%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&emsp;&emsp;本文内容包括：(双向)冒泡排序、选择排序、插入排序、快速排序(填坑和交换)、归并排序、桶排序、基数排序、计数排序(优化)、堆排序、希尔排序。大家可以<a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">在这里测试代码</a>。更多 <code>leetcode</code> 的 <code>JavaScript</code> 解法也可以在我的算法仓库中找到，欢迎查看~</p>
<p>&emsp;&emsp;另外附上十大排序的 <a href="https://github.com/DangoSky/algorithm/blob/master/DataStructure-homework/Experiment%EF%BC%88C%2B%2B%EF%BC%89/%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F.cpp" target="_blank" rel="noopener">C++版本</a>，因为写惯了<code>JavaScript</code>，所以这个 C++版本写得有些丑，请不要介意呀。</p>
<p>&emsp;&emsp;先推荐一个<a href="https://visualgo.net/en" target="_blank" rel="noopener">数据结构和算法动态可视化工具</a>，可以查看各种算法的动画演示。下面开始正文。</p>
<p><img src="https://user-gold-cdn.xitu.io/2016/11/29/4abde1748817d7f35f2bf8b6a058aa40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。   </p>
<p>最好：<code>O(n)</code>，只需要冒泡一次数组就有序了。<br>最坏：<code>O(n2)</code><br>平均：<code>O(n2)</code></p>
<h2 id="单向冒泡"><a href="#单向冒泡" class="headerlink" title="单向冒泡"></a>单向冒泡</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 如果一轮比较中没有需要交换的数据，则说明数组已经有序。主要是对[5,1,2,3,4]之类的数组进行优化</span>
    <span class="token keyword">let</span> mark <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>len<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        mark <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="双向冒泡"><a href="#双向冒泡" class="headerlink" title="双向冒泡"></a>双向冒泡</h2><p>普通的冒泡排序在一趟循环中只能找出一个最大值或最小值，双向冒泡则是多一轮循环既找出最大值也找出最小值。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">bubbleSort_twoWays</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> high <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> mark <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 找到最大值放到右边</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>low<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        mark <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    high<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 找到最小值放到左边</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span>high<span class="token punctuation">;</span> j<span class="token operator">></span>low<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        mark <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    low<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>和冒泡排序相似，区别在于选择排序是将每一个元素和它后面的元素进行比较和交换。  </p>
<p>最好：<code>O(n2)</code><br>最坏：<code>O(n2)</code><br>平均：<code>O(n2)</code></p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>以第一个元素作为有序数组，其后的元素通过在这个已有序的数组中找到合适的位置并插入。</p>
<p>最好：<code>O(n)</code>，原数组已经是升序的。<br>最坏：<code>O(n2)</code><br>平均：<code>O(n2)</code></p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      j<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>选择一个元素作为基数（通常是第一个元素），把比基数小的元素放到它左边，比基数大的元素放到它右边（相当于二分），再不断递归基数左右两边的序列。   </p>
<p>最好：<code>O(n * logn)</code>，所有数均匀分布在基数的两边，此时的递归就是不断地二分左右序列。<br>最坏：<code>O(n2)</code>，所有数都分布在基数的一边，此时划分左右序列就相当于是插入排序。<br>平均：<code>O(n * logn)</code>    </p>
<p>参考学习链接：<br><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html" target="_blank" rel="noopener">算法 3：最常用的排序——快速排序</a><br><a href="https://blog.csdn.net/insistGoGo/article/details/7785038" target="_blank" rel="noopener">三种快速排序以及快速排序的优化</a></p>
<h2 id="快速排序之填坑"><a href="#快速排序之填坑" class="headerlink" title="快速排序之填坑"></a>快速排序之填坑</h2><p>从右边向中间推进的时候，遇到小于基数的数就赋给左边（一开始是基数的位置），右边保留原先的值等之后被左边的值填上。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 递归排序基数左右两边的序列</span>
  <span class="token keyword">function</span> <span class="token function">recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 将小于基数的数放到基数左边，大于基数的数放到基数右边，并返回基数的位置</span>
  <span class="token keyword">function</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 取第一个数为基数</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> temp<span class="token punctuation">)</span>  right<span class="token operator">--</span><span class="token punctuation">;</span>
      arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span>  left<span class="token operator">++</span><span class="token punctuation">;</span>
      arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 修改基数的位置</span>
    arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">recursive</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="快速排序之交换"><a href="#快速排序之交换" class="headerlink" title="快速排序之交换"></a>快速排序之交换</h2><p>从左右两边向中间推进的时候，遇到不符合的数就两边交换值。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">quickSort1</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> p <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> q <span class="token operator">=</span> right<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">&lt;=</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">&lt;=</span> q <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span>  p<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">&lt;=</span> q <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span>  q<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">&lt;=</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 交换值后两边各向中间推进一位</span>
        p<span class="token operator">++</span><span class="token punctuation">;</span>
        q<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 修改基数的位置</span>
    <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> q<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">recursive</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>递归将数组分为两个序列，有序合并这两个序列。   </p>
<p>最好：<code>O(n * logn)</code><br>最坏：<code>O(n * logn)</code><br>平均：<code>O(n * logn)</code>   </p>
<p>参考学习链接：<br><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 有序合并两个数组</span>
  <span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> r1<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> r2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> l1<span class="token punctuation">,</span> j <span class="token operator">=</span> l2<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> r1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">?</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> r1<span class="token punctuation">)</span>  arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r2<span class="token punctuation">)</span>  arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 将有序合并后的数组修改回原数组</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> t<span class="token operator">&lt;</span>index<span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nums<span class="token punctuation">[</span>l1 <span class="token operator">+</span> t<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 递归将数组分为两个序列</span>
  <span class="token keyword">function</span> <span class="token function">recursive</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 比起(left+right)/2，更推荐下面这种写法，可以避免数溢出</span>
    <span class="token keyword">let</span> mid <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> left<span class="token punctuation">;</span>
    <span class="token function">recursive</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">recursive</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> nums<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">recursive</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>取 n 个桶，根据数组的最大值和最小值确认每个桶存放的数的区间，将数组元素插入到相应的桶里，最后再合并各个桶。   </p>
<p>最好：<code>O(n)</code>，每个数都在分布在一个桶里，这样就不用将数插入排序到桶里了(类似于计数排序以空间换时间)。<br>最坏：<code>O(n2)</code>，所有的数都分布在一个桶里。<br>平均：<code>O(n + k)</code>，k表示桶的个数。   </p>
<p>参考学习链接：<br><a href="http://zhuanlan.51cto.com/art/201811/586129.htm" target="_blank" rel="noopener">拜托，面试别再问我桶排序了！！！</a></p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 桶的个数，只要是正数即可</span>
  <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 计算每个桶存放的数值范围，至少为1，</span>
  <span class="token keyword">let</span> range <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token punctuation">(</span>max <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">/</span> num<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 创建二维数组，第一维表示第几个桶，第二维表示该桶里存放的数</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token function">Array</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  nums<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>val <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 计算元素应该分布在哪个桶</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">/</span> range<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 防止index越界，例如当[5,1,1,2,0,0]时index会出现5</span>
    index <span class="token operator">=</span> index <span class="token operator">>=</span> num <span class="token operator">?</span> num <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">:</span> index<span class="token punctuation">;</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 插入排序，将元素有序插入到桶中</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> temp<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> val <span class="token operator">&lt;</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      temp<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
      j<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    temp<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment" spellcheck="true">// 修改回原数组</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>concat<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  nums<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>使用十个桶 0-9，把每个数从低位到高位根据位数放到相应的桶里，以此循环最大值的位数次。<strong>但只能排列正整数，因为遇到负号和小数点无法进行比较</strong>。   </p>
<p>最好：<code>O(n * k)</code>，k表示最大值的位数。<br>最坏：<code>O(n * k)</code><br>平均：<code>O(n * k)</code>   </p>
<p>参考学习链接：    </p>
<p><a href="https://www.cnblogs.com/sun/archive/2008/06/26/1230095.html" target="_blank" rel="noopener">算法总结系列之五: 基数排序(Radix Sort)</a></p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">radixSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 计算位数</span>
  <span class="token keyword">function</span> <span class="token function">getDigits</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sum<span class="token operator">++</span><span class="token punctuation">;</span>
      n <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 第一维表示位数即0-9，第二维表示里面存放的值</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> maxDigits <span class="token operator">=</span> <span class="token function">getDigits</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 用0把每一个数都填充成相同的位数</span>
    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span>maxDigits<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 先根据个位数把每一个数放到相应的桶里</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    arr<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 循环判断每个位数</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>maxDigits<span class="token number">-2</span><span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 循环每一个桶</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span><span class="token number">9</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
      <span class="token keyword">let</span> len <span class="token operator">=</span> temp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 根据当前的位数i把桶里的数放到相应的桶里</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>len<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> str <span class="token operator">=</span> temp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        temp<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        arr<span class="token punctuation">[</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 修改回原数组</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>concat<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  nums<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">+</span>res<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
</code></pre>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>以数组元素值为键，出现次数为值存进一个临时数组，最后再遍历这个临时数组还原回原数组。因为 JavaScript 的数组下标是以字符串形式存储的，所以<strong>计数排序可以用来排列负数，但不可以排列小数</strong>。<br>最好：<code>O(n + k)</code>，k是最大值和最小值的差。<br>最坏：<code>O(n + k)</code><br>平均：<code>O(n + k)</code></p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">countingSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 装桶</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    arr<span class="token punctuation">[</span>temp<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>temp<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 还原原数组</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>min<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>max<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nums<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
      arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="计数排序优化"><a href="#计数排序优化" class="headerlink" title="计数排序优化"></a>计数排序优化</h2><p>把每一个数组元素都加上 <code>min</code> 的相反数，来避免特殊情况下的空间浪费，通过这种优化可以把所开的空间大小从 <code>max+1</code> 降低为 <code>max-min+1</code>，<code>max</code> 和 <code>min</code> 分别为数组中的最大值和最小值。   </p>
<p>比如数组 <code>[103, 102, 101, 100]</code>，普通的计数排序需要开一个长度为 104 的数组，而且前面 100 个值都是 <code>undefined</code>，使用该优化方法后可以只开一个长度为 4 的数组。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">countingSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 加上最小值的相反数来缩小数组范围</span>
  <span class="token keyword">let</span> add <span class="token operator">=</span> <span class="token operator">-</span>min<span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    temp <span class="token operator">+</span><span class="token operator">=</span> add<span class="token punctuation">;</span>
    arr<span class="token punctuation">[</span>temp<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>temp<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>min<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>max<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span>add<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>temp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nums<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
      temp<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>根据数组建立一个堆（类似完全二叉树），每个结点的值都大于左右结点（最大堆，通常用于升序），或小于左右结点（最小堆，通常用于降序）。对于升序排序，先构建最大堆后，交换堆顶元素（表示最大值）和堆底元素，每一次交换都能得到未有序序列的最大值。重新调整最大堆，再交换堆顶元素和堆底元素，重复 n-1 次后就能得到一个升序的数组。  </p>
<p>最好：<code>O(n * logn)</code>，logn是调整最大堆所花的时间。<br>最坏：<code>O(n * logn)</code><br>平均：<code>O(n * logn)</code>   </p>
<p>参考学习链接：<br><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">常见排序算法 - 堆排序 (Heap Sort)</a><br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序</a></p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 调整最大堆，使index的值大于左右节点</span>
  <span class="token keyword">function</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> index<span class="token punctuation">,</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 交换后可能会破坏堆结构，需要循环使得每一个父节点都大于左右结点</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> max <span class="token operator">=</span> index<span class="token punctuation">;</span>
      <span class="token keyword">let</span> left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 左节点</span>
      <span class="token keyword">let</span> right <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 右节点</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>max<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span>  max <span class="token operator">=</span> left<span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>max<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>  max <span class="token operator">=</span> right<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 如果左右结点大于当前的结点则交换，并再循环一遍判断交换后的左右结点位置是否破坏了堆结构（比左右结点小了）</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">!==</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        index <span class="token operator">=</span> max<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 建立最大堆</span>
  <span class="token keyword">function</span> <span class="token function">buildHeap</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 注意这里的头节点是从0开始的，所以最后一个非叶子结点是 parseInt(nums.length/2)-1</span>
    <span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> size <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 从最后一个非叶子结点开始调整，直至堆顶。</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>start<span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">adjustHeap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">buildHeap</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 循环n-1次，每次循环后交换堆顶元素和堆底元素并重新调整堆结构</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">adjustHeap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。 </p>
<p>最好：<code>O(n * logn)</code>，步长不断二分。<br>最坏：<code>O(n * logn)</code><br>平均：<code>O(n * logn)</code>   </p>
<p>参考学习链接：<br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">图解排序算法(二)之希尔排序</a></p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 初始步数</span>
  <span class="token keyword">let</span> gap <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 逐渐缩小步数</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 从第gap个元素开始遍历</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>gap<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 逐步其和前面其他的组成员进行比较和交换</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span>i<span class="token operator">-</span>gap<span class="token punctuation">;</span> j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">-</span><span class="token operator">=</span>gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    gap <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>gap <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2019/05/20/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;常常听到防抖和节流这两个名词，但一直只是有个粗浅的认识而已，现在终于腾出时间来一探这两者的究竟啦。先用一句话概括这两者：防抖和节流都是为了<strong>限制函数的执行频率，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现页面延迟、假死或卡顿的现象</strong>。主要应用于一些会被频繁触发的事件中，例如<code>input</code>输入框的监听，<code>resize</code>，<code>scroll</code>，<code>mousemove</code>，<code>keyup</code>等。</p>
<p>&emsp;&emsp;下面分别介绍防抖和节流的异同和实现方式，其中的函数实现主要参照<code>underscore</code>，再根据自己的一些理解写成的，诸位看官可以翻读<a href="https://github.com/jashkenas/underscore/blob/master/underscore.js" target="_blank" rel="noopener">underscore</a>的源码。</p>
<h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>&emsp;&emsp;防抖其实就是当触发一个事件后，如果在指定时间 n 内再次触发该事件，则以新的触发时间为准重新计算执行时间，保证每次触发都会等到 n 秒后才执行并且不会累计触发（持续触发的情况下只会执行一次）。</p>
<p>&emsp;&emsp;举个栗子，我们常常会给输入框绑定一个<code>input</code>监听函数，根据用户的输入内容来发送<code>Ajax</code>请求实时显示搜索结果。但这样有个问题，每次用户敲一下键盘都会触发到监听函数，造成监听函数被频繁地触发到了（尤其是输入中文的时候），如果监听函数是发送<code>Ajax</code>请求的话那简直就是场灾难。这时候防抖就可以派上用场了，我们设置一个定时器<code>setTimeout</code>让监听函数在指定的延迟时间比如 1s 后才执行，如果在定时器计时的这 1s 内再次触发了事件，则清除之前的定时器重新开始计时，保证监听函数一定会在每次触发的 1s 后才执行。这样监听<code>input</code>事件时就不会频繁地触发到监听函数了，大大优化了页面性能。其他的监听事件如<code>scroll</code>和<code>mousemove</code>也是如此。</p>
<p>&emsp;&emsp;我们先来看看普通的<code>input</code>监听函数的执行情况，从下图中可以看到我只是输入短短的 “世界很温柔” 五个字，监听函数却执行了多达 17 次。可以<a href="https://jsfiddle.net/DangoSky/4dyn1pv0/12/" target="_blank" rel="noopener">戳这里进行实验</a>。</p>
<p><img src="/2019/05/20/防抖和节流/1.gif" alt></p>
<p>&emsp;&emsp;下面我们先来实现一个简单版的防抖，抓住每次触发事件时都会先清除掉之前的定时器再开始计时，我们不难写出下面这几行代码。需要注意的是要使用<code>apply</code>或<code>call</code>来显示绑定监听函数（以下简称<code>fn</code>）的 this 为当前绑定监听函数的 DOM 对象，否则<code>fn</code>里的 this 会指向 window。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 为fn绑定this指向</span>
    <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 先清空定时器再重新开始计时</span>
    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;上面基本版的防抖，是每次触发事件后都会等过了指定的延迟时间才执行 fn，但有时候我们需要让事件触发的时候马上执行 fn，所以我们可以给<code>debounce</code>函数增加第三个参数 immediate 来选择是否触发事件后马上执行 fn。当 immediate 为 true 时，第一次触发事件的时候 timer 因为被初始化成了 null，所以会马上执行 fn。而每一次触发的时候都会重新将 timer 指向一个定时器，使 timer 在指定的延迟时间后重置为 null，从而控制 fn 可以再次执行。当 immediate 为 false 时，则和上文的基本版防抖一样。修改后的代码如下，实现效果可以<a href="https://jsfiddle.net/DangoSky/4dyn1pv0/14/" target="_blank" rel="noopener">戳这里查看</a>。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>  <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 触发后立即执行</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 如果两次触发的间隔小于wait，此时timer还不为null，不执行fn</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">// wait时间后把timer重新设置为null，表示可以再次执行fn了</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 触发后延时执行</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>&emsp;&emsp;说完防抖我们再说说节流，节流和防抖功能大致相同，不同点在于如果持续触发一个事件，防抖只会执行一次 fn，而节流则是每隔指定的时间就执行一次，保证每次执行 fn 的间隔时间相同。防抖和节流都可以降低函数的执行频率，而实际写代码的时候是选择防抖还是节流，还得要取决于具体的需求。</p>
<p>&emsp;&emsp;节流有两种实现方式，一种是使用时间戳，另一种是使用定时器。使用时间戳的话，因为开始时间被初始化为 0，所以第一次触发时会马上执行 fn，并且停止触发后不会再执行。而使用定时器的话，第一次触发则会延迟执行，而停止触发后因为还有定时器的存在，所以会再执行一次 fn。下面给出两种实现方式的代码。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 使用时间戳</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> startTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 当前触发和上一次触发的时间间隔</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>now <span class="token operator">-</span> startTime <span class="token operator">></span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
      startTime <span class="token operator">=</span> now<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 使用定时器</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>timer <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 实际上只要把fn执行代码放到setTimeout外就可以使第一次触发立即执行了，但停止触发后就不会再执行一次了</span>
        fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;如果结合两者，就可以设置一个第一次触发就能够马上执行，最后一次触发后还能再执行一次的节流函数了。这里主要是使用一个 remaining 来计算还剩下多少时间才能够执行 fn，如果 remaining 小于等于 0，则说明距离上一次的 fn 执行时间已超出指定的间隔时间，此时可以再次执行 fn。如果 remaining 大于 0，则说明当前还没有达到间隔时间，若此时没有定时器在计时等待执行 fn，则设置一个定时器在稍后执行 fn，否则不再重新设置定时器。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> startTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// remaining表示还剩下多少时间就能执行fn</span>
    <span class="token keyword">let</span> remaining <span class="token operator">=</span> wait <span class="token operator">-</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 为了第一次触发能够马上执行</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>remaining <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 需要先清空定时器，否则会重复执行</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
      startTime <span class="token operator">=</span> now<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 为了最后一次触发还能够再执行一次</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 如果不能马上执行fn并且定时器为空（表示前面没有定时器在计时）才开始计时等待执行</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>timer <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
          timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
          startTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> remaining<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;再进一步，我们还可以跟防抖一样，给节流函数设置第三个参数来传入一个对象，其中 leading 属性表示第一次触发是否马上执行 fn，trailing 属性表示最后一次触发是否会再执行一次 fn。我们先看看具体的实现代码，注释部分表示和上面代码的不一样之处。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 若没有传递options，则默认两者都开启</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    options <span class="token operator">=</span> <span class="token punctuation">{</span>
      leading<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      trailing<span class="token punctuation">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> startTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 若设置第一次触发不马上执行，则将开始时间设置为当前时间</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>startTime <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>leading <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      startTime <span class="token operator">=</span> now<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> remaining <span class="token operator">=</span> wait <span class="token operator">-</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>remaining <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
      startTime <span class="token operator">=</span> now<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 如果设置最后一次触发不再执行的话，则直接使用时间戳法就够了</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>timer <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>trailing <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
          timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
          <span class="token comment" spellcheck="true">// 需要将开始时间置为0，才能在下一次触发时将开始时间置为now，即不马上执行</span>
          startTime <span class="token operator">=</span> options<span class="token punctuation">.</span>leading <span class="token operator">===</span> <span class="token boolean">false</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> remaining<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;这里的实现思想是，通过是否重置初始的 startTime 为触发的当前时间来控制第一次触发是否马上执行 fn。如果最后一次触发不再执行一次 fn，则直接使用时间戳法就够了，否则还得使用定时器。可能定时器里这句<code>startTime = options.leading === false ? 0 : new Date()</code>不太容易理解，这里解释一下。当一次持续触发过后，startTime 还会保留着上次的执行时间，如果等一会我再次触发它，因为此时 remaining 小于等于 0，所以第二次触发会马上执行。因此当设置了 options.leading 为 false 时就需要把 startTime 置为 0，才能使第二次触发能够把跟第一次触发一样把 startTime 重置为当前触发时间，从而不马上执行。</p>
<p>&emsp;&emsp;需要注意的是，leading 和 trailing 两者不能同时设置为 false，否则第二次触发时还是会马上执行 fn。这是因为当 trailing 为 false 时，执行事件没有使用到定时器。也就同上面解释的，最后一次执行后没有把 startTime 置为 0，startTime 还是保留着上次的执行时间。导致下一次触发时 remaining 小于等于 0 所以会立即执行 fn。</p>
<p>&emsp;&emsp;不得不说这是一个很大的 bug，在 underscore 的 issues 里也有人提出过<a href="https://github.com/jashkenas/underscore/issues/2589" target="_blank" rel="noopener">这个问题</a>，但作者似乎不理解为什么要把 leading 和 trailing 都设置为 false，作者的原意就是 leading 和 trailing 必须至少一个为 true。作者原话：</p>
<blockquote>
<p>Why are both leading and trailing false? One of them should be true.</p>
</blockquote>
<p>&emsp;&emsp;emmm，我不太理解作者的想法，难道不应该考虑两者都为 false 的情况吗？好吧，我自己想了下，发现要解决这个问题的关键就在于如何在一次持续触发结束后把 startTime 重置为 0，但我想来想去还是没想明白要在哪里重置 startTime，新设置一个定时器来重置它好像也行不通。如何区分同一次的持续触发和不同次的持续触发，才好重置 startTime？</p>
<p>&emsp;&emsp;读者可以在<a href="https://jsfiddle.net/DangoSky/4dyn1pv0/16/" target="_blank" rel="noopener">这里</a>进行实验，设置不同的 leading 和 trailing 值来观察差别。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端基础</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode：刷完31道链表题的一点总结</title>
    <url>/2019/05/10/Leetcode%EF%BC%9A%E5%88%B7%E5%AE%8C31%E9%81%93%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;今天终于刷完了 Leetcode 上的<a href="https://leetcode-cn.com/tag/linked-list/" target="_blank" rel="noopener">链表专题</a>，虽然只有 31 道题（总共是 35 道，但有 4 道题加了锁）而已，但也陆陆续续做了两三个星期，严重跟不上原先计划啊。本来打算数据结构课程老师讲完一个专题，我就用 JS 在 Leetcode 做一个专题的。然而老师现在都讲到图了，而我连二叉树都还没刷 Orz（附上一张 AC 图，看着还是挺有成就感的嘛）。</p>
<p><img src="/2019/05/10/Leetcode：刷完31道链表题的一点总结/3.png" alt></p>
<p>&emsp;&emsp;先写一篇博客总结一下这阵子刷链表题的收获吧，有输入也要有输出。这里就不花篇幅介绍链表的一些基本概念了，不清楚的看官就自行<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">谷歌一下</a>吧，本文主要介绍一些常见的链表题和解题思路。文中提到的 Leetcode 题目都有给出题目链接以及相关解题代码，使用其他方法的解题代码，或者更多 Leetcode 题解可以访问我的<a href="https://github.com/DangoSky/algorithm/tree/master/LeetCode" target="_blank" rel="noopener">GitHub 仓库</a>。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>&emsp;&emsp;不得不说<strong>使用数组 / map 来缓存链表中结点的信息</strong>是解决链表题的一大杀器，覆盖问题的范围包括但不限于：在链表中插入 / 删除结点、反向输出链表、链表排序、翻转链表、合并链表等，Leetcode 上 31 道链表绝大部分都可以使用这种方法解题。具体实现思路是先使用一个数组或者 map 来存储链表中的结点信息，比如结点的数据值等，之后根据题目要求对数组进行相关操作后，再重新把数组元素做为每一个结点连接成链表返回即可。虽然<strong>使用缓存来解链表题很 dirty，有违链表题的本意</strong>，而且<strong>空间复杂度也达到了 O(n)</strong>（即使我们常常用空间来换时间，不过还是能避免就避免吧），但这种方法的确很简单易懂，看完题目后几乎就可以马上动手不加思考地敲代码一次 AC 了，不像常规操作那样需要去考虑到很多边界情况和结点指向问题。</p>
<p>&emsp;&emsp;当然，并不是很提倡这种解法，这样就失去了做链表题的意义。如果只是一心想要解题 AC 的话那无妨。否则的话我建议可以使用数组缓存先 AC 一遍题，再使用常规方法解一次题，我个人就是这么刷链表题的。甚至使用常规方法的话，你还可以分别使用迭代和递归来解题，迭代写起来比较容易，而递归的难点在于把握递归边界和递归式，但只要理解清楚了的话，递归的代码写起来真的很少啊（后面会说到）。</p>
<p>&emsp;&emsp;先找道题 show the code 吧，不然只是单纯的说可能会半知半解。比如<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">这道反转链表 II</a>：反转从位置 m 到 n 的链表。如果使用数组缓存的话，这道题就很容易了。只需要两次遍历链表，第一次把从 m 到 n 的结点值缓存到一个数组中，第二次遍历的时候再替换掉链表上 m 到 n 的结点的值就可以了（是不是很简单很清晰啊，如果使用常规方法的话就复杂得多了）。实现代码如下：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> reverseBetween <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> operator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">>=</span> m <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        operator <span class="token operator">===</span> <span class="token string">"get"</span> <span class="token operator">?</span>  arr<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">:</span> cur<span class="token punctuation">.</span>val <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      index<span class="token operator">++</span><span class="token punctuation">;</span>
      cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 获取从 m 到 n 的结点数值</span>
  <span class="token function">fn</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 重新赋值</span>
  <span class="token function">fn</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token string">"set"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;其他的题目例如链表排序、结点值交换等也是大致相同的代码，使用缓存解题就是这么简单。至于上面这题的常规解法，可以<a href="https://privatebin.net/?0f1f9e6d9b3152f1#3XxfN9PQzFFUy0M8ppCxTx9oMKEhVqWVnGcKO5bKUbA=" target="_blank" rel="noopener">戳这里查看</a>，我已经在代码中标注好解题思路了。</p>
<p>&emsp;&emsp;使用缓存来解题的时候，我们可以使用数组来存储信息，也可以使用 map，通常情况下两者是可以通用的。但因为<strong>数组和对象的下标只能是字符串，而 map 的键名可以是任意数据类型</strong>，所以 map 有时候能做一些数组无法做到的事。比如当我们要存储的不是结点值，而是整个结点的时候，这时候使用数组就无能为力了。举个例子，<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a>：判断一个链表中是否有环。先看一下环形链表长什么样。</p>
<p><img src="/2019/05/10/Leetcode：刷完31道链表题的一点总结/1.png" alt></p>
<p>&emsp;&emsp;还是使用缓存的方法，我们在遍历链表的过程中可以把整个结点当作键名放入到 map 中，并把它标记为 true 代表这个结点已经出现过。同时边判断 map 中以这个结点为键名的值是否为 true，是的话说明这个结点重复出现了两次，即这个链表有环。在这道题中我们是没办法用数组来缓存结点的，因为当我们把整个结点（一个对象）当作下标放入数组时，这个对象会先自动转化成字符串<code>[object Object]</code>再作为下标，所以这时候只要链表结点数量大于等于 2 的话，判断结果都会为 true。使用 map 解题的具体实现代码见下。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> hasCycle <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>
    head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;Leetcode 上还有一道题充分体现了 map 缓存解题的强大，<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">复制带随机指针的链表</a>：给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点，要求返回这个链表的深拷贝。具体的这里就不再多说了。此外，该题还有一种 O(1) 空间复杂度，O(n) 时间复杂度的解法（来自于《剑指offer》第187页）也很值得一学，推荐大家看看，详情可以<a href="https://github.com/DangoSky/algorithm/blob/master/LeetCode/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8.js" target="_blank" rel="noopener">看这里</a>。</p>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>&emsp;&emsp;在上面环形链表一题中，如果不使用 map 缓存的话，常规解法就是使用<strong>快慢指针</strong>了。指针是 C++ 的概念，JavaScript 中没有指针的说法，但在 JS 中使用一个变量也可以同样达到 C++ 中指针的效果。先稍微解释一下我对 C++ 指针的理解吧，具体的知识点看官可以自行<a href="https://www.runoob.com/cplusplus/cpp-pointers.html" target="_blank" rel="noopener">谷歌</a>。在 C++ 中声明一个变量，其实声明的是一个内存地址，可以通过取址符<code>&amp;</code>来获取这个变量的地址空间。而我们可以定义一个指针变量来指向这个地址空间，比如<code>int *address = &amp;a</code>。这时候 address 就是指 a 的地址，而 *addess 则代表对这个地址空间进行取值，也就是 a 的值了。（既然说到地址空间了就顺带说一下上面环形链表这道题的另一种很 6 的解法吧。利用的是堆的地址是从低到高的，而且链表的内存是顺序申请的，所以如果有环的话当要回到环的入口的时候，下一个结点的地址就会小于当前结点的地址! 以此判断就可以得到链表中是否有环的存在了。不过 JS 中没有提供获取变量地址的操作方法，所以这种解法和 JS 是无缘的了。C++ 解法可以<a href="https://privatebin.net/?c9f378ff792a427b#LEQWuCALfm00z8h3w6LKPA3PaLvTo1U2vcm+v2airoE=" target="_blank" rel="noopener">戳这里查看</a>。）</p>
<p>&emsp;&emsp;有没有觉得这很像 JS 的按引用传递？之所以说在 JS 中使用一个变量就可以达到同样的效果，这和 JS 是<strong>弱语言类型</strong>和<strong>变量的堆栈存储方式</strong>有关。因为 JS 是弱语言类型，所以定义一个变量它既可以是基本数据类型，也可以是对象数据类型。而对象数据类型是将整个对象存放在堆中的，存储在栈中的只是它的访问地址。所以对象数据类型之间的赋值其实是地址的赋值，<strong>指向堆中同一个内存空间的变量会牵一发而动全身</strong>，只要其中一个改变了内存空间中存储的值，都会影响到其他变量对应的值。但如果是<strong>改变变量的访问地址的话，则对其他变量不会有任何影响</strong>。理解这部分内容非常重要，因为常规的链表操作都是基于这些出发的。举最基本的链表循环来说明。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;上面的几行代码是最基本的链表循环过程，其中 <code>head</code> 表示一个链表的头节点，是一个链表的入口。<code>cur</code> 表示当前循环到的结点，当链表达到了终点即 <code>cur</code> 为 <code>null</code> 的时候就结束了循环。需要注意的是，每一个结点都是一个对象，简单的链表结点都有两个属性<code>val</code>和<code>next</code>，<code>val</code>代表了当前结点的数据值，<code>next</code>则代表了下一个结点。而由每个结点的<code>next</code>不断连接起其他的结点，就构成了一个链表。因为对象是按引用传递，所以可以在循环到任意一个结点的时候改变这个结点<code>cur</code>的信息，比如改变它的数据值或是指向的下一个结点，并且这会随着修改到原链表上去。而改变当前的结点<code>cur</code>，因为是直接修改其访问地址，所以并不会影响到原链表。链表的常规操作正是在这<strong>一变一不变</strong>的基础上完成的，因此操作链表的时候往往需要一个辅助链表，也就是<code>cur</code>，来修改原链表的各个结点信息却不改变整个链表的指向。每次循环结束后<code>head</code>还是指向原来的链表，而<code>cur</code>则指向了链表的末尾<code>null</code>。在这个过程中，除了最开始把<code>head</code>赋值给<code>cur</code>和最后的<code>return</code>外，几乎都不需要再操作到<code>head</code>了。</p>
<p>&emsp;&emsp;介绍完常规操作链表的一些基本知识点后，现在回到快慢指针。快慢指针其实是利用两个变量同时循环链表，区别在于一个的速度快一个的速度慢。比如慢指针<code>slow</code>的速度是 1，每趟循环都指向当前结点的下一个结点，即<code>slow = slow.next</code>。而快指针<code>fast</code>的速度可以是 2，每趟循环都指向当前结点的下下个结点，即<code>fast = fast.next.next</code>（使用的时候需要特别注意<code>fast.next</code>是否为<code>null</code>，否则很可能会报错）。现在想象一下，两个速度不相同的人在同一个环形操场跑步，那么这两个人最后是不是一定会相遇。同样的道理，一个环形链表，快慢指针同时在里面移动，那么它们最后也一定会在链表的环中相遇。所以<strong>只要在循环链表的过程中，快慢指针相等了就代表该链表中有环</strong>。实现代码如下。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> hasCycle <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token keyword">let</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>slow <span class="token operator">===</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;除了判断链表中有没有环外，快慢指针还可以找出链表中环形的入口。假设 A 是链表的入口结点，B 是环形的入口结点，C 是快慢指针的相遇点，x 是 AB 的长度（也就是 AB 之间的结点数量），y 是 BC 的长度，z 是 CB 的长度。因为快指针移动的距离（x + y）是慢指针移动的距离（x + y + z + y）的两倍（当快慢指针相遇时，快指针比慢指针多移动了一圈），所以 z = x。因此，只要在快慢指针相遇的时候，再让一个新指针从头节点 A 开始移动，与此同时慢指针也继续从 C 点移动。但新指针和慢指针相遇的时候，也就是在链表环形的入口处 B。该题的三种实现代码可以<a href="https://github.com/DangoSky/algorithm/blob/master/LeetCode/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II.js" target="_blank" rel="noopener">戳这里查看</a>。</p>
<p><img src="/2019/05/10/Leetcode：刷完31道链表题的一点总结/2.png" alt></p>
<p>&emsp;&emsp;如果我们把快指针的速度设置为 2，即每趟循环都指向当前结点的下下个结点。那么快慢指针在移动的过程中，<strong>快指针移动的距离都会是慢指针移动距离的两倍</strong>，利用这个性质我们可以很方便地得到链表的中间结点。只要让快慢指针同时从头节点开始移动，当快指针走到链表的最后一个结点（链表长度是奇数）或是倒数第二个结点（链表长度是偶数）的时候，慢指针就走到了链表中点。这里给出<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">题目链接</a>和实现代码。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> middleNode <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token keyword">let</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="先后指针"><a href="#先后指针" class="headerlink" title="先后指针"></a>先后指针</h2><p>&emsp;&emsp;先后指针和快慢指针很类似，不同的是<strong>先后指针的移动速度是一样的，而且两者并没有同时开始移动</strong>，是一前一后从头节点出发的。先后指针主要用来寻找链表中倒数第 k 个结点。通常我们寻找链表中倒数第 k 个结点可以有两种办法。 一是先循环一遍链表计算它的长度n，再正向循环一遍找到该结点的位置（正向是第 n - k + 1 个结点）。二是使用双向链表，先移动到链表结尾处再开始回溯 k 步，但大多时候给的链表都是单向链表，这就又需要我们先循环一遍链表给每一个结点增加一个前驱了。</p>
<p>&emsp;&emsp;使用先后指针的话只需要一趟循环链表，实现思路是先<strong>让快指针走 k-1 步，再让慢指针从头节点开始走，这样当快指针走到最后一个结点的时候，慢指针就走到了倒数第 k 个结点</strong>。解释一下为什么，假设链表长度是 n，那么倒数第 k 个结点也就是正数的第 n - k + 1 个结点（不理解的话可以画一个链表看看就清楚了）。所以只要从头节点出发，走 n - k 步就可以达到第 n - k + 1 个结点了，因此现在的问题就变成了如何控制指针只走 n - k 步。在长度为 n 的链表中，从头节点走到最后一个结点总共需要走 n - 1 步，所以只要让快指针先走 (n - 1) - (n - k)= k - 1 步后再让慢指针从头节点出发，这样快指针走到最后一个结点的时候慢指针也就走到了倒数第  n - k + 1 个结点。具体实现代码如下。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> removeNthFromEnd <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>k<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;Leetcode 上<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">有一道题</a>是对寻找倒数第 k 个结点的简单变形，题目要求是要删除倒数第 k 个结点。代码和上面的代码大致相同，只是要再用到一个变量<code>pre</code>来存储倒数第 k 个结点的前一个结点，这样才可以把倒数第 k 个结点的下一个结点连接到<code>pre</code>后面实现删除结点的目的。实现代码可以<a href="https://privatebin.net/?405efe1211cfccb8#t2+dXZMmrxWz6fHU7T1kb+iNoiPeNr6k/mruRq+Ur8g=" target="_blank" rel="noopener">戳这里查看</a>。</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>&emsp;&emsp;双向链表是在普通的链表上给每一个结点增加<code>pre</code>属性来指向它的上一个结点，这样就可以通过某一个结点直接找到它的前驱而不需要专门去缓存了。下面的代码是把一个普通的链表转化为双向链表。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cur<span class="token punctuation">.</span>pre <span class="token operator">=</span> pre<span class="token punctuation">;</span>
  pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
  cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;双向链表的应用场景还是挺多，比如上例寻找倒数第 n 个结点，或者是判断回文链表。可以使用两个指针，从链表的首尾一起向链表中间移动，一边判断两个指针的数据值是否相同。实现代码可以<a href="https://privatebin.net/?75e0059fc072dddd#/pzJY3fT6HehtEsPHF4iokBwDWRBKZ0yJy6vJjjVFgM=" target="_blank" rel="noopener">戳这里查看</a>。</p>
<p>&emsp;&emsp;除了借助双向链表外，还可以先翻转链表得到一个新的链表，再从头节点开始循环比较两个链表的数据值（当然使用数组缓存也是一种方法）。可能各位看官看到上面这句话觉得没什么毛病，通过翻转来判断链表 / 字符串 / 数组是否是回文的也是一个很常见的解法，但不知道看官有没有考虑到一个问题，<strong>翻转链表是会修改到原链表的</strong>，对后续循环链表比较两个链表结点的数据值是有影响的！一发现了这个问题，是不是马上联想到了 JS 的深拷贝。没错，一开始为了解决这个问题我是直接采用<code>JSON.parse</code> + <code>JSON.stringify</code>来粗暴实现深拷贝的（反正链表中没有 <code>Date，Symbol 、RegExp、Error、function 以及 null 和 undefined</code> 这些特殊的数据），但不知道为什么<code>JSON.parse(JSON.stringify(head))</code><strong>报了栈溢出的错误</strong>，现在还没想通原因 Orz。所以只能使用递归去深拷贝一次链表了，下面给出翻转链表和深拷贝链表的代码。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 翻转链表</span>
<span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
    pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
    cur <span class="token operator">=</span> temp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 翻转链表的递归写法</span>
<span class="token keyword">var</span> reverseList <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
  head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head
  head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> cur<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 深拷贝链表</span>
<span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  ans<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;回文链表的 3 种解题方法（数组缓存、双向链表、翻转链表）可以<a href="https://github.com/DangoSky/algorithm/blob/master/LeetCode/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.js" target="_blank" rel="noopener">戳这里查看</a>，题目链接在<a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">这里</a>。</p>
<p>&emsp;&emsp;除此之外还有一道<a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">重排链表</a>的题，解题思路和判断回文链表大致相同，各位看官有兴趣的话可以试着 AC 这道题。同样的，这道题我也给出了 <a href="https://github.com/DangoSky/algorithm/blob/master/LeetCode/143.%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.js" target="_blank" rel="noopener">3 种解题方法</a>。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>&emsp;&emsp;使用递归解决链表问题不得不说是十分契合的，因为很多链表问题都可以分割成几个相同的子问题以缩小问题规模，再通过调用自身返回局部问题的答案从而来解决大问题的。比如<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并有序链表</a>，当两个链表长度都只有 1 的时候，就是只有判断头节点的数据值大小并合并两者而已。当链表一长问题规模一大，也只需调用自身来判断两者的下一个结点和已有序的链表，通过不断递归解决小问题最后便能得到大问题的解。</p>
<p>&emsp;&emsp;更多问题例如<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除链表中重复元素</a>、<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">删除链表中的特定值</a>、<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表结点</a>等也是可以通过递归来解决的，看官有兴趣可以自行尝试 AC，相关的解决代码可以<a href="https://github.com/DangoSky/algorithm/tree/master/LeetCode" target="_blank" rel="noopener">在这里找到</a>。使用递归解决问题的优势在于递归的代码十分简洁，有时候使用迭代可能需要十几二十行的代码，使用递归则只需要短短几行而已，有没有觉得很短小精悍啊啊啊。不过递归也还是得小心使用，否则一旦递归的层次太多很容易导致栈溢出（有没有联想到什么，其实就是函数执行上下文太多使执行栈炸了）。</p>
<h2 id="一个小技巧"><a href="#一个小技巧" class="headerlink" title="一个小技巧"></a>一个小技巧</h2><p>&emsp;&emsp;有时候我们在循环链表进行一些判断的时候，需要对头结点进行特殊判断，比如要新创建一个链表 newList 并根据一些条件在上面增加结点。我们通常是直接使用<code>newList.next</code>来修改结点指向从而增加结点的。但第一次添加结点的时候，newList 是为空的，不能直接使用<code>newList.next</code>，需要我们对 newList 进行判断看看它是否为空，为空的话就直接对 newList 赋值，不为空再修改<code>newList.next</code>。</p>
<p>&emsp;&emsp;为了避免对头节点进行特殊处理，我们可以在 newList 的初始化的时候先给它一个头结点，比如<code>let newList = new ListNode(0)</code>。这样在操作过程中只使用<code>newList.next</code>就可以了而不需要另行判断，而最后结果只要返回<code>newList.next</code>（当然，在循环的时候需要使用一个辅助链表来循环 newList ，否则会改变到 newList 的指向）。可能你会觉得不就是多了一个<code>else if</code>判断吗，对代码也没多大影响，但如果在这个<code>if</code>中包含了很多其他相关操作呢，这样的话<code>if</code>和<code>else if</code>里就会有很多代码是重复的，不仅代码量变多了还很冗余耶。</p>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>&emsp;&emsp;关于链表本文就说这么多啦，如果大家发现有什么错误、或者有什么疑问和补充的，欢迎在下方留言。更多 LeetCode 题目的 JavaScript 解法可以参考<a href="https://github.com/DangoSky/algorithm/tree/master/LeetCode" target="_blank" rel="noopener">我的GitHub</a>，目前已经 AC 了一百多道题，并持续更新中。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Puzzle Game</title>
    <url>/2019/05/03/Puzzle-Game/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;会做这个 <strong>Puzzle Game</strong>，还是应前几天 lightyears 的一次提议，模仿的是鹰脚网络首页左下角那个<a href="https://www.hypergryph.com/#/" target="_blank" rel="noopener">拼图小游戏</a>。那天晚上睡觉的时候在床上想了一下，大致 get 到了它内部实现的原理，于是就干脆动手实践一番，现在也顺道写一篇博客记录下实现思路和中间遇到的一些问题。</p>
<p><img src="/2019/05/03/Puzzle-Game/1.png" alt></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>&emsp;&emsp;<strong>Puzzle Game</strong> 的游戏过程为：用户上传图片后选择要分割的碎片数量，一颗星代表 2 * 2 = 4 个碎片， 两颗星代表 3 * 3 = 9 个碎片，以此类推八颗星则是 81 个碎片。通过拖拽碎片进行拼图，当每个碎片和其相邻的碎片间隔都不超过阈值时，则提示拼图成功。</p>
<p>&emsp;&emsp;<a href="http://dangosky.com/puzzle-game/index.html" target="_blank" rel="noopener">传送门</a>, Go to play?<br>&emsp;&emsp;<a href="https://github.com/DangoSky/puzzle-game" target="_blank" rel="noopener">GitHub</a>，喜欢的话就给个 star 鼓励鼓励吧😊。</p>
<p><img src="/2019/05/03/Puzzle-Game/2.gif" alt></p>
<p><img src="/2019/05/03/Puzzle-Game/3.gif" alt></p>
<h2 id="首先要解决的两个难点"><a href="#首先要解决的两个难点" class="headerlink" title="首先要解决的两个难点"></a>首先要解决的两个难点</h2><p>&emsp;&emsp;<strong>Puzzle Game</strong> 的难点主要是两个：一是如何对上传的图片进行切割成各个碎片，二是如何判断是否拼图成功。鹰脚网络那个拼图因为是固定的，就只有那一张图片和四个图片碎片，所以大可以事先把图片分割成 4 块碎片再写进代码里。但 <strong>Puzzle Game</strong> 使用的图片和碎片数量取决于用户选择，所以就得另辟蹊径了。</p>
<p>&emsp;&emsp;这里我利用到的是<strong>精灵图</strong>，根据用户选择的碎片数量，生成 N 个<code>&lt;div&gt;</code>（代表每一个碎片），将用户上传的图片设置为每一个<code>&lt;div&gt;</code>的背景图片，再使用<code>background-position</code>把每一个碎片都定位到图片相应的位置，这样就可以实现把图片切割成各个碎片啦。<strong>Puzzle Game</strong> 还是挺简单的，每一个碎片都是等大的，而且是 n * n 的碎片数量，相对容易实现很多。不过即使是 n * m 也是一样的，只要改变一下碎片的宽高和<code>background-position</code>的定位就可以了，问题不大。但如果每一个碎片都不等大的话就麻烦了，目前没想到实现思路。</p>
<p>&emsp;&emsp;至于判断拼图是否成功，我想到的办法是：先设置好一个阈值，<strong>在每次拖拽完毕后就遍历每一个碎片，判断它和相邻碎片（上下左右四个碎片，对于边界碎片再行判断）之间的间隔是否不超过这个阈值</strong>。如果每一个碎片都不超过，则拼图成功；若有一个碎片和相邻某一个碎片之间的间隔超过了阈值，则直接结束判断过程。此处判断碎片间的距离使用的是<code>element.getBoundingClientRect()</code>，四个属性值<code>left</code>、<code>right</code>、<code>top</code>、<code>bottom</code>统一是相对于浏览器视口来计算的。（具体代码实现可以看<a href="https://github.com/DangoSky/puzzle-game/blob/master/index.html" target="_blank" rel="noopener">这里</a>）</p>
<h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><h3 id="拖拽后计算碎片的位置"><a href="#拖拽后计算碎片的位置" class="headerlink" title="拖拽后计算碎片的位置"></a>拖拽后计算碎片的位置</h3><p>&emsp;&emsp;拖拽碎片进行移动使用到的 api 有三个：<code>mousedown</code>、<code>mousemove</code>、<code>mouseup</code>（移动端则是对应的<code>touchstart</code>、<code>touchmove</code>、<code>touchend</code>。不过 <strong>Puzzle Game</strong> 没有适应移动端，因为我觉得通过拖拽来实现拼图而且碎片数量还是不确定的，这需要大屏幕才方便操作，移动端屏幕太小不适合）。在<code>mousemove</code>的过程中实时更新碎片的位置，计算方法有两个：</p>
<ol>
<li><strong>鼠标拖拽过程中移动的距离 + 碎片原先离父元素的左 / 上边距</strong></li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> x <span class="token operator">=</span> e<span class="token punctuation">.</span>clientX <span class="token operator">-</span> startX <span class="token operator">+</span> px<span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> e<span class="token punctuation">.</span>clientY <span class="token operator">-</span> startY <span class="token operator">+</span> py<span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;其中<code>e.clientX</code>是鼠标松开时鼠标的 x 坐标，startX 是一开始鼠标按下时的 x 坐标，px 是碎片原先离父元素的左边距，由<code>targetEle.offsetLeft</code>得到。</p>
<ol start="2">
<li><strong>鼠标松开时的 x / y 坐标 - 碎片自身宽 / 高的一半</strong></li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> x <span class="token operator">=</span> e<span class="token punctuation">.</span>clientX <span class="token operator">-</span> targetEle<span class="token punctuation">.</span>clientWidth <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> e<span class="token punctuation">.</span>clientY <span class="token operator">-</span> targetEle<span class="token punctuation">.</span>clientHeight <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;这两个计算方法本身没有问题，但和后面的<code>targetEle.style.left = `${x}px`; targetEle.style.top = `${y}px`;</code>合用的时候就产生了一个参照物的问题。方法一使用到的<code>targetEle.offsetLeft</code>和<code>targetEle.offsetTop</code>是相对于它的<code>offsetParent</code>而言的，也就是它第一个设置有定位的父元素，如果它的父级元素都没有定位则为 body。而碎片设置的<code>left</code>和<code>top</code>属性也是相对于它第一个设有定位的父级元素而言的，所以不管碎片的父元素如何定位（默认也好，绝对 / 相对 / 固定定位也罢），<strong>得出的 x 和 y 值以及<code>left</code>和<code>top</code>都是相对于其父元素而言的，是统一的</strong>。</p>
<p>&emsp;&emsp;但使用方法二算出来的 x 和 y 是相对于浏览器视口左上角而言的，和<code>left</code>和<code>top</code>的参照物可能不一样，所以使用方法二有时候就会出现拖拽图片但图片却偏离到右下角去了的情况。因此要准确地<strong>使用方法二是有个前提条件的，就是碎片的父元素必须得是相对于浏览器左上角定位的</strong>。这和父元素是否设置了定位无关，因为如果父元素没有设置定位，那么父元素自然是相对于浏览器左上角来定位的（即使父元素前面已经有其他的元素了）。而如果父元素设置了定位，只要父元素位于浏览器左上角从而让碎片还是相对于浏览器左上角定位那也是可以的，比如父元素设置了定位但<code>left</code>和<code>top</code>为 0 并且前面没有其他的元素，或者父元素前面的元素都脱离了文档流。只有满足这几个条件，才能正确使用方法二，否则拖拽后图片的位置会出现异常，例如下面图三所示。</p>
<p>&emsp;&emsp;接下来我们先用代码和结果图进一步验证，看客可以<a href="https://jsfiddle.net/8x014ewm/2/" target="_blank" rel="noopener">戳这里</a>查看具体代码自行验证，这里就只放效果图不放代码啦。</p>
<ul>
<li><p>父元素没有设置定位<br><img src="/2019/05/03/Puzzle-Game/4.gif" alt></p>
</li>
<li><p>父元素设置了定位（<code>relative</code> / <code>absolute</code> / <code>fixed</code> 定位都行），但父元素位于浏览器左上角的位置（<code>left</code>和<code>top</code>为 0 且前面没有元素，或是前面的元素都脱离了文档流）。</p>
</li>
</ul>
<p><img src="/2019/05/03/Puzzle-Game/5.gif" alt></p>
<ul>
<li>父元素设置了定位，但设置了非零的<code>left</code>和<code>top</code>，或是前面已有在文档流中占位的元素。</li>
</ul>
<p><img src="/2019/05/03/Puzzle-Game/6.gif" alt></p>
<p>&emsp;&emsp;考虑到使用方法二会有一些限制条件，所以还是推荐使用方法一的好，比较健壮适应性也好。如果使用方法二的话，则要注意上述的这些坑点，免得跳坑里了。（咦，如果不跳一次坑哪来的这篇博客？？）</p>
<h3 id="拖拽速度过快"><a href="#拖拽速度过快" class="headerlink" title="拖拽速度过快"></a>拖拽速度过快</h3><p>&emsp;&emsp;在监听事件的时候，我们通常都是把监听函数绑定到相应的目标元素上的，很少把监听函数绑定到<code>document</code>或<code>body</code>上（监听页面滚动和利用事件委托等除外）。所以当我把<code>mousedown</code>、<code>mousemove</code>、<code>mouseup</code>这三个监听函数绑定到碎片上时，<code>mousedown</code>没什么问题，问题就出在了<code>mousemove</code>和<code>mouseup</code>上。<strong>如果点击碎片后拖拽的速度过大，就会造成鼠标移动过快而碎片来不及响应移动</strong>。要知道，<code>mousemove</code>触发频率是很高的，相应的监听函数也会被高频率调用。这很容易造成碎片的移动速度跟不上鼠标的移动速度，<strong>结果就是鼠标移出了碎片后，即使鼠标没有松开但因为监听函数失去了目标所以碎片也不会再跟着移动。而因为鼠标松开后也没能触发相应的监听函数，所以此时标记鼠标移动是否开始的变量还是为<code>true</code>，又造成了当鼠标移动到碎片上时即使没有按住鼠标碎片也还是可以跟着鼠标移动</strong>。具体代码和效果可以<a href="https://jsfiddle.net/8x014ewm/1/" target="_blank" rel="noopener">戳这里</a>。</p>
<p>&emsp;&emsp;我使用的解决办法很简单，直接把<code>mousemove</code>和<code>mouseup</code>这两个监听函数绑定到<code>document</code>或者<code>body</code>上就行了。这样即使鼠标移动速度过快离开了碎片，也还是能触发到相应的监听函数让碎片也跟着移动。这里还有一个注意点，计算得到 x 和 y 的值要修改碎片的<code>left</code>和<code>top</code>属性时，不能使用<code>e.target</code>来获取碎片自身了。因为鼠标移动过快离开碎片后此时的<code>e.target</code>便成<code>document</code>了，所以<strong>需要事先使用一个变量来缓存<code>e.target</code></strong>才行。</p>
<p>&emsp;&emsp;接下来再说说把<code>mousemove</code>和<code>mouseup</code>这两个监听函数绑定到<code>document</code>和<code>body</code>的区别。<code>document</code>包括了整个浏览器视图，而<code>body</code>只包括了网页正文（脱离文档流的元素还不算在<code>body</code>的宽高上）。所以如果<code>body</code>没有达到整个浏览器视图的大小，那把监听函数绑定到<code>body</code>上和原先绑定在碎片上没有啥区别。如果<code>body</code>的宽高已经和浏览器视图一样大小了，比如手动设置为<code>100vw</code>和<code>100vh</code>，此时绑定到<code>document</code>或<code>body</code>上的区别在于两者对边界情况的处理不同。<strong>绑定到<code>document</code>上时即使鼠标移到了页面正文外（比如浏览器的工具栏和桌面的任务栏）碎片也还是能跟着继续移动，而绑定到<code>body</code>上如果鼠标移出了页面正文碎片就不会跟着移动了，只有鼠标再移回页面正文碎片的位置才会继续跟着响应</strong>。（若绑定到<code>window</code>或者<code>html</code>上则跟绑定到<code>document</code>上是一样的。）</p>
<p>&emsp;&emsp;看效果图会更直观点，下图一是<code>mousemove</code>和<code>mouseup</code>监听函数绑定在<code>document</code>上，下图二是绑定在<code>body</code>上（当然代码中可不能直接写<code>body</code>，得写成<code>document.body</code>才行）。</p>
<p><img src="/2019/05/03/Puzzle-Game/7.gif" alt></p>
<p><img src="/2019/05/03/Puzzle-Game/8.gif" alt></p>
<p>&emsp;&emsp;不知道看客有没有想到一个问题，把<code>mousemove</code>和<code>mouseup</code>的监听函数绑定到<code>document</code>上会不会造成事件触发频率过高的问题？毕竟监听对象从原来的几个碎片扩大成了整个<code>document</code>啊。不可避免地事件触发频率会高很多，但没办法，我想不出其他的解决方案啊，只能去尽量避免过多触发到监听函数了。比如把<code>mousemove</code>和<code>mouseup</code>的监听写在<code>mousedown</code>的监听函数里，这和前面使用一个变量标记鼠标移动是否开始差不多。但主要的是<strong>在<code>mouseup</code>的监听函数里把<code>document</code>上的<code>mousemove</code>和<code>mouseup</code>监听事件清除掉</strong>。比如<code>document.onmousemove = null; document.onmouseup = null;</code>。这样只有在点击碎片的时候才会监听事件并且点击完毕后就马上清除掉了，触发监听函数的次数少了很多。</p>
<h3 id="上传的图片过大"><a href="#上传的图片过大" class="headerlink" title="上传的图片过大"></a>上传的图片过大</h3><p>&emsp;&emsp;如果用户上传的图片过大，甚至超过了浏览器视窗大小，那必然得对图片进行压缩后，否则图片都铺满了整个浏览器视窗还怎么进行拼图。这里我采用的方法也很简单，上传完图片后对图片的大小进行判断，如果超过了限定值（我设置的是浏览器宽度的一半）则将图片的宽度缩小为这个限定值，再根据原始的宽高比例和压缩后的图片宽度计算出压缩后的图片高度就行了。这里我还遇到两个小问题。</p>
<ol>
<li><p>我使用<code>imageEle.naturalWidth</code>和<code>imageEle.naturalHeight</code>来获取图片大小，但如果直接读取的话你会发现得到的图片宽高都是 0。这是因为 imageEle 的 src 属性是依赖于用户上传的图片来动态赋值的，<strong>需要等图片加载完成后才能获取到它的宽高</strong>，图片还没有加载完成就去获取得到的自然就是 0 了。解决方法是使用<code>setTimeout(callback, 0)</code>来异步获取图片宽高，如果想要更及时获取到图片宽高也可以开一个<code>setInterval</code>隔一段时间就去判断获取到的图片宽高是否非 0，是的话则代表图片已经加载完成就可以结束<code>setInterval</code>了。我本来以为使用<code>Vue.$nextTick</code>在下次 DOM 更新时再获取图片宽高也是可以的，但发现不行，估计是下次 DOM 更新了图片也可能没有加载完毕吧，这点不是很清楚。</p>
</li>
<li><p>另一个问题是，缩小图片尺寸后页面会有一瞬间图片从大变小的过程。解决方法也很简单，<strong>事先给图片设置一个<code>max-width</code></strong>就行了，这个<code>max-width</code>也就是前面提到的限定值，这样图片就不会有一个大小的瞬间变化了。不过这得在 js 代码里去设置，在 css 里没法获取到浏览器宽高。</p>
</li>
</ol>
<h3 id="refs-的获取"><a href="#refs-的获取" class="headerlink" title="$refs 的获取"></a>$refs 的获取</h3><p>&emsp;&emsp;因为要分割成的碎片数量取决于用户的选择，所以所有的碎片都是动态加载的。<strong>而<code>$refs</code>不是响应式的，只能在组件渲染完成后才能获取到，所有动态加载的模板更新时<code>$refs</code>都无法相应地及时变化</strong>（<a href="https://cn.vuejs.org/v2/api/index.html#ref" target="_blank" rel="noopener">可见官方文档</a>）。所以需要等 DOM 更新后才能获取到<code>$refs</code>，可以利用<code>Vue.$nextTick(callback)</code>实现。</p>
<h3 id="对-background-position-理解出错"><a href="#对-background-position-理解出错" class="headerlink" title="对 background-position 理解出错"></a>对 background-position 理解出错</h3><p>&emsp;&emsp;说到这个就有些尴尬了，我之前以为<code>background-position</code>的两个属性值 x 和 y 代表的是在这张图片上定位到（x, y）这个坐标的位置上再显示背景图片，结果导致使用<code>background-position</code>定位到的碎片显示的图片位置错位。又因为我老是以为是我中间哪里出问题了所以一直没有想到是我自己对<code>background-position</code>理解出错上去（Orz），最后单独起了个 demo 实验才发现问题所在。<strong>原来<code>background-position</code>的两个属性值 x 和 y 代表的是将这张图片向右移动和向下移动指定的距离后再显示背景图片</strong>。和我之前理解的恰恰相反，而且因为我之前没有设置<code>background-repeat: no-repeat</code>所以如果只有四个碎片的话是不会表现出什么问题的。知道了<code>background-position</code>的真正意思后要解决就很容易了，只要把 x 和 y 都变成负值就可以啦。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>&emsp;&emsp;<strong>Puzzle Game</strong> 写起来还是挺简单的，主要是一时兴起练练手吧。中午去食堂的时候才想起来我在写一个<a href="http://blog.dangosky.com/categories/Web-Project/">Web Project</a>的时候应该边写边记录的才对啊。像这个 <strong>Puzzle Game</strong> 就是边写代码的过程中边三言两语记录下遇到的问题和解决方案，这样事后才可以总结成一篇博客，记录自己遇到的坑点和盲点。不然就跟之前写的<a href="http://blog.dangosky.com/2019/02/25/vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%BFiOS%E7%89%88%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/">cloud music</a>一样，没有边写代码边记录遇到的问题，所以等写完代码后都差不多忘记中间遇到的很多问题了，写成的博客也就很空淡。好吧，吸收经验，下次就要记得正确的学习姿势了！</p>
<p>&emsp;&emsp;花了三天的时间写完 <strong>Puzzle Game</strong> 和这篇博客，五一假期就只剩下这半天了啊。我还是滚回去写我的数据结构实验了，挥挥。</p>
]]></content>
      <categories>
        <category>Web Project</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web Project</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>从浏览器的渲染机制谈起</title>
    <url>/2019/04/19/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E8%B0%88%E8%B5%B7/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;大家应该都知道在前端有一道极其著名的题目：<strong>从输入 url 到页面加载完成的过程中发生了什么？</strong>不得不说这的确是一道覆盖面很广的题目，从计算机网络到浏览器缓存和渲染等内容几乎都包括在其内，更别提还可以引申出去再谈谈性能优化了，估计单单这一道题，从广度和深度挖下去就足以撑起一场面试了。不过本文只涉及到浏览器渲染方面的内容，从服务器返回响应开始讲起，而此前的内容等以后我理清楚了再分别写几篇博客谈谈。</p>
<h1 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h1><h2 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h2><p>&emsp;&emsp;在计算机网络中传输的内容都是以字节的形式传输的，当浏览器接受到（或者从本地磁盘读取到）这些字节数据（也就是HTML文档）时，会先根据指定的编码方式（如 utf-8）把它们解码成字符串。然后通过<a href="https://zh.wikipedia.org/wiki/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90" target="_blank" rel="noopener">词法分析</a>把字符串识别成一个个词语（此处词法分析会识别并跳过空格和换行等无关的字符），再利用这些词语生成节点，而这些节点根据原本的文档结构便构建成了一颗 DOM 树。</p>
<p>&emsp;&emsp;其中词法分析是按一定的语言规则将字符串转化成一个个浏览器可以识别的词语（即 <strong>token</strong>），每一个 token 会标识出当前的 token 是“开始标签”、“结束标签”还是“文本”等信息。对于词法分析的过程，我猜可能是利用到正则表达式 + 栈来实现的，类似于 <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">Leetcode</a> 上一道算法题，匹配括号判断字符串是否有效，也可能是我想的太简单了。（对于 HTML 字符串如何解析成词语和节点，本文就不深入探讨了，看客有兴趣可以参考《<strong>WebKit技术内幕</strong>》这本书的 5.2 章。难道我会告诉你其实我也不是很清楚吗？还是等之后我深入理解了后再补充这部分的知识点吧，在这里立个 flag）</p>
<p><img src="/2019/04/19/从浏览器的渲染机制谈起/1.png" alt></p>
<h2 id="构建-CSSOM-树"><a href="#构建-CSSOM-树" class="headerlink" title="构建 CSSOM 树"></a>构建 CSSOM 树</h2><p>&emsp;&emsp;CSSOM 树的构建过程和 DOM 树的构建过程很相似，先是解析 CSS 生成 token，再由这些 token 生成节点构建出 CSSOM 树。</p>
<blockquote>
<p>在这一过程中浏览器会确定每一个节点的样式到底是什么，而这一过程其实是很消耗时间的。因为样式可以自行设置给某个节点，也可以通过继承父节点获得。所以浏览器得递归 CSSOM 树，才能确定元素的具体样式。</p>
</blockquote>
<p><img src="/2019/04/19/从浏览器的渲染机制谈起/2.png" alt></p>
<p>&emsp;&emsp;需要注意的是，上图的 CSSOM 树并不是完整的 CSSOM 树，因为它只显示出了我们在样式表中给定的样式。但除此之外每一个浏览器都会为每一个标签提供默认的样式信息的，比如<code>font-size</code>和<code>margin</code>等，CSSOM 树中显示的只是我们用来替换默认样式的信息而已。</p>
<p>&emsp;&emsp;不知道诸位看客从上图中有没有发现一个问题，上图的 CSSOM 树是由一个个标签名构建而成的，但往往我们的 CSS 样式表中是通过 class 和 id 来设置样式的，既然如此那 CSSOM 树要如何单单根据 class 和 id 就构建出有父子关系层层嵌套的树呢？（emmm，这个其实我也不知道Orz）</p>
<p>&emsp;&emsp;既然说到了 CSSOM 树，就顺道提一下 CSS 匹配规则吧。我们知道 CSS 匹配节点样式时是从右往左的。举个例子，对于<code>.box div</code>这个 CSS 选择器会先去查找所有的 div 标签，再去匹配这些 div 标签的父元素是否有 box 这个类。所以根据这个匹配规则我们应该尽量使用 id 和 class 选择器，让 CSS 匹配可以更高效，避免使用标签选择器过度嵌套。当然这里面还牵涉到<strong>选择器优先级</strong>的问题，不过这里就不过多说这些题外话啦，有兴趣的看客就自行 Google 吧。</p>
<h2 id="合成渲染树"><a href="#合成渲染树" class="headerlink" title="合成渲染树"></a>合成渲染树</h2><p>&emsp;&emsp;构建完 DOM 树和 CSSOM 树后就会合并两者，根据 DOM 上的节点及其对应的样式生成一颗渲染树（render tree）。在合并的过程中渲染树只会包含可见的节点，对于设置了<code>display: none</code>的节点和<code>&lt;head&gt;</code>、<code>&lt;script&gt;</code>这些节点是不会被渲染出来的。作为对比，设置<code>visible: hidden</code>的节点虽然不可见，但依旧会占据空间，还是会出现在渲染树中被渲染出来。</p>
<p><img src="/2019/04/19/从浏览器的渲染机制谈起/3.png" alt></p>
<h2 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h2><p>&emsp;&emsp;有了渲染树就可以对应起每一个节点和相应的样式信息，但这时候每一个节点在文档中所处的位置还是不确定的。所以就需要根据渲染树中的节点及其样式在页面上<strong>自上而下，从左到右</strong>地计算各个节点所处的位置和大小，也就是布局（有没有联想到什么？每一个节点其实都代表了一个个盒模型啊）。</p>
<h2 id="绘制（Painting）"><a href="#绘制（Painting）" class="headerlink" title="绘制（Painting）"></a>绘制（Painting）</h2><p>&emsp;&emsp;顾名思义，就是根据渲染树中的节点和对应的样式，以及计算得到的位置信息等将各个节点转换为页面上的实际像素并绘制出来。</p>
<p>&emsp;&emsp;用一张图总结一下浏览器渲染的五个过程。</p>
<p><img src="/2019/04/19/从浏览器的渲染机制谈起/4.png" alt></p>
<p>&emsp;&emsp;在以上的五个过程中有两个地方需要注意到。</p>
<ol>
<li><p>上述这五个步骤并不是同步的，而是逐步完成的。DOM 并不需要等 HTML 文档完全解析完再开始构建，而是<strong>边解析 HTML 边构建 DOM 树</strong>的。而且现在的浏览器为了达到更好的用户体验，渲染引擎会尽可能快的将内容渲染到屏幕上，它不会等到整个 HTML 文档都解析完成之后再去构建 render 树和布局渲染，而是同样解析完一部分内容就显示一部分内容（这是一个<strong>渐进</strong>的过程）。</p>
</li>
<li><p>现代一些浏览器在开始解析 HTML 的时候会有一个<strong>预解析</strong>的优化操作，即一开始就会<strong>并行</strong>去加载 HTML 文档中需要加载到的外部资源（JS 脚本、CSS 样式表以及图片等），而不必等 DOM 构建到它们相应的那个节点（我猜应该是通过正则表达式去匹配它们对应的标签名来实现的吧）。这样当 DOM 构建到相应的标签时，由于外部资源已经预加载好了，所以就可以立即执行而不用再等待资源加载从而避免进一步阻塞页面渲染（预解析并不改变 DOM 树）。</p>
</li>
</ol>
<p><img src="/2019/04/19/从浏览器的渲染机制谈起/6.png" alt></p>
<h1 id="JS-和-CSS-对-DOM-的阻塞"><a href="#JS-和-CSS-对-DOM-的阻塞" class="headerlink" title="JS 和 CSS 对 DOM 的阻塞"></a>JS 和 CSS 对 DOM 的阻塞</h1><h2 id="JS-会阻塞-DOM-的解析和页面渲染"><a href="#JS-会阻塞-DOM-的解析和页面渲染" class="headerlink" title="JS 会阻塞 DOM 的解析和页面渲染"></a>JS 会阻塞 DOM 的解析和页面渲染</h2><p>&emsp;&emsp;在构建 DOM 树时，如果遇到了<code>&lt;script&gt;</code>加载 JS 脚本，那么 DOM 树会暂停构建，先执行 JS 代码。如果 JS 脚本是通过外部引入的，则是等待 JS 先下载再执行。为什么 JS 脚本会阻塞到 DOM 树的构建呢？看客应该都知道，JavaScript的一个强大之处在于它可以操纵页面中的每一个节点并对其进行增删改查操作，其中也包括修改节点对应的 CSS 样式信息。所以<strong>为了防止要执行的 JS 代码和正在构建的 DOM 树起冲突</strong>，DOM 树的构建是会先被挂起的，等到 JS 代码执行完毕才会继续构建 DOM 树。如果 JS 脚本加载时间很长，页面无法继续渲染下去就会造成浏览器失去响应处于假死状态。（不知道看客们有没有联想到什么？<a href="http://blog.dangosky.com/2019/04/07/%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">前面一篇讲事件循环的博客</a>里有提到浏览器的两个线程：<strong>GUI 线程</strong>和 <strong>JavaScript</strong> 引擎线程。这两个线程是互斥的，其中原因和 JS 代码阻塞 DOM 是一样的）。平时我们常说不要把 JS 文件放在<code>&lt;head&gt;</code>头部而要放到<code>&lt;body&gt;</code>尾部防止首屏加载时间过长，就是基于 JS 会阻塞 DOM 的解析和渲染这一个原因。JS 文件放到了<code>&lt;body&gt;</code>的尾部，这样即使 JS 代码长时间加载也不会影响到首屏显示，因为这时候页面已经渲染完毕了。如果有一些 JS 代码必须先行加载（放在<code>&lt;head&gt;</code>头部）的话，最好直接将代码写在页面中而不是以外联载入的形式，这样可以节省加载 JS 文件所消耗的时长（不过 JS 代码放在<code>&lt;body&gt;</code>前面好像没什么用处吧，这时候页面还没有渲染又不能获取到 DOM 节点，通过 CDN 加载第三方库除外）。</p>
<p>&emsp;&emsp;如果页面中有多个<code>&lt;script&gt;</code>标签要加载 JS 文件，例如：</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"a.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"b.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>&emsp;&emsp;那么浏览器会并行下载这两个 JS 文件，但执行的时候会保证先执行 a.js，再执行 b.js，即使后者先加载完毕。也就是说，脚本的执行顺序由它们在页面中的出现顺序决定，不过页面的渲染还是得等它们都加载并执行完毕才会继续。</p>
<h2 id="CSS-不会阻塞-DOM-的解析，但会阻塞页面渲染"><a href="#CSS-不会阻塞-DOM-的解析，但会阻塞页面渲染" class="headerlink" title="CSS 不会阻塞 DOM 的解析，但会阻塞页面渲染"></a>CSS 不会阻塞 DOM 的解析，但会阻塞页面渲染</h2><p>&emsp;&emsp;<strong>DOM 树和 CSSOM 树的构建是两个独立的过程</strong>，彼此不会互相依赖，所以 CSS 加载也就不会影响到 DOM 的解析。然而<strong>渲染树得依赖于 DOM 树和 CSSOM 树</strong>来合成的，所以页面的渲染也就得等待 CSSOM 构建了。也就是说 CSS 不会阻塞 DOM 的解析，但会阻塞页面的渲染。换个角度想想也是，如果页面不等待 CSS 加载完成就渲染，而若正在加载的 CSS 文件修改到页面上已经渲染完成的节点的话，那就得造成页面重绘了，造成很多无谓的消耗。如果还引起页面重排的话那就更消耗性能了，所以等待 CSS 加载完成再继续渲染页面反倒能优化性能。</p>
<p>&emsp;&emsp;如果遇到 JS 脚本时还有未加载完成的 CSS 样式文件，那 CSS 的加载还会阻塞到 JS 的执行。原因也同上面说的，JS 可以增删改查到 DOM 节点，自然也就能读取或修改到 DOM 节点的 CSS 样式信息。为了防止 JS 文件读取读取到不完整的 CSS 信息或是修改时和前面的 CSS 样式表起冲突，所以 JS 文件会等待前面的 CSS 资源加载完成才执行。而 JS 又会阻塞到后面 DOM 的解析和页面渲染，双重阻塞下页面就变得更卡顿了。这也是我们平时常说的不要把 JS 文件放在 CSS 样式表之后的原因。</p>
<h1 id="异步加载-JS-脚本"><a href="#异步加载-JS-脚本" class="headerlink" title="异步加载 JS 脚本"></a>异步加载 JS 脚本</h1><p>  &emsp;&emsp;在<code>&lt;script&gt;</code>标签中可以设置两个属性，分别是<code>defer</code>和<code>async</code>，设置了<code>defer</code>和<code>async</code>的 JS 脚本相当于异步加载 JS 文件。在普通的<code>&lt;script&gt;</code>下，JS 的加载会暂停后续 DOM 的解析，而设置<code>defer</code>和<code>async</code>的<code>&lt;script&gt;</code>可以<strong>边加载 JS 文件，边进行 DOM 解析</strong>，这两个过程是并行发生的。需要注意的是，这两个属性只能作用于外部引入的脚本，对于内联脚本是不起作用的。</p>
<p>  &emsp;&emsp;两者的区别在于，<code>defer</code>加载的 JS 脚本会延迟执行，等到该 JS 脚本加载完毕并且 DOM 也解析完成后才会执行该 JS 代码。而<code>async</code>则是一旦加载完成 JS 脚本就会马上执行，如果这时候 DOM 还没有解析完成也是会先暂停解析先等待 JS 执行完毕的（同样会阻塞）。如果使用<code>defer</code>加载多个 JS 脚本，那 JS 脚本会按照它们在代码中的先后顺序执行。而<code>async</code>因为是 JS 脚本一加载完成就马上执行，所以并不能保证 JS 脚本的执行顺序，这取决于哪个 JS 脚本先加载完成。下面这张图很直观地展示了三者的区别。</p>
<p>  <img src="/2019/04/19/从浏览器的渲染机制谈起/5.jpg" alt></p>
<p>&emsp;&emsp;需要注意的是，<strong><code>defer</code>脚本会在<code>DOMContentLoaded</code>监听函数之前（相当于 jQuery 的 ready 事件）执行</strong>。而<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded" target="_blank" rel="noopener">什么是 DOMContentLoaded 事件</a>，用一句话概括就是，<code>DOMContentLoaded</code>会在 DOM 构建完毕后触发，此时<code>&lt;link&gt;</code>和<code>&lt;img&gt;</code>等外部资源可能还没有加载完成。和<code>DOMContentLoaded</code>相似的还有一个<code>load</code>事件，这个大家应该比较熟悉了。<code>load</code>事件不仅得等待 DOM 构建完成，还得等页面上其他的资源如图片音频和视频等都加载完后才触发，所以<code>load</code>事件是在<code>DOMContentLoaded</code>事件之后才触发的。至于<code>async</code>则情况会复杂一点，并不能确保<code>async</code>与<code>DOMContentLoaded</code>的执行先后顺序（但会在<code>load</code>之前执行）。这是因为<code>async</code>脚本一加载完毕就会马上执行，所以<code>async</code>与<code>DOMContentLoaded</code>的执行先后顺序取决于<code>async</code>脚本的加载完成时间。如果<code>async</code>脚本在 DOM 解析完成之前就加载完毕了，那么<code>async</code>脚本会先于<code>DOMContentLoaded</code>执行，反之则是<code>DOMContentLoaded</code>先于<code>async</code>脚本执行。（不知道看客们会不会有一个疑问，<code>defer</code>脚本不是构建完 DOM 才执行的吗，而<code>DOMContentLoaded</code>也是在构建完 DOM 完后就执行，那<code>defer</code>脚本怎么就一定会先于<code>DOMContentLoaded</code>执行呢？其实我也不知道，因为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script#%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">MDN</a> 就是这么写的。）</p>
<p>&emsp;&emsp;除了使用<code>defer</code>和<code>async</code>异步加载 JS 脚本外，我们还可以动态加载脚本，即在页面加载完成后才导入 JS 脚本，这样也可以避免阻塞页面渲染。</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>
  window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ele<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span><span class="token punctuation">;</span>
    ele<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'test.js'</span><span class="token punctuation">;</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<h1 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h1><h2 id="何时发生重排和重绘"><a href="#何时发生重排和重绘" class="headerlink" title="何时发生重排和重绘"></a>何时发生重排和重绘</h2><p>&emsp;&emsp;前面在说浏览器渲染的五个阶段的时候，后两个阶段分别是布局和绘制，其实对应的就是重排（也叫做回流）和重绘，而重排和重绘常常是影响页面性能的主因之一。我们先说说什么时候会触发重排和重绘。当页面中某一个元素的几何属性如大小位置等发生变化时，浏览器就需要重新计算该元素的几何属性，并且页面中的其他元素也都会受到影响，所以这时候就会对页面进行重新布局。造成重排的操作包括但不限于：</p>
<ul>
<li>页面首屏初始化加载。</li>
<li>添加或删除可见的 DOM 元素（包括设置元素的<code>display: none</code>属性）。</li>
<li>改变元素的位置。</li>
<li>改变元素的大小，如外边距、边框、内边距、宽高等。</li>
<li>内容改变导致元素的大小改变，如改变图片大小或是将图片替换成另一张不同尺寸的图片。</li>
<li>改变浏览器窗口大小。</li>
</ul>
<blockquote>
<p>根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改根节点。</p>
</blockquote>
<p>&emsp;&emsp;而重绘则相对友好一些，不会导致页面重新布局，只是重新绘制受影响的部分元素。常见的造成重绘的操作除了上述的操作外还有：修改元素的背景颜色、字体的颜色和修改元素的外观显示<code>outline</code>等。由此我们也可以发现重排和重绘之间的关系：<strong>重排一定会造成重绘，但重绘不一定会重排</strong>。</p>
<h2 id="如何减小重排和重绘"><a href="#如何减小重排和重绘" class="headerlink" title="如何减小重排和重绘"></a>如何减小重排和重绘</h2><p>&emsp;&emsp;重排和重绘很消耗性能，所以我们在编写代码的时候应该有意识地去避免一些造成重排和重绘的发生（我们常常被建议不要去操作 DOM，因为操作 DOM 慢，而慢的原因就是因为操作 DOM 常常会引起重排和重绘）。</p>
<h3 id="合并对样式的修改"><a href="#合并对样式的修改" class="headerlink" title="合并对样式的修改"></a>合并对样式的修改</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'box'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token string">'100px'</span><span class="token punctuation">;</span>
ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token string">'100px'</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;我们常常会使用诸如上面示例的方法去修改 DOM 节点的样式，但上面这样的修改方式操作到了两次 DOM ，更糟糕的是导致了浏览器发生两次重排。所以我们可以通过<code>cssText</code>来合并对同一个 DOM 节点的多次修改，从而把操作 DOM 和重排的次数降为 1，优化页面性能。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> ele <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'box'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">=</span> <span class="token string">'top: 100px; left: 100px'</span><span class="token punctuation">;</span>
ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'width: 100px; height: 100px;'</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;需要一提的是，<code>cssText</code>会覆盖掉之前设置好的样式，比如示例中如果不使用<code>+=</code>来拼接样式信息的话，则显示出来的元素会丢失原先设置好的<code>left</code>和<code>right</code>样式。当然，除了使用<code>cssText</code>外，我们还可以通过增加或修改元素的<code>class</code>来控制元素的样式显示（在 Vue 中不就常这么干）。</p>
<p>&emsp;&emsp;不过现在大多数浏览器会尽量把所有的样式变动都集中到一起，形成一个队列再批量处理，从而来避免页面多次重排。比如上面对<code>left</code>和<code>right</code>样式的修改，浏览器会把两次修改集中到一起再执行，这样就能只重排一次了。但<strong>一些操作会阻止浏览器对样式修改进行批量修改，强制页面马上重新渲染</strong>。比如以下方法:</p>
<ul>
<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>
<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>
<li>clientTop、clientLeft、clientWidth、clientHeight</li>
<li>getComputedStyle()</li>
</ul>
<p>&emsp;&emsp;以上这些操作要求浏览器返回最新的页面信息，所以浏览器不得不马上渲染已修改了的样式信息，造成页面多次重排。所以平时应该尽量少的去使用上述的属性，或者尽量不要把样式的写操作和读操作放在同一个语句里，可以先使用一个变量存储元素的上述的一些样式信息再进行写操作。</p>
<h3 id="批量修改-DOM"><a href="#批量修改-DOM" class="headerlink" title="批量修改 DOM"></a>批量修改 DOM</h3><p>&emsp;&emsp;有时候 DOM 节点并不是静态的，而需要我们去动态添加并进行一系列操作。比如在页面中给<code>ul</code>插入 N 个<code>li</code>，如果我们只是常规地在一个 for 循环中创建节点再添加的话，会对 DOM 操作 N 次并造成 N 次重排，这样对性能的影响可想而知。所以我们可以先让要操作到的元素脱离文档流再进行批量操作，最后再将元素添加回文档流中，这样就可以大大减小页面重排的次数。常用的方法有：</p>
<ol>
<li>使用<code>display: none</code>隐藏元素</li>
</ol>
<p>&emsp;&emsp;利用设置了<code>display: none</code>的元素在文档流中不占空间，所以我们可以先改变<code>ul</code>的<code>display</code>属性，再在<code>ul</code>上添加<code>li</code>，最后再恢复原先<code>ul</code>的<code>display</code>属性即可。</p>
<ol start="2">
<li>使用文档片段</li>
</ol>
<p>&emsp;&emsp;使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createDocumentFragment" target="_blank" rel="noopener">document.createDocumentFragment()</a>来创建一个文档片段，而因为文档片段存在于内存中，所以将子元素插入到文档片段时并不会对 DOM 树造成任何影响，因此自然就不会造成多余的重排了。只要将操作完后的文档片段添加到<code>ul</code>后即可，而这整个过程只会造成一次重排。</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span>
  <span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">"ul"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>
  <span class="token operator">&lt;</span>script<span class="token operator">></span>
    <span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      li<span class="token punctuation">.</span>innerText <span class="token operator">=</span> i<span class="token punctuation">;</span>
      fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ul<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
</code></pre>
<ol start="3">
<li>克隆原节点修改后再替换</li>
</ol>
<p>&emsp;&emsp;使用<code>cloneNode</code>克隆要进行修改的节点，在克隆的节点（副本）上进行操作后再使用<code>replaceChild</code>替换掉原先的节点。</p>
<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">"ul"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>
  <span class="token operator">&lt;</span>script<span class="token operator">></span>
    <span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> clone <span class="token operator">=</span> ul<span class="token punctuation">.</span><span class="token function">cloneNode</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> li <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      li<span class="token punctuation">.</span>innerText <span class="token operator">=</span> i<span class="token punctuation">;</span>
      clone<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ul<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">replaceChild</span><span class="token punctuation">(</span>clone<span class="token punctuation">,</span> ul<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
</code></pre>
<blockquote>
<p>对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载6～20个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。</p>
</blockquote>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>&emsp;&emsp;这篇博客页只是对浏览器的渲染过程做了一个大致的分析而已，如果对浏览器渲染的五个步骤进行深究下去其实还可以挖出很多细节的东西（前端就这样，原理的东西可以一个劲地深挖下去，而且还涉及的很广）。碍于个人所学有限，就先做一个简单的分析，等以后有了更深入的认识我再回来补充吧。或者看客有兴趣的话可以阅读下面这几篇深度好文做详细了解（超级长文预警）。</p>
<p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn" target="_blank" rel="noopener">构建对象模型</a><br><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a><br><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#The_parsing_algorithm" target="_blank" rel="noopener">How browsers work</a><br><a href="https://blog.csdn.net/riddle1981/article/details/90756332" target="_blank" rel="noopener">从渲染原理谈前端性能优化</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>事件模型和事件委托</title>
    <url>/2019/04/12/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&emsp;&emsp;这回说的是事件模型，跟上篇博客说的事件循环关系不大。事件循环主要是同异步事件在内部环境的执行过程，而事件模型主要是涉及到事件的生成过程，在实践中的应用比较多，比如说常见的事件委托（也叫做事件代理）。</p>
<h1 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h1><p>&emsp;&emsp;事件模型指的是当我们触发一个事件时，会经历三个阶段，分别是捕获阶段，目标阶段，冒泡阶段。（<strong>IE8及之前版本 的事件模型则没有捕获阶段</strong>）</p>
<ol>
<li>捕获阶段：事件对象从window经过目标节点的祖先节点到达目标节点，若经过的结点中绑定有同类型事件的监听函数，则会被触发执行。</li>
<li>目标阶段：事件对象到达目标节点，开始执行指定的事件监听函数。若该事件对象被标志为不能冒泡，则到此会停止执行。</li>
<li>冒泡阶段：事件对象从目标节点经过目标节点的祖先节点到达window，若经过的结点中绑定有同类型事件的监听函数，则会被触发执行。</li>
</ol>
<p>&emsp;&emsp;在捕获阶段从 window 到目标节点经过的节点顺序为 window -&gt; document -&gt; html -&gt; body -&gt; 祖先节点 -&gt; 父亲节点 -&gt; 目标节点，冒泡阶段则反过来。</p>
<p><img src="/2019/04/12/事件模型和事件委托/1.png" alt></p>
<p>&emsp;&emsp;我们可以用代码验证一下：</p>
<pre class=" language-html"><code class="language-html">// html 代码， css的样式代码就不贴了
&lt;div id="parent>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>children<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
</code></pre>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// JS代码</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"window"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"document"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"parent"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"parent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"children"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"children"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
</code></pre>
<p><img src="/2019/04/12/事件模型和事件委托/2.png" alt></p>
<p>&emsp;&emsp;上面结果是通过点击 children 节点得到的。 需要注意的是，addEventListener 函数的第三个参数表示是否在捕获阶段触发监听函数，默认为 false 即在冒泡阶段才触发，为 true 时则在捕获阶段触发。我们把上面代码的第三个参数都修改成 false 看看冒泡阶段的执行顺序。</p>
<p><img src="/2019/04/12/事件模型和事件委托/3.png" alt></p>
<p>&emsp;&emsp;可以看到，冒泡阶段的执行顺序确实是和捕获阶段相反的。当然如果你给某一个节点的捕获阶段和冒泡阶段都添加相应的事件监听函数，则在一次点击事件中两者都会触发到。我们把上面捕获阶段和冒泡阶段的代码放到一起执行来验证看看。</p>
<p><img src="/2019/04/12/事件模型和事件委托/4.png" alt></p>
<p>&emsp;&emsp;这里还有一个注意点，如果<strong>目标节点</strong>同时定义了同类型事件捕获阶段和冒泡阶段的监听函数，则<strong>哪个事件代码写在前面就先执行哪个</strong>，而对于非目标节点则都是先执行捕获后执行冒泡。这里就不贴图了，看客们可以自行验证。</p>
<h1 id="Event-对象"><a href="#Event-对象" class="headerlink" title="Event 对象"></a>Event 对象</h1><p>&emsp;&emsp;关于 Event 对象，这里只介绍四个和事件模型相关的 api，其余部分看客们可直接查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event" target="_blank" rel="noopener">MDN</a>。</p>
<h2 id="event-stopPropagation"><a href="#event-stopPropagation" class="headerlink" title="event.stopPropagation()"></a>event.stopPropagation()</h2><p>&emsp;&emsp;如果要阻止事件继续向下捕获或向上冒泡的话，可以直接在相应的目标事件中使用<code>event.stopPropagation()</code>（但依旧会执行当前节点的监听函数）。如果是非目标节点的话，在执行完当前节点的相应事件后就会停止执行了。<strong>如果是目标节点的话，即使在捕获阶段阻止了也还是会执行目标节点的冒泡事件再停止执行</strong>。</p>
<p>&emsp;&emsp;除了<code>event.stopPropagation()</code>，<code>event.cancelBubble = true</code>也可以达到同样的功能，不过<code>event.cancelBubble = true</code>主要是用于做 IE 兼容，而且已经 Web 标准中删除了。我试了下，发现不管是<code>event.stopPropagation()</code>，还是<code>event.cancelBubble = true</code>在 Chrome 和 IE11 中都起作用了。<code>event.cancelBubble = true</code>了解一下就好了，说不定以后哪天需要兼容到 IE 老古董的时候就可以派上用场。</p>
<h2 id="event-composedPath"><a href="#event-composedPath" class="headerlink" title="event.composedPath()"></a>event.composedPath()</h2><p>&emsp;&emsp;<code>event.composedPath()</code>会返回一个数组，成员是目标节点最内层的子节点和依次冒泡经过的所有上层节点。还是使用上面的代码，我们在 children 节点的点击监听函数中使用<code>event.composedPath()</code>再点击验证看看。</p>
<p><img src="/2019/04/12/事件模型和事件委托/6.png" alt></p>
<h2 id="event-stopImmediatePropagation"><a href="#event-stopImmediatePropagation" class="headerlink" title="event.stopImmediatePropagation()"></a>event.stopImmediatePropagation()</h2><p>&emsp;&emsp;如果有多个相同类型事件的监听函数绑定到同一个元素上的话，则当触发事件时，会把这些事件按代码编写顺序都执行下去。若在某一个事件上增加<code>event.stopImmediatePropagation()</code>则可以阻止执行剩下的同类型监听函数。</p>
<h2 id="event-preventDefault"><a href="#event-preventDefault" class="headerlink" title="event.preventDefault()"></a>event.preventDefault()</h2><p>&emsp;&emsp;<code>event.preventDefault()</code>顾名思义是用来阻止默认行为的，可以阻止浏览器给一些事件预先设置好的默认行为如 a 标签的页面跳转等。在 jQuery 中则可以直接使用<code>return false</code>来阻止默认行为，简单粗暴，然而现在这年头估计很少用 jQuery 了吧。</p>
<p>&emsp;&emsp;之前我在做 <a href="https://github.com/DangoSky/2048" target="_blank" rel="noopener">2048</a> 的时候发现一个问题，在移动端如果一个页面的宽高都只是移动设备视图的百分之百即不会出现水平垂直滚动，但若页面中给某一个元素添加了 touch 监听事件，则在 touchmove 的时候是会触发浏览器的默认行为造成页面滑动的。当然这时候可以选择使用<code>event.preventDefault()</code>来阻止移动端页面的默认滑动行为，但这时候会报错<code>Unable to preventDefault inside passive event listener due to target being treated as passive</code>。</p>
<p>&emsp;&emsp;之所以会这样和<code>addEventListener</code>的第三个参数配置有关，一般情况下我们都是不设置第三个参数的，因为它默认下是 false 表示事件在冒泡阶段触发，这也是我们想要的效果。但<strong>实际上第三个参数是可以设置为一个对象的</strong>，包括了几个属性：</p>
<ul>
<li>capture： 表示监听函数是否在捕获阶段执行，默认为 false。</li>
<li>once： 表示监听函数最多只会调用一次，设置为 true 后监听函数在第一次调用后会自动被移除。</li>
<li>passive： 表示监听函数永远不会阻止默认行为，默认为 true，如果这时候监听函数仍使用<code>event.preventDefault()</code>就会报错。</li>
</ul>
<p>&emsp;&emsp;没错，会报<code>Unable to preventDefault inside passive event listener due to target being treated as passive</code>的错误就是和这个 passive 有关。这样的设置也是有原因的，简而言之就是，当我们触发页面的 touch 事件的时候，浏览器其实并不知道页面是否需要滚动，这得根据监听函数里是否有阻止默认行为。所以浏览器只能等 touch 监听事件执行完毕后才能开始选择滚动与否，这就造成了页面的滚动会有一定时间的延迟（我看到的说是 200ms）。而为了避免这无谓的浪费，就在<code>addEventListener</code>的第三个参数中配置 passive 提前告诉浏览器是否需要滚动以提高页面响应速度。说到这，解决那报错的方法就很明显了，直接把 passive 设置为 false 就可以了。</p>
<h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>&emsp;&emsp;事件委托是利用事件冒泡来实现的，在实际的应用中十分常见。当我们想要给子元素比如 li 添加监听函数的时候，可以选择把监听函数委托给父元素如 ul 上，在子元素上触发该事件时通过冒泡到父元素上再触发。这样可以避免为每一个子元素单独编写监听函数（不但浪费内存而且代码还冗余），更重要的是可以<strong>给之后动态添加进来的子元素也绑定该监听事件</strong>！</p>
<pre class=" language-html"><code class="language-html">// html 代码
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>给ul添加一个li标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ul<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我是子元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我是子元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>我是子元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>
</code></pre>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// JS 代码</span>
<span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  e <span class="token operator">=</span> e <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
  <span class="token keyword">let</span> ele <span class="token operator">=</span> e<span class="token punctuation">.</span>target <span class="token operator">||</span> e<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
  ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> tag <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> text <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">"我是动态添加进来的子元素"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  tag<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
  ul<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p><img src="/2019/04/12/事件模型和事件委托/6.png" alt></p>
<p>&emsp;&emsp;上面的代码实现中涉及到一个问题，它对于每一个子元素的点击都会进行响应，但如果我们不想给其他子元素例如 p 和 span 等标签也添加事件监听那怎么办？其实这也可以办到，只要在监听函数里判断目标元素是不是 li 标签就可以了。</p>
<pre><code>if(ele.tagName.toLowerCase() === &#39;li&#39;) {
  ele.style.color = &#39;red&#39;;
};
</code></pre><p>&emsp;&emsp;这里再稍微提一下<code>e.target</code>和<code>e.currentTarget</code>，平时还是挺容易混淆两者的。<strong><code>e.target</code>获取的是真正触发事件的目标节点，而<code>e.currentTarget</code>获取的是绑定监听事件的节点</strong>。以上面的代码为例，当我们点击每一个 li 时，<code>e.target</code>获取到的就是点击到的那个 li，而<code>e.currentTarget</code>获取到的就是 ul，因为监听事件其实是绑定到 ul 上的。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>事件队列和事件循环</title>
    <url>/2019/04/07/%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="JavaScript是单线程的"><a href="#JavaScript是单线程的" class="headerlink" title="JavaScript是单线程的"></a>JavaScript是单线程的</h1><p>&emsp;&emsp;JavaScript 从出生以来就是单线程的，这可能和 JavaScript 一切从简有关，毕竟是人家只花了10天就开发出的语言。也可能是受限于 JavaScript 的用途，JavaScript 作为脚本语言控制着页面的行为，如果有多个线程同时对页面的某一个元素进行操作，比如对同一个 DOM 元素进行增删操作，那浏览器要听哪个线程的？所以如果是多线程的话，浏览器在响应时就会变得很复杂了。（难道要像多进程那样引入锁？？）</p>
<p>&emsp;&emsp;而单线程意味着主线程只能一次执行一个任务，不能同时执行多个，这就导致了像 http 请求等耗时长的任务很可能会长时间占用着主线程，堵塞了执行栈中其他任务的执行。互联网上有一个八秒准则（当然这个八秒也只是一个虚数而已），即用户在执行操作后如果页面在 8s 之内没有得到响应，进入假死状态，则用户会失去耐心直接关闭页面（不知道你们会不会这样，反正我就是这样的，不过可能我耐心好一点所以我会等上个十几秒）。所以考虑到主线程堵塞的问题，JavaScript 异步操作就应运而生了。异步任务不会在执行期间长时间占用主线程，而是会先被主线程挂起，等达到一定条件比如 http 请求得到响应或到了代码指定的延迟时间后，通过调用回调函数的方式来回头完成代码的执行，而在这段时间内主线程就可以去执行其他的任务了，这样即使 http 请求花费了很长时间甚至是一直没有响应也不会堵塞到其他任务的执行。</p>
<h1 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h1><p>&emsp;&emsp;当程序在执行过程中遇到异步任务时会先把异步任务挂起，交由其他相关的浏览器线程处理。注意，这里指的是浏览器线程，<a href="https://imweb.io/topic/58e3bfa845e5c13468f567d5" target="_blank" rel="noopener">引用一下相关的描述</a>：</p>
<blockquote>
<p> 浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>
<ul>
<li>GUI 渲染线程</li>
<li>JavaScript引擎线程</li>
<li>定时触发器线程</li>
<li>事件触发线程</li>
<li>异步http请求线程</li>
</ul>
<p>GUI渲染线程：<br>&emsp;&emsp;GUI渲染线程负责渲染浏览器界面HTML元素，当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行。在Javascript引擎运行脚本期间，GUI渲染线程都是处于挂起状态的，也就是说被“冻结”了（与 JavaScript 引擎线程互斥，即两个线程不能同时运行）。</p>
<p>Javascript引擎线程：<br>&emsp;&emsp;Javascript 引擎，也可以称为JS内核，主要负责处理 Javascript 脚本程序，例如V8引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。</p>
<p>定时触发器线程：<br>&emsp;&emsp;浏览器定时计数器并不是由 JavaScript 引擎计数的， 因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确， 因此通过单独线程来计时并触发定时是更为合理的方案。</p>
<p>事件触发线程：<br>&emsp;&emsp;当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p>
<p>异步http请求线程：<br>&emsp;&emsp;在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。</p>
</blockquote>
<p>&emsp;&emsp;以<code>setTimeout</code>为例，当Javascript引擎运行到<code>setTimeout</code>时，因为<code>setTimeout</code>是一个异步事件，所以会将<code>setTimeout</code>交由相关的<strong>定时触发器线程</strong>进行计时操作。在<code>setTimeout</code>被挂起的这段时间之内，主线程依然会马不停蹄地接着往下执行代码而不会等待<code>setTimeout</code>。当定时触发器线程计时达到<code>setTimeout</code>指定的延迟时间后，就会把<strong>setTimeout的回调函数</strong>推入到事件队列中。注意，这里只是把回调函数推入到事件队列，并不意味着会马上执行它，<strong>只有等到执行栈中所有的同步事件都执行完毕后，才会去读取事件队列中的事件并将其放到执行栈中执行</strong>（既然是一个队列，事件队列自然就有 queue <strong>先进先出</strong>的特性了）。因为得先执行完执行栈中所有的同步事件才会去读取事件队列中的事件，所以这也决定了<strong>setTimeout 指定的执行延迟时间是不准确的</strong>，这发生在执行栈中所有事件执行完毕的所需时间大于延迟时间的时候，因此 HTML5 也规定了<code>setTimeout</code>的最小延迟时间不能小于 4ms（当然并不是所有的浏览器都遵循了这个标准）。我们可以用代码说话：</p>
<pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> time <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"执行定时器的事件"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> time <span class="token operator">&lt;</span> <span class="token number">2000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/* 
  start 2019-04-07T11:56:51.537Z
  end 2019-04-07T11:56:53.541Z
  执行定时器的事件 2019-04-07T11:56:53.542Z
*/</span>
</code></pre>
<p>&emsp;&emsp;我们可以分析一下上面代码的执行过程，JavaScript引擎开始解析代码，先生成全局执行上下文并把它压入到执行栈中（当然其中还有生成 VO、确定 this 指向和建立作用域链的环节，这不是本文重点就略过不提了。遇到<code>console.log(&quot;start&quot;, new Date())</code>发现这是一个同步事件后马上执行并输出 start 和当前的时间点。接着给 time 变量赋值后（注意是赋值，而不是声明，因为在创建全局执行上下文的时候就已经变量提前声明了）遇到了<code>setTimeout</code>事件，因为这是一个异步事件所以 JavaScript 引擎会把它挂起交由定时触发器线程进行计时操作。接着进入到 while 循环，我们手动地给 while 循环的持续时间设定为 2000ms，而在这 2000ms 内定时触发器线程已经完成了对<code>setTimeout</code>事件的计时并把它的回调函数放入到事件队列中了。但这时候因为执行栈中还有 while 循环在执行，所以<code>setTimeout</code>的回调函数还是留在事件队列中没能进入执行栈。2000ms 过后 JavaScript引擎继续向下解析，输出 end 和当前的时间点，之后执行栈中所有的同步事件便都执行完毕了，开始读取事件队列发现有<code>setTimeout</code>便把它取出放到执行栈中执行，所以最后输出“执行定时器的事件”和当前的时间点。</p>
<p>&emsp;&emsp;通过上面的分析以及输出的三个时间点，我们可以发现<code>setTimeout</code>指定的执行延迟时间确实是不确切的，这依赖于执行栈中所有同步事件执行完毕所需的时间，执行<code>setTimeout</code>回调函数的延迟时间只会大于指定的延迟时间而不会小于延迟时间。</p>
<p>&emsp;&emsp;在我写这篇博客的时候，我还有一个疑惑。我看到许多的博客说的都是异步事件的回调函数进入事件队列后，是等执行栈为空的时候才会取出事件队列中的事件放入到执行栈中去执行，不知到各位看客对此有没有什么疑问。<strong>如果事件队列中的事件是否进入执行栈的判断标准是执行栈是否为空的话，那就涉及到执行栈是否会为空了？</strong>想必大家都知道执行上下文吧，其中全局执行上下文在程序一开始执行就被创建，并且会被压入到执行栈中并一直存在执行栈底直到页面被关闭。是的，全局执行上下文一直存在执行栈底，这点应该没有什么争议。既然如此，是否意味着执行栈一直非空呢？这样的话事件队列中的事件还怎么通过判断执行栈是否为空来进入执行栈，不就一直进入不了执行栈了吗，这两者就冲突了啊！如果按执行栈是否为空为标准来判断事件队列中的事件是否进入执行栈，则势必要理清执行栈到底会不会为空的问题，如果不会为空的话怎么解释事件队列中的事件只有等到执行栈为空时才会进入执行栈中，如果会为空的话怎么解释全局执行上下文会一直存在执行栈栈底？所以我觉得以执行栈是否为空为标准来判断事件队列中的事件是否进入执行栈并不恰当，而是<strong>以执行栈中的同步事件是否都执行完毕为标准来判断</strong>（只剩下全局执行上下文）会更容易理解，这样就没有上面说的和全局执行上下文一直存在执行栈底的冲突了。</p>
<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>&emsp;&emsp;事件循环是建立在事件队列的基础上的，当执行栈中所有的同步事件都执行完毕后就会去读取事件队列中的事件，如果事件队列中有事件存在则取出放到执行栈中执行，否则的话就继续读取事件队列，这样不断地读取、执行、读取、执行的周而复始就成了事件循环。</p>
<p>&emsp;&emsp;引用一张经典的图辅助吧：<br><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png" alt></p>
<p>&emsp;&emsp;上图中，执行栈执行其中的同步任务，若代码中调用了外部异步的 Web API 如 DOM 事件、<code>Ajax请求</code>和<code>setTimeout</code>等，就将它们的回调函数放入到事件队列中，等执行栈中的同步事件都执行完毕后就读取事件队列，取出其中的事件到执行栈中执行，在执行栈和事件队列之间不断循环。不过我觉得这图里缺少了异步事件的回调函数是如何放到事件队列中的过程，比如<code>setTimeout</code>和<code>Ajax 请求</code>，<code>setTimeout</code>事件是马上就被放入到事件队列中的，还是等到了指定的延迟时间后才会推入到事件队列。如果是后者的话，在到达指定的延迟时间这段时间之内，<code>setTimeout</code>事件既然不在执行栈也不在事件队列中那是在哪里，是怎么进行计时的？（前文有解释到，定时触发器线程负责了<code>setTimeout</code>事件的计时，到达指定事件后就把其回调函数推入到事件队列中）</p>
<p>&emsp;&emsp;要声明的是，上述的事件循环是指浏览器环境下的事件循环，跟 nodeJS 的事件循环机制是不一样的。而 nodeJS 的事件循环是怎样的，我现在也还不清楚，就等以后我再写一篇博客介绍吧。</p>
<h1 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h1><p>&emsp;&emsp;其实异步任务还有再细分为两种的，分别是宏任务（macro task）和微任务（micro task）。其中宏任务主要有<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>I/O</code>和<code>UI rendering</code>等， 微任务主要有<code>Promise</code>、<code>process.nextTick</code>（process 是只存在于 Node 环境中的全局变量）和<code>MutationObserver</code>。前文介绍的是，异步事件的回调函数会被推入到事件队列中，但实际上还会根据这个异步事件的类型再推入到相应的宏任务事件队列或微任务事件队列中去。当执行栈中所有的同步事件都执行完毕后主线程会先读取微任务事件队列，如果其中有事件存在则会依次将它们放入到执行栈中去执行，接着才会去读取宏任务队列中的事件（即<strong>同一次事件循环中微任务永远在宏任务之前执行</strong>），如此周而复始慢慢循环。我们总结一下事件循环的执行过程就是，在一趟事件循环中：</p>
<ol>
<li>把执行栈中所有的同步任务都执行完。</li>
<li>先处理<strong>所有</strong>微任务事件队列中的事件。</li>
<li>在宏任务事件队列中取出<strong>一个</strong>事件放入到执行栈中执行。</li>
<li>不断重复 1、2、3 的过程。</li>
</ol>
<p>&emsp;&emsp;我还看到一个点：<strong>浏览器是在每一次事件循环之间渲染页面的</strong>。不过这点我也不知道怎么验证，就暂且先记着吧。</p>
<h2 id="Node10-x-和浏览器环境下的不同"><a href="#Node10-x-和浏览器环境下的不同" class="headerlink" title="Node10.x 和浏览器环境下的不同"></a>Node10.x 和浏览器环境下的不同</h2><p>&emsp;&emsp;说完宏任务和微任务的运行机制后就要敲黑板了：<strong>上面所述是针对浏览器环境而言的！上面所述是针对浏览器环境而言的！上面所述是针对浏览器环境而言的！</strong>重要的事情说三次！为什么说是针对浏览器环境而言呢？因为<strong>在 node 环境下，宏任务和微任务的运行机制是不同的！</strong>这里的 node 环境指的是 node10.x，node10 以下的我就不清楚了（原谅我缺乏打破砂锅问到底的精神就不回退版本去验证了Orz，有兴趣的看客可以自行验证，不过我估计跟 node10.x 是一样的）。当前 node 最新版本是 node11.x，<strong>在 node11.x 就将宏任务和微任务的运行机制统一得跟浏览器环境一样了</strong>。</p>
<p>&emsp;&emsp;强调完宏任务和微任务的运行机制在浏览器环境和 node10.x中不一样后，我们再来看看究竟有何不同。前面我们说到当执行栈中的同步任务都执行完毕后，会先清空微任务事件队列中的所有事件，再从宏任务事件队列中取出<strong>一个</strong>事件放到执行栈中执行，这是在浏览器环境下的。而在 node10.x 环境下，清空微任务事件队列中的所有事件后，有时候会跟浏览器环境一样再从宏任务事件队列中取出一个事件执行，<strong>有时候则是清空宏任务事件队列中的所有事件</strong>。你没有看错，就是<strong>有时候</strong>，具体采取哪一种运行机制我也不知道（不过根据多次的运行结果，node10.x <strong>采取后者的概率要比前者大得多</strong>），这也造成了同一段代码在 node 环境下运行结果有时候会是不一样的。我们先看一段简单的代码吧。</p>
<pre class=" language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"timer1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"timer2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;我们分别在浏览器环境和 node 环境去运行上面的代码，可以看到在浏览器环境下无论你运行多少次，结果输出的顺序都只会是 timer1 promise1 timer2 promise2 。而在 node10.x 环境下，输出的结果往往会是 timer1 timer2 promise1 promise2，但如果你多运行几次的话就会发现结果有时候跟在浏览器环境下是一样的，这也证明了 node10.x 环境下对宏任务和微任务采取的运行机制后者比前者要大得多（发现这点的时候我其实是 Orz 的，一个程序的结果还能有不确定性的，真的是 too young to simple）。</p>
<p>&emsp;&emsp;简要解释一下node 环境下为什么会输出 timer1 timer2 promise1 promise2 吧，浏览器环境下的结果应该没什么好解释的了，前面应该说的够清楚了吧。node10.x 环境下在清空执行栈中所有的同步任务并清空所有的微任务后，有时候只是从宏任务队列中取出一个事件放到执行栈中执行而已（这也是浏览器下的运行机制，node11.x 也是如此），但更多时候并不只是取出一个事件，而是会执行完宏任务事件队列中的所有事件。也就是说取出第一个<code>setTimeout</code>定时器执行完，并不会马上执行 Promise 的回调函数，而是会继续执行<strong>同轮循环</strong>下其他的宏任务，所有在输出 timer1 后就跟着输出了 timer2，最后才去清空微任务事件队列。</p>
<h2 id="process-nextTick具有优先权"><a href="#process-nextTick具有优先权" class="headerlink" title="process.nextTick具有优先权"></a>process.nextTick具有优先权</h2><p>&emsp;&emsp;process是 node 环境下的全局变量，浏览器环境下是不具有的，因此<code>process.nextTick</code>自然也只能在 node 环境下使用了。上文有说到，<code>process.nextTick</code>是属于微任务事件队列的，但需要注意的是，在 node 环境下<strong>process.nextTick 在微任务事件队列中的优先级会大于其他的微任务</strong>，即清空微任务事件队列时会先执行所有的<code>process.nextTick</code>事件。我们实践一下：</p>
<pre class=" language-js"><code class="language-js">Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;上面的代码不管是在 node10.x 还是在 node11.x 都会先执行 process.nextTick 再执行 promise 的回调函数！</p>
<h2 id="setTimeout-和-setImmediate-的优先顺序"><a href="#setTimeout-和-setImmediate-的优先顺序" class="headerlink" title="setTimeout 和 setImmediate 的优先顺序"></a>setTimeout 和 setImmediate 的优先顺序</h2><p>&emsp;&emsp;<code>setImmediate</code>的功能和<code>setTimeout</code>其实是一样的，不同点在于<code>setImmediate</code>会马上调用，相当于设置了 0ms 延迟的 setTimeout。其中的坑点在于：<code>setImmediate</code>和设置 0ms 延迟的<code>setTimeout</code>的执行顺序是不确定的。</p>
<pre class=" language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;上面的代码，可能先输出 timeout 也可能先输出 immediate，node 10.x 和 node11.x 都是如此。不过好像有一个规律是：当 script 整体代码执行完的时候，如果已经过了<code>setTimeout</code>指定的延迟时间的话则会先执行<code>setTimeout</code>，即使<code>setImmediate</code>出现在<code>setTimeout</code>之前，反之若整体代码执行完后<code>setTimeout</code>还没有到指定的延迟时间，则会先执行<code>setImmediate</code>。我们修改一下上面的代码试试。</p>
<pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"耗时:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// for(let i=1; i&lt;=1000000; i++) {}</span>
console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"耗时:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;emmm，好像只有在执行完 script 所有代码所需的时间和 <code>setTimeout</code>的指定延迟时间相差较大（差不多得差上 5ms 左右吧）时，上述的规律才会成立，我们可以使用一个空的 for 循环来增加执行 script 所有代码所需的时间。不过这所谓的规律也只是猜想而已，不一定正确，具体的还是得去看 node 的源码啊Orz。等以后有时间了再去看吧，感觉现在还不太适合去看源码，更何况还是 node 的源码。现阶段还是先继续把 JS 的基础打好，毕竟框架啥的也都是离不开 JS 的，基础还是很重要滴，不能只会调用 api 只知概念而不知原理吧。</p>
<hr>
<p>&emsp;&emsp;最后再留下一段代码当做课后习题吧，各位看客有兴趣的可以自个先分析后再上机跑一下结果。提醒一下，浏览器环境和 node10.x 环境结果是不一样的。如果你在浏览器中跑这段代码得到将会是<code>Uncaught ReferenceError: process is not defined</code>，至于原因看客们自己想想，想不到就把这篇博客再看一遍吧。要验证浏览器环境下的输出，看客可以使用 node11.x 的环境运行，前面也有提到，node11.x 和 浏览器环境下的运行机制是统一的。</p>
<pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'7'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'11'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'12'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝的实现</title>
    <url>/2019/04/01/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><p>&emsp;&emsp;先用简单的两句话概括深拷贝和浅拷贝的区别吧。<br>&emsp;&emsp;浅复制：只将对象的各个属性进行一层复制，因此对于引用数据类型而言<strong>复制的是对象地址</strong>，导致了“牵一发而动全身”。<br>&emsp;&emsp;深复制：递归复制了所有层级，复制引用数据类型时会<strong>开辟新的栈空间</strong>，因此两个对象指向了两个不同的地址。 </p>
<h1 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h1><p>这里顺道简单罗列下浅拷贝的方法吧，具体的就不过多介绍了。</p>
<ul>
<li>concat 方法浅拷贝数组。</li>
<li>slice 方法浅拷贝数组。</li>
<li>Object.assign。</li>
<li>… 展开运算符。</li>
<li>手动实现。</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">shallowClone</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> target <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> target <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> cloneTarget <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          cloneTarget<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> cloneTarget<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> target<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h1><h2 id="JSON-parse-JSON-stringify-实现"><a href="#JSON-parse-JSON-stringify-实现" class="headerlink" title="JSON.parse+JSON.stringify 实现"></a>JSON.parse+JSON.stringify 实现</h2><p>&emsp;&emsp;我们实现深拷贝一个对象/数组的时候，除了通过递归去拷贝对象/数组中的每一个引用类型外，使用 <code>JSON.parse() + JSON.stringify()</code> 组合也可以实现深拷贝。不过这存在以下几个缺陷：</p>
<ol>
<li>如果对象里面有 <code>Date</code> 对象，则转换后的结果中，时间将只是字符串的形式。而不是对象。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// string</span>
</code></pre>
<ol start="2">
<li>如果对象里有 <code>RegExp</code>、<code>Error</code>、<code>Set</code>, <code>Map</code> 对象，则拷贝后只会得到空对象。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// [ /(?:)/ ]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// [ {} ]</span>
</code></pre>
<ol start="3">
<li>在对象中遇到 <code>undefined</code>、<code>function</code> 和 <code>symbol</code> 时会自动将其忽略，在数组中则会返回 <code>null</code>。</li>
</ol>
<ul>
<li>在数组中</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> undefined<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// [ [Function], undefined, null, Symbol() ]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// [ null, null, null, null ]</span>
</code></pre>
<ul>
<li>在对象中</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span> 
  c<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  d<span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// { a: [Function: a], b: undefined, c: null, d: Symbol() }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// { c: null }</span>
</code></pre>
<ol start="4">
<li>如果对象里有 <code>NaN</code>、<code>Infinity</code> 和 <code>-Infinity</code>，则拷贝后的结果会变成 <code>null</code>。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">Infinity</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// [ NaN, Infinity, -Infinity ]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// [ null, null, null ]</span>
</code></pre>
<ol start="5">
<li>只能拷贝对象的可枚举的自有属性。如果对象中的某个属性是由构造函数生成的，则深拷贝后会丢弃该属性的 <code>constructor</code>。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>       
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>       
<span class="token punctuation">}</span>      
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"dangosky"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>date<span class="token punctuation">:</span> person<span class="token punctuation">}</span><span class="token punctuation">;</span>      
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// { date: Person { name: 'liai' } }   </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// { date: { name: 'liai' } }</span>
</code></pre>
<p><img src="/2019/04/01/深拷贝实现/1.png" alt></p>
<ol start="6">
<li>如果对象中存在循环引用的情况也无法正确实现深拷贝。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  val<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>target <span class="token operator">=</span> a<span class="token punctuation">;</span>
</code></pre>
<h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p>&emsp;&emsp;再来看看如何用递归逐层拷贝对象属性以实现深拷贝。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>t<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>t<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> undefined<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj1<span class="token punctuation">.</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// { a: 1, arr: [ { t: 1 }, { t: 2 } ], b: null, c: undefined }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// { a: 1, arr: [ { t: 1 }, { t: 20 } ], b: null, c: undefined }</span>
</code></pre>
<p>&emsp;&emsp;通过上述 <code>deepCopy</code> 递归实现深拷贝已经能正常工作了，但也存在几个缺陷：</p>
<ol>
<li>无法拷贝 <code>Date</code>，<code>RegExp</code>，<code>Error</code>、<code>Set</code>, <code>Map</code> 对象。</li>
<li>无法拷贝对象属性中的 <code>constructor</code>。</li>
<li>无法解决循环引用的问题。</li>
</ol>
<h3 id="优化（最终版本）"><a href="#优化（最终版本）" class="headerlink" title="优化（最终版本）"></a>优化（最终版本）</h3><p>下面我们来对 <code>deepCopy</code> 优化一下。</p>
<ol>
<li>解决循环引用的问题。只需要记录拷贝过的对象，并在拷贝一个对象之前先判断下该对象是否已经拷贝过就行了。这里可以借助 Map 来实现。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 标记 obj 已经拷贝过了</span>
  map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>要注意的是，上述代码里使用 <code>WeakMap</code> 而不是 <code>Map</code>。这是因为 <code>Map</code> 上的 <code>key</code> 和 <code>Map</code> 构成了强引用关系，而 <code>WeakMap</code> 则是弱引用。举个例子说明下什么是强引用和弱引用。（详情可见<a href="https://es6.ruanyifeng.com/#docs/set-map#WeakMap" target="_blank" rel="noopener">阮一峰的 ES6 教程</a>）</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> e1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> e2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">[</span>e1<span class="token punctuation">,</span> <span class="token string">'foo 元素'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>e2<span class="token punctuation">,</span> <span class="token string">'bar 元素'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码里 <code>arr</code> 使用到了 <code>e1</code> 和 <code>e2</code> 两个对象。如果是强引用的话，则当不需要使用这两个对象的时候，还需要手动删除 <code>arr</code> 对这两个对象的引用（<code>arr[0] = null; arr[1] = null</code>），否则垃圾回收机制就不会释放 <code>e1</code> 和 <code>e2</code> 占用的内存。但如果是弱引用的话，垃圾回收机制则不将该引用考虑在内。因此只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。</p>
<p>考虑到当前这个场景，如果 <code>Map</code> 引用的对象已经不需要用到了，那么这些对象就可以被回收了。使用 <code>Map</code> 因为是强引用，所以还需要手动去释放 <code>Map</code> 对这些对象的引用。但如果使用 <code>WeakMap</code> 的话则是弱引用，<code>WeakMap</code> 对其使用的对象不会计入引用范围内。（<code>WeakMap</code> 的键名只能是 <code>Object</code>）</p>
<ol start="2">
<li>解决 <code>Date</code>，<code>RegExp</code>，<code>Error</code>、<code>Set</code>, <code>Map</code> 等数据类型的拷贝问题。需要判断要拷贝对象的数据类型，并获取该数据类型的构造器，以此来构造出一个新的数据。对于 <code>Date</code>，<code>RegExp</code>，<code>Error</code> 可以直接利用它们的指构造出一个新的数据，对于 <code>Set</code> 和 <code>Map</code> 就需要再遍历它们的元素并递归拷贝。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 如果 obj 只是基本类型的话，就直接返回</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> obj <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token keyword">const</span> objType <span class="token operator">=</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 根据 obj 的数据类型获取到它的构造函数</span>
  <span class="token keyword">const</span> constructorFn <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 根据构造器创建不同的数据类型，并注意需要传递 obj 为参数。如果是 Date、Error 等数据类型才可以获取到这个值</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">constructorFn</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 标记 obj 已经拷贝过了</span>
  map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>objType <span class="token operator">===</span> <span class="token string">"[object Array]"</span> <span class="token operator">||</span> objType <span class="token operator">===</span> <span class="token string">"[object Object]"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 因为 in 方法会遍历到 obj 的原型连上，所以需要判 key 是不是 obj 自己的属性</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>objType <span class="token operator">===</span> <span class="token string">"[object Map]"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token function">deepCopy</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>objType <span class="token operator">===</span> <span class="token string">"[object Set]"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">deepCopy</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/* Test */</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token string">'c'</span><span class="token punctuation">:</span> <span class="token string">'dangosky'</span><span class="token punctuation">,</span>
  <span class="token string">'d'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">'e'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'dangosky'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">'f'</span><span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>
  <span class="token string">'g'</span><span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token string">'h'</span><span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token punctuation">[</span><span class="token string">'key'</span><span class="token punctuation">,</span> <span class="token string">'size'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token string">'i'</span><span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token string">'j'</span><span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">1245</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token string">'k'</span><span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token string">'l'</span><span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token regex">/dangosky/g</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token string">'m'</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">'n'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 之模拟实现</title>
    <url>/2019/03/28/JS%E4%B9%8B%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h1><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">is</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 修正 +0 === -0 为 true 的 bug</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 运行到 1/x === 1/y 的时候x和y都为0，但是 1/+0 = +Infinity，1/-0 = -Infinity, 两者不相等</span>
    <span class="token keyword">return</span> x <span class="token operator">!==</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">!==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token number">1</span> <span class="token operator">/</span> x <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">/</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 修正 NaN !== NaN 为 false 的 bug</span>
    <span class="token keyword">return</span> x <span class="token operator">!==</span> x <span class="token operator">&amp;&amp;</span> y <span class="token operator">!==</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
<h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p>&emsp;&emsp; 利用函数作为对象方法的时候 this 指向了该对象，所以给目标对象添加要调用的函数并执行，了事后再删除该对象中这个方法就可以了。</p>
<pre class=" language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_call <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 没有传递参数或参数为 null 和 undefined 时默认 this 指向 window</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> context <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    context <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// context 为原始值时 this 指向该原始值的自动包装对象。</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 考虑到对象本身已经有 fn 这个方法，使用 Symbol 作为对象的属性名可以保证不会出现同名的属性</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'fn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 通过 this 获取调用 call 的函数，方法中的 this 指向调用方法的对象</span>
  context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 函数可能有返回值</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 也可使用 eval 方法</span>
  <span class="token comment" spellcheck="true">// let result = eval('context[fn](' + '...arg' + ')');</span>
  <span class="token comment" spellcheck="true">// 最后记得要从对象中删除该方法</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">"window"</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">"local"</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
show<span class="token punctuation">.</span><span class="token function">_call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"dangosky"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><pre class=" language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_apply <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> context <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    context <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'fn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p>&emsp;&emsp; 大致同 apply，但 bind 返回的是一个函数，并且需要考虑到返回的函数作为构造函数的情况。</p>
<pre class=" language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_bind <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 保存 this，表示调用 bind 的函数</span>
  <span class="token keyword">let</span> _this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 考虑到返回的函数作为构造函数时 this 会指向实例，即 this instanceof fn 为 true，此时执行环境为实例自己。</span>
    <span class="token comment" spellcheck="true">// 若返回的函数只是作为普通函数调用，则 this 指向 window，此时执行环境为最初指定的 context</span>
    context <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fn</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token punctuation">:</span> context
    <span class="token keyword">return</span> _this<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arg<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arg1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 若返回的函数作为构造函数时，实例要继承原先绑定函数的属性方法，所以要改变返回的函数的原型。</span>
  <span class="token comment" spellcheck="true">// 因为原型是一个对象，牵一发而动全身所以不能直接赋值</span>
  fn<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 或者使用一个空函数充当中间代理</span>
  <span class="token comment" spellcheck="true">// var empty = function () {};</span>
  <span class="token comment" spellcheck="true">// empty.prototype = this.prototype;</span>
  <span class="token comment" spellcheck="true">// fn.prototype = new empty();</span>
  <span class="token keyword">return</span> fn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">"local"</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span>param1<span class="token punctuation">,</span> param2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>param1 <span class="token operator">+</span> param2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> Fn <span class="token operator">=</span> show<span class="token punctuation">.</span><span class="token function">_bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Fn</span><span class="token punctuation">(</span><span class="token string">"作为的普通函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token string">"作为构造函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h1 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h1><h2 id="迭代-reduce"><a href="#迭代-reduce" class="headerlink" title="迭代 + reduce"></a>迭代 + reduce</h2><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_flat <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>deep <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>deep<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 标志数组是否已经达到一维，防止参数为 Infinity 时炸掉</span>
    <span class="token keyword">let</span> mark <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    arr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>total<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mark <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> total<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>mark<span class="token punctuation">)</span>  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">_flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">_flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_flat <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>deep <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>deep <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
  arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>val<span class="token punctuation">.</span><span class="token function">_flat</span><span class="token punctuation">(</span>deep<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  deep<span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="不考虑展平的深度（一展到底）"><a href="#不考虑展平的深度（一展到底）" class="headerlink" title="不考虑展平的深度（一展到底）"></a>不考虑展平的深度（一展到底）</h2><h3 id="1-join-split"><a href="#1-join-split" class="headerlink" title="1. join + split"></a>1. join + split</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_flat</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过该方法得到的扁平数组元素都是string，得再根据需要去转换</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">_flat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">_flat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="2-递归-reduce"><a href="#2-递归-reduce" class="headerlink" title="2. 递归 + reduce"></a>2. 递归 + reduce</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_flat</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>total<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      total <span class="token operator">=</span> total<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">_flat</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      total<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> total<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="3-循环判断-扩展运算符"><a href="#3-循环判断-扩展运算符" class="headerlink" title="3. 循环判断 + 扩展运算符"></a>3. 循环判断 + 扩展运算符</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_flat</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp; 若只是展平二维数组，则还可以利用 apply 中第二个参数是 (伪) 数组时，每个值都会单独添加即会被展平（仅限于展平深度为 1）。</p>
<pre class=" language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// [ [ 1 ], [ [ 2, 3 ], [ 4 ] ], 5, 6 ]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>concat<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// [ 1, [ 2, 3 ], [ 4 ], 5, 6 ]</span>
</code></pre>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>&emsp;&emsp; 其实 new 的模拟实现很简单，只要理解 new 做的四件事就可以了：</p>
<ol>
<li>先创建一个新对象。</li>
<li>把新对象的原型绑定为构造函数的原型以实现继承。</li>
<li>执行构造函数而且 this 指向新对象。</li>
<li>若构造函数指定返回了一个对象则返回该指定对象否则返回创建的新对象。</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Constructor <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Constructor<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> must be a function`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> Constructor<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> isObject <span class="token operator">=</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> result <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> isFunction <span class="token operator">=</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>isObject <span class="token operator">||</span> isFunction<span class="token punctuation">)</span> <span class="token operator">?</span> result <span class="token punctuation">:</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>getName <span class="token operator">=</span>  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token function">_new</span><span class="token punctuation">(</span>Fn<span class="token punctuation">,</span> <span class="token string">'dangosky'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// dangosky</span>
person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// dangosky</span>
person<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// Hello dangosky</span>
</code></pre>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>&emsp;&emsp; 只要循环去取左值的原型和右值的原型比较即可。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_instanceof</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 左值需要是函数或非 null 的对象，右值需要是函数。</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> left <span class="token operator">===</span> <span class="token string">"function"</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> left <span class="token operator">===</span> <span class="token string">"Object"</span> <span class="token operator">&amp;&amp;</span> left <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> right <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"传入的参数不符合规范。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> _left <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
  <span class="token keyword">let</span> _right <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>_left <span class="token operator">===</span> _right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>_left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    _left <span class="token operator">=</span> _left<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="基础版深拷贝"><a href="#基础版深拷贝" class="headerlink" title="基础版深拷贝"></a>基础版深拷贝</h1><p>&emsp;&emsp; 递归拷贝每一个引用类型数据即可。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>t<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>t<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> undefined<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj1<span class="token punctuation">.</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>t <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// { a: 1, arr: [ { t: 1 }, { t: 2 } ], b: null, c: undefined }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// { a: 1, arr: [ { t: 1 }, { t: 20 } ], b: null, c: undefined }</span>
</code></pre>
<p>&emsp;&emsp;JSON.parse() + JSON.stringify() 实现。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>t<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>t<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> undefined<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<blockquote>
<p>至于这两种方法的不足，请看<a href="http://blog.dangosky.com/2019/04/01/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0/">我的另一篇文章</a> 介绍。</p>
</blockquote>
<h1 id="优化版深拷贝"><a href="#优化版深拷贝" class="headerlink" title="优化版深拷贝"></a>优化版深拷贝</h1><blockquote>
<p>优化方向和思路还是参考<a href="http://blog.dangosky.com/2019/04/01/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0/#toc-heading-6">我的另一篇文章</a> 介绍。</p>
</blockquote>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 如果 obj 只是基本类型的话，就直接返回</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> obj <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
  <span class="token keyword">const</span> objType <span class="token operator">=</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 根据 obj 的数据类型获取到它的构造函数</span>
  <span class="token keyword">const</span> constructorFn <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 根据构造器创建不同的数据类型，并注意需要传递 obj 为参数。如果是 Date、Error 等数据类型才可以获取到这个值</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">constructorFn</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 标记 obj 已经拷贝过了</span>
  map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>objType <span class="token operator">===</span> <span class="token string">"[object Array]"</span> <span class="token operator">||</span> objType <span class="token operator">===</span> <span class="token string">"[object Object]"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 因为 in 方法会遍历到 obj 的原型连上，所以需要判 key 是不是 obj 自己的属性</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>objType <span class="token operator">===</span> <span class="token string">"[object Map]"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token function">deepCopy</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>objType <span class="token operator">===</span> <span class="token string">"[object Set]"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">deepCopy</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="记忆函数"><a href="#记忆函数" class="headerlink" title="记忆函数"></a>记忆函数</h1><p>&emsp;&emsp; 记忆函数的功能在于缓存先前操作得到的结果，避免对同一个值进行重复计算浪费时间，比如斐波那契数列和阶乘等运算，算是用空间换时间吧。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 记忆函数</span>
<span class="token keyword">function</span> <span class="token function">memoize</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> recur <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 若记忆数组中没有记录则递归求值再保存</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> res<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>recur<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> recur<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 斐波那契数列</span>
<span class="token keyword">function</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fn</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> memoizeFib <span class="token operator">=</span> <span class="token function">memoize</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> fibonacci<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">memoizeFib</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 阶乘</span>
<span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">fn</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> memoizeFac <span class="token operator">=</span> <span class="token function">memoize</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> factorial<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">memoizeFac</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h1 id="实现数组的-map-方法"><a href="#实现数组的-map-方法" class="headerlink" title="实现数组的 map 方法"></a>实现数组的 map 方法</h1><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_map <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> context <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">this</span> <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Cannot read property 'map' of null or undefined"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">"[object Function]"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>fn <span class="token operator">+</span> <span class="token string">' is not a function'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> index<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> val<span class="token punctuation">,</span> index<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="实现数组的-reduce-方法"><a href="#实现数组的-reduce-方法" class="headerlink" title="实现数组的 reduce 方法"></a>实现数组的 reduce 方法</h1><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_reduce <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> initialValue<span class="token punctuation">,</span> context <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">this</span> <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Cannot read property 'reduce' of null or undefined"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">"[object Function]"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>fn <span class="token operator">+</span> <span class="token string">' is not a function'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 如果有传初始值的话，则结果值初始化为该初始值；否则初始化为数组第一个元素</span>
  <span class="token keyword">const</span> hasInitialValue <span class="token operator">=</span> initialValue <span class="token operator">!==</span> undefined<span class="token punctuation">;</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> hasInitialValue <span class="token operator">?</span> initialValue <span class="token punctuation">:</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 如果 res 已经被初始化为数组第一个元素，则不需要对第一个数组元素进行计算了</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasInitialValue <span class="token operator">&amp;&amp;</span> i <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    res <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> res<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="实现数组的-filter-方法"><a href="#实现数组的-filter-方法" class="headerlink" title="实现数组的 filter 方法"></a>实现数组的 filter 方法</h1><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_filter <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> context <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">this</span> <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Cannot read property 'reduce' of null or undefined"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">"[object Function]"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>fn <span class="token operator">+</span> <span class="token string">' is not a function'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> mark <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="实现数组的-push-方法"><a href="#实现数组的-push-方法" class="headerlink" title="实现数组的 push 方法"></a>实现数组的 push 方法</h1><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_push <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> originLen <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">let</span> addLength <span class="token operator">=</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>addLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arr<span class="token punctuation">[</span>originLen <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 考虑到对象可能也会调用 push 方法，所以得手动修改 length 属性。可见下例</span>
  arr<span class="token punctuation">.</span>length <span class="token operator">=</span> originLen <span class="token operator">+</span> addLength<span class="token punctuation">;</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/* test */</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  length<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  addElem<span class="token punctuation">:</span> <span class="token keyword">function</span> addElem <span class="token punctuation">(</span>elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>push<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">addElem</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">addElem</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h1 id="实现数组的-pop-方法"><a href="#实现数组的-pop-方法" class="headerlink" title="实现数组的 pop 方法"></a>实现数组的 pop 方法</h1><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_pop <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 如果不包含length属性或length属性不能被转成一个数值，会将length置为0，并返回undefined（参考自MDN）</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">===</span> undefined <span class="token operator">||</span> <span class="token keyword">typeof</span> len <span class="token operator">!==</span> <span class="token string">'Number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arr<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> undefined<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  len<span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> arr<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> arr<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
  arr<span class="token punctuation">.</span>length <span class="token operator">=</span> len<span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="实现数组的-splice-方法"><a href="#实现数组的-splice-方法" class="headerlink" title="实现数组的 splice 方法"></a>实现数组的 splice 方法</h1><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_splice <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> deleteSum<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 处理开始索引为负数或越界的情况</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    start <span class="token operator">=</span> start <span class="token operator">+</span> len <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> start <span class="token operator">+</span> len <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">></span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    start <span class="token operator">=</span> len<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 处理删除个数异常的情况。如果没有指定删除个数或其大于数组剩下的元素，则调整为删除剩下的所有元素</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>deleteSum <span class="token operator">===</span> undefined <span class="token operator">||</span> deleteSum <span class="token operator">></span> len <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    deleteSum <span class="token operator">=</span> len <span class="token operator">-</span> start<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>deleteSum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    deleteSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 先将剩下的数组元素排到要新增的数组元素后面，这样就可以直接替换而不必去区分是剩下的数组元素亦或是要新增的了</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>start<span class="token operator">+</span>deleteSum<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arg<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 表示已经删除的个数</span>
  <span class="token keyword">let</span> arrIndex <span class="token operator">=</span> start<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 循环原数组的索引</span>
  <span class="token keyword">let</span> argIndex<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 循环要替换的数组的索引</span>
  <span class="token comment" spellcheck="true">// 删除个数已经达到了并且要替换的数组已经全部替换完了才退出循环</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> deleteSum <span class="token operator">||</span> argIndex <span class="token operator">&lt;</span> arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> deleteSum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>arrIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      sum<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    arr<span class="token punctuation">[</span>arrIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arg<span class="token punctuation">[</span>argIndex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 为避免因删除的个数和新增的个数不相等时，进行数组替换会出现undefined，所以最后还需要修改数组长度</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arr<span class="token punctuation">.</span>length <span class="token operator">=</span> len <span class="token operator">-</span> deleteSum<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    arr<span class="token punctuation">.</span>length <span class="token operator">=</span> start <span class="token operator">+</span> arg<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event 事件"></a>Event 事件</h1><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">EventEmitter</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 以事件名为键，监听函数数组为值</span>
  <span class="token punctuation">}</span>

  <span class="token function">emit</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> handles <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handles <span class="token operator">&amp;&amp;</span> handles<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      handles<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">addListener</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> handles <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    handles<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> handles<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">removeListener</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> handles <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> handles<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> item <span class="token operator">!==</span> fn<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">removeAllListener</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/* test code */</span>
<span class="token keyword">const</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

event<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> fn1<span class="token punctuation">)</span><span class="token punctuation">;</span>
event<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> fn2<span class="token punctuation">)</span><span class="token punctuation">;</span>
event<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token string">'DangoSky'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h1 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h1><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Publish</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 数组元素的格式为：{id, callbacks: {cb1, cb2}}</span>
    <span class="token comment" spellcheck="true">// 订阅者的 callback 数据格式为对象，是为了使订阅者有多个订阅函数，并且在取消订阅时可以更好地区分订阅函数。</span>
    <span class="token comment" spellcheck="true">// 如果使用数组的话需要用数组下标这样语义不强</span>
  <span class="token punctuation">}</span>
  <span class="token function">notice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>callbacks<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        fn <span class="token operator">&amp;&amp;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">add</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">remove</span><span class="token punctuation">(</span>sub<span class="token punctuation">,</span> fnName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 不传第二个参数(要移除的订阅者的某个订阅函数名)的话，就是移除整个订阅者</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fnName <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> item<span class="token punctuation">.</span>id <span class="token operator">!==</span> sub<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 只是移除订阅者的某个回调函数</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>id <span class="token operator">===</span> sub<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> item<span class="token punctuation">.</span>callbacks<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> fnName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              item<span class="token punctuation">.</span>callbacks<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 对于发布订阅模式，可能是先发布后订阅。此类业务场景应用比如 QQ 的离线模式，就是先将信息存储起来（先发布），等到订阅者订阅，就立即将信息发送给订阅者，所以当切换到登录模式时（后订阅）就能马上接受到之前的消息了</span>
</code></pre>
<h1 id="基础版-Promise"><a href="#基础版-Promise" class="headerlink" title="基础版 Promise"></a>基础版 Promise</h1><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> PEDDING <span class="token operator">=</span> <span class="token string">'pedding'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> RESOLVED <span class="token operator">=</span> <span class="token string">'resolved'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> REJECTED <span class="token operator">=</span> <span class="token string">'rejected'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Promise</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> PEDDING<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> resolve <span class="token operator">=</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PEDDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> res<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> RESOLVED<span class="token punctuation">;</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>cb <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          cb<span class="token punctuation">.</span><span class="token function">onResolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> reject <span class="token operator">=</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PEDDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> err<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> REJECTED<span class="token punctuation">;</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>cb <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          cb<span class="token punctuation">.</span><span class="token function">onReject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span> 
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">fn</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>then <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>onResolve<span class="token punctuation">,</span> onReject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onResolve <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    onResolve <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onReject <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    onReject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PEDDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        onResolve<span class="token punctuation">:</span> val <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">onResolve</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        onReject<span class="token punctuation">:</span> val <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">onReject</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> RESOLVED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> REJECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> err <span class="token operator">=</span> <span class="token function">onReject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>基础版 Promise 的不足:</p>
<ol>
<li>没有 try…catch，无法捕获错误。</li>
<li>没有对 then 的返回值进行判断，可能会返回一个 promise，并需要对这个返回的 promise 做合规校验并解析它的结果。</li>
<li>没有对重复的代码进行封装。</li>
<li>没有实现静态 resolve、reject 方法，以及 all、race 方法。</li>
</ol>
<h1 id="完善版-Promise"><a href="#完善版-Promise" class="headerlink" title="完善版 Promise"></a>完善版 Promise</h1><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> PEDDING <span class="token operator">=</span> <span class="token string">'pedding'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> RESOLVED <span class="token operator">=</span> <span class="token string">'resolved'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> REJECTED <span class="token operator">=</span> <span class="token string">'rejected'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Promise</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> fn <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'fn is not a function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> PEDDING<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// resolve 或 reject 后的回调函数</span>

  <span class="token keyword">const</span> resolve <span class="token operator">=</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PEDDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> RESOLVED<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> res<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 模仿异步执行 then 决断后的回调函数，对于 resolve 或 reject 后的代码会继续同步执行</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          item<span class="token punctuation">.</span><span class="token function">onResolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> reject <span class="token operator">=</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PEDDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> REJECTED<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> err<span class="token punctuation">;</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          item<span class="token punctuation">.</span><span class="token function">onReject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">fn</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 决断 then 返回的 promise。对捕获错误、判断决断后回调函数返回的 promise 是否合规、解析该 promise 的值，这三种情况进行封装</span>
Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>parse <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>selfPromise<span class="token punctuation">,</span> result<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// then 中返回的 promise 不能和 resolve/reject 回调函数中返回的 promise 一样</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>selfPromise <span class="token operator">===</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'chaining cycle detected'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 如果 resolve/reject 回调函数中返回的是 promise，则解析该 promise 的值返回给下一个 then</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Promise<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>then <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>onResolve<span class="token punctuation">,</span> onReject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 如果没有传 onResolve 或 onReject 函数的话，则默认返回当前 promise 的值，实现值穿透</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onResolve <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    onResolve <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onReject <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    onReject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> selfPromise <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 使用箭头函数绑定 this 为外层的 this 指向</span>
    <span class="token comment" spellcheck="true">// 当前 promise 还在 pedding，先放入 callbacks 中等状态变化后再调用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> PEDDING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        onResolve<span class="token punctuation">:</span> val <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>selfPromise<span class="token punctuation">,</span> <span class="token function">onResolve</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        onReject<span class="token punctuation">:</span> err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>selfPromise<span class="token punctuation">,</span> <span class="token function">onReject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> RESOLVED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 模仿 then 的异步操作</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>selfPromise<span class="token punctuation">,</span> <span class="token function">onResolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> REJECTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>selfPromise<span class="token punctuation">,</span> <span class="token function">onReject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> selfPromise<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 将 value 转化成 promise，默认为 resolve 状态</span>
Promise<span class="token punctuation">.</span>resolve <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 如果 value 本身已经是 promise 了，则解析它的值来决断，否则直接 resolve</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 将 value 转化成 promise，默认为 reject 状态</span>
Promise<span class="token punctuation">.</span>reject <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 返回一个 promise，所有 promise 都 resolve 后才 resolve，有一个 reject 则该 promise 会被 reject</span>
Promise<span class="token punctuation">.</span>all <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> resolvePromises <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    promises<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      item<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resolvePromises<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 等到所有 promise 都 resolve 后才能 resolve</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolvePromises<span class="token punctuation">.</span>length <span class="token operator">===</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span>resolvePromises<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 返回一个 promise，其状态跟第一个决断的 promise 相同</span>
Promise<span class="token punctuation">.</span>race <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 只要一个 promise 决断了就可以了，因为状态一经改变就不会再变，所以之后即使还有其他 promise 决断了也不会有影响</span>
    promises<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      item<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_async</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 返回一个函数，使得 gen 可以接受参数</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// async/await 的返回值是一个 Promise</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>  
      <span class="token keyword">function</span> <span class="token function">_next</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          res <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果遍历器已经遍历结束则直接 resolve 掉 Promise，否则递归调用 _next 以遍历完</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// yield 后面可以跟 Promise 和基本数据类型，如果为 Promise 的话还得去获取它的结果，所以统一转化为 Promise 方便去获取 res.value</span>
        Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          <span class="token function">_next</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// 抛出错误以便被外层的 try-catch 捕获</span>
          g<span class="token punctuation">.</span><span class="token keyword">throw</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token function">_next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/* test */</span>
<span class="token keyword">const</span> getData <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'My name is '</span> <span class="token operator">+</span> name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 模拟异步获取数据</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> run <span class="token operator">=</span> <span class="token function">_async</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token operator">*</span> <span class="token punctuation">(</span>lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">'Jerry '</span> <span class="token operator">+</span> lastName<span class="token punctuation">)</span>
  <span class="token keyword">const</span> data2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">'Lucy '</span> <span class="token operator">+</span> lastName<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>data1<span class="token punctuation">,</span> data2<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">run</span><span class="token punctuation">(</span><span class="token string">'Green'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// [ 'My name is Jerry Green', 'My name is Lucy Green' ]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>排序后循环判断当前的数组元素值是否等于上一个数组元素，是的话则用 <code>splice</code> 删除。该方法会影响到原数组。并且如果数组中包含了字符串的话，该方法无法做到去重，因为排序后，两个相同的数值之间可能会含有它们的字符串形式，导致判断失效。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      i<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">/* test */</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'33'</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="filter-indexOf"><a href="#filter-indexOf" class="headerlink" title="filter + indexOf"></a>filter + indexOf</h2><p>使用 <code>indexOf</code> 和当前的数组下标进行比较，可以得到当前的数组元素是否是重复出现。该方法不需要排序，也不会影响到原数组。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">===</span> index<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 去重</span>
    <span class="token comment" spellcheck="true">// return arr.indexOf(parseInt(val)) === index;       // 可以先使用 parseInt 解析来转化字符串</span>
    <span class="token comment" spellcheck="true">// return arr.indexOf(val) === arr.lastIndexOf(val);   // 用于找数组中没有重复的数</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// return Array.from(new Set(arr));</span>
<span class="token punctuation">}</span>
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2019/03/23/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="闭包的原理"><a href="#闭包的原理" class="headerlink" title="闭包的原理"></a>闭包的原理</h1><p>&emsp;&emsp;说闭包之前，需要先说一下变量作用域。在JS中作用域分为全局作用域和局部作用域，决定了变量和函数的可见范围。定义在函数内部的变量一般情况下只对当前所在函数可见，在函数外部是无法读取到函数内部的变量的。不过 JavaScript 是门神奇的语言，若是在函数内没有声明一个变量便对其赋值的话，实际上会默认将该变量声明为全局变量。而作用域链，是指在函数内部查找某一个变量的时候，先会在当前函数内寻找查找，若是找不到则会循着它的父级外部函数一直向上，直到找到该值或是到全局环境为止，也就是说外部父级函数和全局变量对某一函数而言都是可见的，这就形成了一条作用域链。而且在 Javascript 中，函数是一等公民，即函数可以被赋值，可以作为参数传递，也可以作为函数结果被 return 回去。根据这几点，我们就可以设置出一种方法，使得在函数外部依旧可以使用到函数内部的变量（这种需求也还是很常见的），而这种方法，就是闭包。</p>
<p>&emsp;&emsp;我对闭包的理解是，<strong>在一个函数中使用了一个内部函数，而且在这个内部函数中使用到了外部函数的变量</strong>。在一般情况下，函数一旦执行完毕其内部的变量就会被销毁无法再被访问到，但通过返回一个函数（或者让一个全局变量接受这个函数，所以并不是只有返回函数才算是闭包）就可以使得该函数作用域链上可见的变量在函数外依旧可见，而我们只要在函数外使用一个变量来接受该返回结果就可以延长它们的生命周期了。这也就是闭包的两个作用： </p>
<ol>
<li><p><strong>可以在函数外部读取到函数内部的变量</strong>。</p>
</li>
<li><p><strong>让这些变量的值始终保持在内存中</strong>。因为闭包被赋予一个全局变量后始终在内存中（对于全局变量，垃圾回收机制不知道什么时候应该回收它们），而闭包的存在依赖于其外部函数，所以该外部函数即使在调用结束后也不会被垃圾回收机制回收，始终都保留在内存中。</p>
</li>
</ol>
<p>&emsp;&emsp;因此使用闭包很消耗内存，不利用于性能优化，糟糕时还可能会造成内存泄漏。所以要慎用！先举个栗子吧。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> add5 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> add10 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add5</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 7</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add10</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 12</span>
<span class="token comment" spellcheck="true">// 释放对闭包的引用</span>
add5 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
add10 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;在 add 的内部函数里使用到了外部变量 x，x 的状态被保留了会一直存在内存中直至闭包被销毁。<br>&emsp;&emsp;再看看下面这个栗子：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"global"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">"local"</span><span class="token punctuation">,</span>
  getName<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// global</span>
</code></pre>
<p>&emsp;&emsp;当我们调用<code>obj.getName()()</code>的时候，这时候函数其实是在全局作用域中进行的，this 自然就指向了全局对象。我们可以在 getName 中绑定 this 指向来避免这个问题， <code>var _this = this</code> 即可。或者直接使用箭头函数绑定 this，箭头函数中的 this 固定指向了函数被定义时的函数上下文环境。</p>
<h1 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h1><h2 id="封装对象的私有属性和私有方法。"><a href="#封装对象的私有属性和私有方法。" class="headerlink" title="封装对象的私有属性和私有方法。"></a>封装对象的私有属性和私有方法。</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> num <span class="token operator">=</span> initial <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> num<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">setNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    num<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    getNum<span class="token punctuation">:</span> getNum<span class="token punctuation">,</span>
    setNum<span class="token punctuation">:</span> setNum
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span><span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 10</span>
counter<span class="token punctuation">.</span><span class="token function">setNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">.</span><span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 11</span>
</code></pre>
<p>&emsp;&emsp;通过闭包我们可以模仿 C++ 里面类的私有成员，使其在函数外部只能通过函数返回的对象来操纵，保持数据的私有性。而且每一次调用都是在前面一次调用的基础上进行的，变量的内容会被保留。</p>
<h2 id="绑定循环变量"><a href="#绑定循环变量" class="headerlink" title="绑定循环变量"></a>绑定循环变量</h2><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>&emsp;&emsp;上面的代码中我们本来想着会依次打印 1、2、3、4、5 的，但实际上它打印出来的是 5 个 6。这是因为当开始执行定时器中的代码时，此时 for 循环已经运行完毕了，循环变量 i 也变成了 6。所以定时器的回调函数再去取 i 的值就只能取到当前的值 6 了。对此解决办法大致有以下几种：</p>
<ul>
<li><p>使用 let 代替 var 声明 循环变量 i。原理是利用 let 在每一趟循环中都会生成一个块级作用域，这样执行定时器的回调函数时取到的 i 值就是这个块级作用域中相应的 i 值了。</p>
</li>
<li><p>给定时器传入第三个参数, 作为 timer 函数的函数参数。</p>
</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>使用闭包，原理是利用闭包可以读取到外部函数的变量并将其保留在内存中，使 i 的值可以被记忆住。</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>我还看到一种方法，是使用 forEach 来循环的，不过我也不知道原理是啥，暂且贴一下代码。</p>
</blockquote>
<pre class=" language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>val <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<h1 id="一道有关闭包的题目："><a href="#一道有关闭包的题目：" class="headerlink" title="一道有关闭包的题目："></a>一道有关闭包的题目：</h1><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>o<span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    fun<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">fun</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// undefined</span>
a<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 0      </span>
a<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 0</span>
a<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 0</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// undefined, 0, 1, 2</span>

<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// undefined, 0</span>
c<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1</span>
c<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1</span>
</code></pre>
<p>&emsp;&emsp;我第一次做这道题的时候做错了，逻辑没理清过来，现在再说说思路。</p>
<p>&emsp;&emsp;对于变量 a 部分。首先使调用了 fun 函数，打印 形参 o 的时候因为只传进去了一个实参，所以 o 为 undefined，接着返回了一个对象并赋值给变量 a。<code>a.fun(1)</code> 是调用 a 对象里的 fun 方法，返回执行外层 fun 函数的结果。因为运用了闭包，所以可以读取到之前调用外层 fun 函数时的形参 n（即 0），此时 1 和 0 分别作为实参 m、n 一起传递给了外层 fun 函数后，先是打印出形参 o 也就是 0，接着再返回一个对象。但由于没有用一个变量接受这个返回的对象也不是链式调用，所以返回的结果是没用了的，所以后面的<code>a.fun(2)</code>和<code>a.fun(3)</code>的运行过程是和<code>a.fun(1)</code>一样的，只是参数 m 变了而已，要注意的是参数 n 还是用的原来变量 a 保存好的 0。</p>
<p>&emsp;&emsp;对于变量 b 部分。首先是调用了 fun 函数，依旧打印出了 undefined 后返回一个对象。接着在返回的对象基础上调用<code>fun(1)</code>，也还是打印出形参 0 返回一个对象，到此处执行的操作和之前的 a 一样的。不同的是，因为这里是链式调用，<code>fun(2)</code>的执行是在<code>fun(1)</code>返回的对象的基础上进行的，也就是参数 n 变成了之前<code>fun(1)</code>保留下来的 1 了，所以这时候再打印 0 就打印出了 1 。<code>fun(3)</code>也还是在<code>fun(2)</code>的基础上操作，所以打印出的是 2。</p>
<p>&emsp;&emsp;对于变量 c 部分。<code>fun(1)</code>是在<code>fun(0)</code>的基础上调用后才把返回的对象赋值给变量 c 的，所以变量 c 保存的参数 n 是 1 而不是 0，因此<code>fun(2)</code>打印的也自然是 1 了，而后的<code>fun(3)</code>依旧是在变量 c 的基础上调用，所以打印出来的也是 1。</p>
<p>&emsp;&emsp;其实只要好好分析它们前后的调用关系，这道题也不会像看上去那么复杂的。</p>
<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><p>&emsp;&emsp;什么是函数柯里化？其实可以简单地理解为：只传递给函数一部分参数来调用它，再返回一个函数去处理剩下的参数。我们先看个简单的栗子就大概知道了。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 3</span>
</code></pre>
<p>&emsp;&emsp;在上面这个栗子中我们是先传递一个参数给函数 add，并利用闭包会保存作用域链上的变量的特性来保存这个参数，再返回一个函数来接受第二个参数，最后再一起进行计算并返回结果。</p>
<p>&emsp;&emsp;我们通过一道题目来加深对函数柯里化的理解。</p>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 编写一个 add 函数使下面这几个式子都能输出正确结果。</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
</code></pre>
<p>&emsp;&emsp;我们可以像上面那个栗子一样，通过嵌套地返回一个函数来实现，不过麻烦地是需要根据每次调用形参数目的不同来判断是否需要链式调用。这种方法比较繁琐而且通用性不高，所以我们就不使用这种方法了。我试了其他三种方法，不过都有些缺陷（没办法啊，搞了大半天还是没有得出一个完美的方法Orz）。</p>
<ul>
<li>方法一</li>
</ul>
<p>&emsp;&emsp;把每一次链式调用的参数拼成一个数组，再在最后一次链式调用时通过改写好了的 valueOf 方法 或 toString 方法来返回我们想要的结果，这里利用的是对象打印或类型转化时会根据不同的情况调用 valueOf 和 toString 方法，具体请看我<a href="http://blog.dangosky.com/2019/02/28/zhong-de-lei-xing-zhuan-huan/#toc-heading-2">另一篇文章</a>（如果不改写 valueOf 或 toString 则默认返回函数本身）。</p>
<p>&emsp;&emsp;缺陷在于，这种方法在 Chrome 中会在每一个结果之前打印一个 f 字符（表示函数），而且在 Firefox 中不会生效直接就打印成了函数。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 收集参数，返回 fn 链式调用</span>
    args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> fn<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  fn<span class="token punctuation">.</span>valueOf <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> args<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>total<span class="token punctuation">,</span> curVal<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> total <span class="token operator">+</span> curVal<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> fn<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;补充：可以使用<code>Number()</code>强制类型转换来解决这个问题，如<code>Number(add(1,2,3,4))</code>。</p>
<ul>
<li>方法二</li>
</ul>
<p>&emsp;&emsp;通过判断形参数目来决定是递归调用自身还是直接调用 fn 函数，而且每一次递归调用都把参数拼凑到一个数组中去，在最后调用 fn 的时候再一起进行相加求值。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> recur <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> recur<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> recur<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> add <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> args<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>total<span class="token punctuation">,</span> cur<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> total <span class="token operator">+</span> cur<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 40</span>
</code></pre>
<p>&emsp;&emsp;缺陷在于，每一次使用都需要额外再调用一次告诉函数该调用 fn 了，否则返回的结果是函数本身。并且因为 args 是存在于 curry 函数中的，返回 recur 函数后 args 被保存了下来，而之后每次使用 add 都是在上一次的 args 的基础上进行的，所以会有一个 args 的累加问题。想要让每一次调用 add 函数都是独立的，只能把累加操作直接合并到柯里化函数中去了（目前我只想到这种办法而已）。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> recur <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> args<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>total<span class="token punctuation">,</span> cur<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> total <span class="token operator">+</span> cur<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arg<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> recur<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> recur<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>方法三</li>
</ul>
<p>&emsp;&emsp;这个方法是对方法二的优化，通过给 curry 函数传递一个 length 参数，根据已收集到的参数数目和 length 进行比较，从而决定是递归调用自身还是直接调用 fn 函数。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">currying</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> currying<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arg<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arg1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> add <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arg<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 要进行相加的个数</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 10</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 10</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 10</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// length 大于实际进行相加的个数，所以会打印函数本身</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// length 小于实际进行相加的个数，而且调用fn后还有链式调用，所以报错：Uncaught TypeError: add(...) is not a function</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// length 小于实际进行相加的个数，但调用fn后没有链式调用，所以可以成功输出结果15</span>
</code></pre>
<p>&emsp;&emsp;缺陷在于，需要事先知道要进行相加的个数并设置为参数传递给 curry。若是length 大于实际进行相加的个数，则打印函数本身。若是小于或等于则视链式调用的次数而定（若调用 fn 后还存在链式调用则会报错，否则就能成功输出结果）。</p>
<p>&emsp;&emsp;需要说明的是，返回的 currying 函数里如果<code>arg.length &lt; length</code>的话，需要再返回一个匿名函数来调用 currying。如果直接连接 arg 和 arg1 并返回 currying 的话，第一次调用 add 函数后的 arg.length 会保留到下一次调用 add 函数上，导致第二次调用 add 函数出错。读者可以查看<a href="https://privatebin.net/?7772ae23cd77c7bc#U/vFaqY8qYXdGjbNcM58Y1h5wJd3jL/sfgM8CawKAOE=" target="_blank" rel="noopener">这里的代码</a>进行查看，对比两种写法。</p>
<p>&emsp;&emsp;这三种方法刚看可能有些难理解，但其实只要理解了就可以发现它们的主要原理都是：<strong>利用闭包的特性将所有的参数都集中到最后返回的函数里进行计算并返回结果</strong>！读者可以代入一个栗子去理清它的执行顺序，应该就能够明白这三种方法了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之原型和原型链</title>
    <url>/2019/03/20/JS%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在JavaScript之中并没有 C++ 和 Java 中类的概念，JavaScript的继承是基于原型的，ES6引入的 class 也只是一种语法糖而已，JS通过函数来模拟实现类。</p>
<p>&emsp;&emsp;JavaScript有三种方法可以建立一个对象：</p>
<ol>
<li>直接使用字面量创建。如<code>let obj = {}</code>。</li>
<li>使用构造函数 new 一个实例。</li>
<li>使用create方法，如<code>let obj = Object.create({})</code>。</li>
</ol>
<h1 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h1><p>&emsp;&emsp;JavaScript的原型里，最重要的两个属性就是<code>prototype</code>和<code>__proto__</code>（注意左右各是两个下划线）。首先先说 __proto__，所有的数据类型都有 __proto__ 和 constructor（除了 null 和 undefined）两个属性，前者指向了它们的原型。比如<code>&quot;abc&quot;.__proto__</code>会返回一个 String 对象，其中包含了字符串的各种方法，<code>true.__proto__</code>则返回一个 Boolean 对象。对象的每一个数据都继承了它们原型上的方法，可以化为己用，比如每一个字符串字面量都可以使用 concat，slice 等各种方法。当我们查找一个对象的某个属性时，会先在该对象本身的属性上查找，如果查找不到的话会往它的原型上去查找，如果它的原型上还是没有，则会继续往它的原型的原型上去查找，依次类推上去，直到找到该属性或是达到了原型链的源头即 null 为止（我更喜欢说是源头，而不是尽头），若是达到原型链源头了还没能找到该属性则会返回 undefined。因此我们也能够通过在一个对象的原型增加某一个属性或方法，使得该对象也能够使用到它，包括基本数据类型，如下面这个栗子。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Number<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// "hello world"</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// "hello world"</span>
</code></pre>
<p>&emsp;&emsp;虽然 a 只是一个普通的数字，但通过给它的原型<code>Number.prototype</code>增加了一个 num 属性，所以 a 也继承了这个 num 属性，包括其他也是以 Number.prototype 为原型的数据也是如此。除了直接使用 __proto__ 外，我们还可以使用<code>Object.getPrototypeOf()</code>来获取一个对象的属性，使用<code>Object.setPrototypeOf()</code>来设置一个对象的原型。（听说 __proto__ 操作比较慢而且还耗性能？这点我是从其他博客看到的，尚未经过实验。不过即使不考虑性能，单从兼容性上考虑也不推荐使用 __proto__，毕竟 __proto__ 只是浏览器厂商自己实现的内部属性。）</p>
<h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p>&emsp;&emsp;至于<code>prototype</code>属性，需要明确区分的一点是，prototype 只是<strong>存在于函数上的，并且这个函数要能够使用 new 运算符来生成实例</strong>（相当于构造函数），像 Math.round() 这样的函数就没有 prototype 属性。当我们使用构造函数创建一个实例时，实例的 <code>__proto__</code> 属性就是指向了其构造函数的 <code>prototype</code>属性（即该实例的原型）。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>        
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Fn<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Function<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 通过函数字面量定义的函数的 __proto__ 属性都指向了 Function.prototype。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 注意和上式进行区分，构造函数继承自Function，其原型继承自 Object.prototype，因为 Fn.prototype 是一个对象，所以原型是 Object.prototype。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 通过对象字面量定义的对象的 __proto__ 属性都指向了Object.prototype。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Object函数的原型的 __proto__ 属性指向null。</span>
</code></pre>
<p>&emsp;&emsp;我们知道，普通函数实际上是Function的实例，即普通函数继承于<code>Function.prototype</code>，而<strong>Object、Number、String、Function 等构造函数也是继承自<code>Function.prototype</code></strong>的。<code>Function.prototype</code>继承于<code>Object.prototype</code>，<code>Object.prototype</code>继承自 null，而null是原型链的源头。一条链下来就是<code>Array/String/Number/Function -&gt; Function.prototype -&gt; Object.prototype -&gt; null</code>。</p>
<pre class=" language-js"><code class="language-js">函数名<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Function<span class="token punctuation">.</span>prototype  
Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Object<span class="token punctuation">.</span>prototype
Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span>  

Number<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Function<span class="token punctuation">.</span>prototype  
String<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Function<span class="token punctuation">.</span>prototype  
Boolean<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Function<span class="token punctuation">.</span>prototype  
Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Function<span class="token punctuation">.</span>prototype  
Function<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Function<span class="token punctuation">.</span>prototype    
<span class="token comment" spellcheck="true">// 上述几个式子都为true</span>
</code></pre>
<h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>&emsp;&emsp;此外还有一个<code>constructor</code>属性，存在于所有数据类型上（除了 null 和 undefined 外），指向了它们的构造函数。比如</p>
<pre class=" language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor   <span class="token comment" spellcheck="true">// ƒ Boolean() { [native code] }</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor      <span class="token comment" spellcheck="true">// ƒ Number() { [native code] }</span>

<span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Fn     <span class="token comment" spellcheck="true">// true</span>
</code></pre>
<p>&emsp;&emsp;原型上的 constructor 属性也指向了构造函数，即该函数本身，<code>Fn.prototype.constructor === Fn)  // true</code>。不过说 constructor 属性，存在于所有数据类型上不是很严谨， 并不是那些基本数据类型上自己有 constructor 属性，我们对其使用 constructor 属性时，实际是到它们的原型上获取到 constructor 属性的。<br>&emsp;&emsp;我们用一张关系图来总结 <code>prototype</code> 、 <code>__proto__</code> 和 <code>constructor</code> 的关系。</p>
<p><img src="/2019/03/20/JS之原型和原型链/1.jpg" alt></p>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p>&emsp;&emsp;我们可以使用<code>instanceof</code>来判断一个对象的原型链上是否存在一个构造函数的原型。如 A instanceof B，即判断  B.prototype 是否在对象 A 的原型链上。在判定过程中会循着 A 的原型链上去查找，只要该对象出现在其原型链上的任一位置，就会判定为 true。当然也可以借此判断某一个数据的数据类型，不过这还是会有些不足，虽然判断一个数据是否为数组时<code>[] instanceof Array</code>会返回 true，但判定<code>[] instanceof Object</code>也还是会返回 true，所以判定数据类型的时候还是采用<code>Object.prototype.toString.call()</code>的好。现在我们再来看下面的几个等式。</p>
<pre class=" language-js"><code class="language-js">Object <span class="token keyword">instanceof</span> <span class="token class-name">Function</span>
Function <span class="token keyword">instanceof</span> <span class="token class-name">Function</span> 
Function <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> 
Object <span class="token keyword">instanceof</span> <span class="token class-name">Object</span>
<span class="token comment" spellcheck="true">// 上述几个式子都为true</span>
</code></pre>
<p>&emsp;&emsp;前两个式子之所以会返回 true，是因为 Object 和 Function 等构造函数都继承自 <code>Function.prototype</code>，所以所有的函数都能通过原型链找到创建它们的 Function 构造函数，自然也就返回了 true。而 <code>Function.prototype</code>是一个对象，它的构造函数是 Object，所以在对 Function、Object 等的原型链上寻找时会找到它们的构造函数 Object，自然也就返回了 true。</p>
<p>&emsp;&emsp;我们可以根据 instanceof 的工作原理来模拟实现 instanceof。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_instanceof</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 左值需要是函数或非null的对象，右值需要是函数。</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> left <span class="token operator">===</span> <span class="token string">"function"</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> left <span class="token operator">===</span> <span class="token string">"Object"</span> <span class="token operator">&amp;&amp;</span> left <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> right <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"传入的参数不符合规范。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> _left <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
  <span class="token keyword">let</span> _right <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>_left <span class="token operator">===</span> _right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>_left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    _left <span class="token operator">=</span> _left<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>instanceof</code> 的工作原理是调用对象内置的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance" target="_blank" rel="noopener">Symbol.hasInstance</a> 方法，我们可以通过改写 <code>Symbol.hasInstance</code> 来自定义的 <code>instanceof</code> 行为。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">PrimitiveNumber</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>hasInstance<span class="token punctuation">]</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'number'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span> <span class="token keyword">instanceof</span> <span class="token class-name">PrimitiveNumber</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
</code></pre>
<h1 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h1><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>可以判断基本数据类型，但判断数组、对象和 null 时得到的都是 Object，并且 <code>typeof NaN</code> 会得到 Number。可以在 typeof 的基础上再使用 Array.isArray 加以区分。</p>
<h4 id="instanceof-1"><a href="#instanceof-1" class="headerlink" title="instanceof"></a>instanceof</h4><p>可以判断基本数据类型，但判断引用类型的话，因为所有原型都继承自 Object，所以 <code>函数/数组 instanceof Object</code> 都会得到 true。</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>通过 <code>Object.prototype.toString.call()</code> 来判断数据类型，不仅是基本数据类型还是引用数据类型，都可以得到正确结果。而且对于 Map、Set 等数据结构也能准确判断。</p>
<h1 id="JS继承的几种方式"><a href="#JS继承的几种方式" class="headerlink" title="JS继承的几种方式"></a>JS继承的几种方式</h1><h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>&emsp;&emsp;直接在子构造函数中调用父构造函数，这样可以使子类继承了父构造函数的属性和方法。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Parent"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"I'm Parent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 需要的话还可以向父构造函数传递参数</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>des <span class="token operator">=</span> <span class="token string">"Child constructor"</span> 
<span class="token punctuation">}</span>
<span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Parent</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>show<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// undefined</span>
</code></pre>
<p>&emsp;&emsp;使用构造函数继承的缺陷在于，子构造函数只是继承到父构造函数中的属性和方法，无法继承到父构造函数原型链上的东西，因为这种方法<strong>只是简单地在子构造函数上调用父构造函数，拷贝了一份属性方法而已</strong>。</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>&emsp;&emsp;为了解决构造函数继承的问题，我们可以直接让子构造函数的原型指向父构造函数，这样既能继承父构造函数的属性方法，也能继承其原型链上的属性方法。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Parent"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"I'm Parent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>des <span class="token operator">=</span> <span class="token string">"Child constructor"</span> 
<span class="token punctuation">}</span>
Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// Child.prototype = Parent;</span>
<span class="token comment" spellcheck="true">// child -> Child.prototype(Parent本身) -> Function.prototype -> Object.prototype -> null</span>
<span class="token comment" spellcheck="true">// Child.prototype = new Parent();</span>
<span class="token comment" spellcheck="true">// child -> Child.prototype(Parent的实例) -> Parent.prototype -> Object.prototype -> null</span>
</code></pre>
<p>&emsp;&emsp;要注意到上面两种不同写法，结果 child 的原型链是不一样的。前面原型链上没有<code>Parent.prototype</code>，所以 child 上自然也就没有 show 方法了。原型链继承的不足在于，创建实例时不能给构造函数传参，child 不能自由初始化父构造函数上变量的值。而且对于每一个由 Child 生成的实例，当它们对 <strong>Parent构造器上的引用类型数据</strong>进行修改时会互相影响，因为每一次修改都会改动到 Parent 构造器上的值，造成下一次 Child 实例回溯原型链取值时拿到的都是被修改后的值。我们先修改一下上面的代码。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Parent"</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"I'm Parent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>des <span class="token operator">=</span> <span class="token string">"Child constructor"</span> 
<span class="token punctuation">}</span>
Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 操作一</span>
child<span class="token punctuation">.</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// child.arr -> [0, 3], child1.arr -> [0, 3]</span>
<span class="token comment" spellcheck="true">// 操作二</span>
child<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// child.arr -> [1, 3, 4], child1.arr -> [1, 3, 4]</span>
<span class="token comment" spellcheck="true">// 操作三</span>
child<span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// child.arr -> [1], child1.arr -> [1, 3]</span>
</code></pre>
<p>&emsp;&emsp;举这个例子要说明的是 JS 的堆栈存储方式。使用原型链继承，child 和 parent 都指向了 Parent.prototype 这个对象，而对象中的值是存储在堆中的，存储在栈中的只是指向这个堆空间的地址而已。如果是直接修改堆中数据的值（比如操作一和操作二），那么会影响到所有指向这个地址空间的变量。而若只是改变地址空间的指向，则不会影响到其他指向原来这个地址空间的变量（比如操作三）。（看到这里，你有没有想到那构造函数继承法会不会也存在这个问题？答案是不会，至于原因，其实上面的加粗字体也已经解释了。）</p>
<p>&emsp;&emsp;针对上面的例子，我们通过一段代码来佐证吧，这里就不再花篇幅解释了，有疑问的读者再好好理解上面这一段话吧。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">A</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
A<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  c<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  d<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// undefined</span>
<span class="token comment" spellcheck="true">// a 始终指向构造函数之前的那个原型</span>
</code></pre>
<h2 id="构造函数继承-原型链继承"><a href="#构造函数继承-原型链继承" class="headerlink" title="构造函数继承 + 原型链继承"></a>构造函数继承 + 原型链继承</h2><p>&emsp;&emsp;既然构造函数继承法里不存在实例修改父构造函数上引用类型的值会相互影响的问题，那么我们便可以采用构造函数继承 + 原型链继承的方法了。使用构造函数继承法使子构造函数拥有父构造函数的属性和方法，使用原型链继承法修改子构造函数的原型使其指向父构造函数的原型。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Parent"</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"I'm Parent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>des <span class="token operator">=</span> <span class="token string">"Child constructor"</span> 
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 这里不使用上例的 Child.prototype = new Parent()，是为了不重复指向两次父构造函数，避免引入多余的重复数据</span>
Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
<span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
child<span class="token punctuation">.</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        
<span class="token keyword">let</span> child1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// child.arr -> [10, 3]，child1.arr -> [1, 3]</span>
</code></pre>
<p>&emsp;&emsp;现在可以看到，即使在 Child 的一个实例上修改了 arr 的值，也不会影响到 其他实例上 arr 的值了。不过问题又来了，当我们<code>console.log(child.constructor)</code>的时候，发现输出的会是 Parent 构造函数。这问题也很好理解，因为我们修改了 child.prototype 的原型，而我们对某一个对象或函数使用 constructor 属性时是到它们的原型上去读取的，所以 child 的构造函数自然也就成了 Parent。既然如此，我们可以手动把它的构造函数改回来，设置<code>Child.prototype.constructor = Child</code>。</p>
<pre class=" language-js"><code class="language-js">Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Child函数</span>
<span class="token keyword">let</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Child函数</span>
</code></pre>
<p>&emsp;&emsp;虽然通过手动修改 Child.prototype 的 constructor 属性可以修正 Child 实例的构造函数指向错误问题，但当我们输出 Parent 实例的构造函数的时候发现也同样输出了 Child 函数！原因呢？我们可能会忽略了一点，<code>Child.prototype</code>是一个对象，而对象是按引用传递，牵一发而动全身！知道了问题所在，就可以对症下药了。使用<code>Object.create</code>方法既可以以参数为原型创建一个对象，也可以防止修改对象时也对原本的对象造成影响（但修改参数对象的话是会对实例对象造成修改的）。除了<code>Object.create</code>方法外，也可以使用<code>Child.prototype = JSON.parse(JSON.stringify(Parent.prototype))</code>，作用是一样的。最终的构造函数继承 + 原型链继承方法的代码实现为：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 父构造函数的属性和方法</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 子构造函数的属性和方法</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 绑定子构造函数的原型</span>
Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Child.prototype = JSON.parse(JSON.stringify(Parent.prototype));</span>
<span class="token comment" spellcheck="true">// 修正实例构造函数的指向错误</span>
Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>
</code></pre>
<p>（如果要实现多继承的话，貌似只能通过 <code>__proto__</code> 将一个个父类连接到子类上，或者通过 <code>Object.assign</code> 方法将所有父类的原型都集中到一个上，再将这个集万千个原型于一体的父类 通过 <code>Object.create</code> 方法赋给子类）</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之执行上下文和词法作用域</title>
    <url>/2019/03/16/js%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><ul>
<li>全局执行上下文： 在浏览器中即window对象，此时this指向该全局对象（作用域链的源头）。JS代码一开始执行就会被创建，而且至始至终都存在直至关闭程序。</li>
<li>函数执行上下文：每次调用函数时都会创建一个函数执行上下文，此时this指向并不能确定，可能指向当前函数，也可能指向全局对象。</li>
</ul>
<p>&emsp;&emsp;一个执行上下文的生命周期可以分为两个阶段（我看到也有人说是编译阶段和执行阶段，但其实都一样）：</p>
<ol>
<li><strong>创建阶段</strong>:</li>
</ol>
<p>&emsp;&emsp;在创建阶段中，代码还没有执行，此时的准备工作是：<strong>创建变量对象</strong>（Variable object，VO）、<strong>建立作用域链</strong>、<strong>确定this的指向</strong>。其中变量对象包含了当前执行上下文所有的参数，变量，函数，相当于是对这些数据进行初始化，工作包括以下三点：</p>
<ul>
<li><strong>建立argument对象</strong>，检查当前上下文的形参建立相应的属性，对于没有实参的形参则设为undefined。</li>
<li><strong>检查函数声明</strong>，创建指向函数的引用。</li>
<li><strong>检查变量声明</strong>，由var声明的变量通过变量提升会初始化为undefined。</li>
</ul>
<p>&emsp;&emsp;在创建阶段，变量对象里的所有数据都不能访问，只有等到执行阶段，变量对象转变为活动对象（activation object，AO）后，这些数据才能被访问到。而活动对象，其实也就是变量对象，只是两者在不同的生命周期下的不同状态而已。</p>
<ol start="2">
<li><strong>执行阶段</strong>:</li>
</ol>
<p>&emsp;&emsp;创建完成之后就会开始执行代码，此时会完成变量赋值，函数引用，以及执行其他代码等工作。</p>
<p>&emsp;&emsp;其中需要注意的是：</p>
<ol>
<li><p>同一作用域下若存在多个同名函数声明，则后面的函数声明会替换前面的。</p>
</li>
<li><p>let和const不存在变量提升，变量值不会被初始化为undefined，直到被声明之前这段时间内会进入<strong>暂时性死区</strong>，若在这段时间内使用该变量会直接报错。</p>
</li>
<li><p>创建阶段时，首先会处理函数声明（<strong>函数会优先被提升</strong>），其次再处理变量声明，如果变量名跟已经声明的形参或函数同名，则变量声明不会对其造成干扰。</p>
</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 举个栗子：</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 1</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 进入创建阶段时，将a变量提前声明了，但因为其跟形参同名所以a不会被初始化为undefined而是保持原先的值1。</span>
<span class="token comment" spellcheck="true">// 待到执行阶段时，形参的值被覆盖于是输出2。</span>
<span class="token comment" spellcheck="true">// 题外话：如果重新声明一个已经被赋值了的变量，该变量还是会保留原先的值而不会被置为undefined，因为重复的声明会被忽略。</span>
</code></pre>
<p>&emsp;&emsp;关于arguments：</p>
<p>&emsp;&emsp;调用函数时，会先为每一个函数创建一个Arguments对象，所有作为参数传入的值都会成为Arguments对象的数组元素，在该函数体内可以使用arguments.length来获取到参数个数。需要注意的是，虽然可以通过arguments[0]，arguments[1]等下标形式来获取参数，但arguments是一个伪数组，并没有数组的slice等方法，但可以通过<code>Array.from(arguments)</code>来把它转换为真正的数组。如果我们使用<code>Object.prototype.toString.call(arguments)</code>来判定argumes的数据类型，得到的会是<code>[object Arguments]</code>。</p>
<ol>
<li><p>如果我们给arguments新增一个值如arguments[100]，是会成功添加到arguments上的，但不会改变arguments的长度。</p>
</li>
<li><p>如果我们在函数体内修改arguments的值，不仅会修改到arguments上，也会修改到该形参。若是使用严格模式，则只会修改到arguments，但不会修改到该形参。</p>
</li>
<li><p>如果声明一个和形参同名的变量或修改形参，不仅会修改到该形参，也会修改到arguments上。若是使用严格模式，则只会修改到形参，而不会修改到arguments。</p>
</li>
</ol>
<p><strong>&emsp;&emsp;总结一下就是，在非严格模式下，arguments和形参会同步改变，一变则两者都变。若是严格模式，arguments和形参则不会同步改变。（类似于JS的按值访问和按引用访问）</strong></p>
<p><img src="/2019/03/16/js之作用域和执行上下文/1.png" alt></p>
<p>&emsp;&emsp;另外还有一点就是，如果形参是由 rest 接受的，或是设置了默认参数的，形参的改变就不会修改到 arguments 上。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// [Arguments] { '0': 11 }</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// [Arguments] { '0': 1 }</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// [Arguments] { '0': 1 }</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h1 id="执行栈-调用栈"><a href="#执行栈-调用栈" class="headerlink" title="执行栈 / 调用栈"></a>执行栈 / 调用栈</h1><p>&emsp;&emsp;用于存储在代码执行期间创建的所有执行上下文，具有后进先出（LIFO）的特性。</p>
<p>&emsp;&emsp;一开始运行JS代码时，就会创建全局执行上下文并放到到当前的执行栈中（全局执行上下文始终都在执行栈底）。每当调用函数时，JS引擎都会为该函数创建一个新的函数执行上下文（即使该函数曾经被调用过）并放到执行栈的栈顶。当函数执行完毕后，该函数执行上下文就会出栈，上下文控制权将交给执行栈的下一个函数执行上下文。</p>
<h1 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h1><p>&emsp;&emsp;词法作用域由变量所在的位置决定，编写代码的时候就能够确定的了，所以也是静态作用域。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Uncaught ReferenceError: a is not defined</span>
  a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 1</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    

<span class="token comment" spellcheck="true">// 创建foo函数执行上下文时，因为变量a没有使用var声明，所以在创建阶段不存在变量提升。</span>
<span class="token comment" spellcheck="true">// 在执行阶段打印a时，会先在本函数的作用域里查找a，如果找不到则继续向父级作用域（这里是全局作用域）查找，也找不到a所以直接抛出错误。</span>
<span class="token comment" spellcheck="true">// 如果是非严格模式则还会在全局上创建全局变量a（但是这样会污染全局变量，甚至造成内存泄露），因此在bar函数里往全局作用域查找时就找到了a所以输出1。</span>
</code></pre>
<h2 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h2><p>&emsp;&emsp;函数表达式里函数变量a可读可写，函数名fn只能读不能写（类似于const）。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 修改成功，但不会改变到fn</span>
  fn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 修改失败，非严格模式下默默失效，严格模式下直接报Uncaught TypeError: Assignment to constant </span>
  variable
  <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 若是声明一个和函数名同名的变量则会覆盖掉fn，但不会修改到a</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 函数表达式的函数名只在该函数内部有效</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre>
<p>&emsp;&emsp;函数声明里函数名fn可读可写（严格模式也是）。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 打印函数本身</span>
  fn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 1</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;<strong>IIFE中的函数是函数表达式而不是函数声明</strong>，所以在非匿名自执行函数（Immediately Invoked Function Expressions）中，函数名只能读不能写。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 若是通过var再次声明则会覆盖掉原先的值</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 打印函数本身</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 10</span>
</code></pre>
<h2 id="静态作用域和动态作用域"><a href="#静态作用域和动态作用域" class="headerlink" title="静态作用域和动态作用域"></a>静态作用域和动态作用域</h2><p>&emsp;&emsp;刚才说过，JS采用的词法作用域也是静态作用域，变量和函数的作用域是在定义的时候就决定了的，跟执行时的状态无关。我们举个栗子说明便知（取自犀牛书P183）。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> scope<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> scope<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> f<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>&emsp;&emsp;上面两段代码都会得到 local scope。先看第一段代码，我们调用了 checkscope 函数，并在 return 中调用了内部函数 f，返回 scope 变量。在查找 scope 的过程中会先在函数 f 中寻找，寻找不到会往上向外部函数 checkscope 寻找，找到了就返回 “local scope”，如果还找不到才会向上往全局变量查找。而第二段代码和第一段的区别在于，第二段代码是在 checkscope 函数中返回了函数 f，再再全局环境下调用 f。此时 scope 的查找过程其实是跟第一段代码一样的。因为 scope 的作用域早已在函数和变量定义的时候就确定好了，不受函数执行时的位置干扰，这也就是所谓的静态作用域，而动态作用域的查找依赖于函数执行的位置。假若此处使用动态作用域，第二段代码对 scope 的查找同样会是从函数 f 开始，找不到后就往调用 f 的环境即全局环境里去查找了。</p>
<p>&emsp;&emsp;理解了静态作用域后，我们再看一段代码，涉及的知识点是一样的，所以就不多做解释了。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">innnerFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ReferenceError: c is not defined</span>
  <span class="token punctuation">}</span>
  fn <span class="token operator">=</span> innnerFoo<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>盒模型和负margin</title>
    <url>/2019/03/12/CSS%E8%B4%9F%E8%BE%B9%E8%B7%9D/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>&emsp;&emsp;每一个HTML标签元素都是由四个部分组成的，分别是内容(content)、内边距(padding)、边框(border)、外边距(margin)。其中盒子的大小只由 content + padding + border 决定，margin影响的不是盒子大小，而是盒子占据的位置。这一部分比较简单，所以这里就不多做叙述了。<br><img src="/2019/03/12/CSS负边距/box.png" alt></p>
<h2 id="标准盒模型和IE盒模型"><a href="#标准盒模型和IE盒模型" class="headerlink" title="标准盒模型和IE盒模型"></a>标准盒模型和IE盒模型</h2><p>&emsp;&emsp;关于盒模型需要着重注意的是标准盒模型和IE盒模型的差异。W3C标准盒模型下，content 的宽高只由其自身的宽高决定，而在IE盒模型下，content 的宽高还包括了 border 和 padding（也就是怪异模式）。我们可以在页面开头声明 DOCTYPE 的类型，来指定浏览器统一使用 W3C 标准盒模型，否则在 IE 浏览器中会将盒模型解释为 IE 盒模型。声明 DOCTYPE 时推荐使用<code>&lt;!DOCTYPE html&gt;</code>，会指示浏览器使用 HTML5 规范（要使用 HTML4 则会有三种 &lt;!DOCTYPE&gt; 声明方式）。</p>
<h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p>&emsp;&emsp;在 IE8+ 及 chrome 等浏览器中还可以通过 CSS 的<code>box-sizing</code>属性来定义如何计算一个元素的宽高。对于默认值<code>box-sizing: content-box</code>，页面计算时会使用 W3C 标准盒模型，给元素的宽高赋值相当于对 content 赋值，而整个盒子的大小还得再算上 border 和 padding。</p>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/box1.png" alt><br>&emsp;&emsp;若设置<code>box-sizing: border-box</code>，则会使用IE盒模型，给元素的宽高赋值相当于是设置content+padding+border的总宽高。我们使用padding时很多时候都需要再设置<code>box-sizing: border-box</code>，以免元素超出容器范围。比如当我们设置一个列表或输入框的时候，通常左边或右边会有一个icon图标，我们可以采用设置背景图片的方式来显示图标，再设置padding-left或padding-right来间隔开图标和文字。这时候我们就需要再设置<code>box-sizing: border-box</code>了，否则设置的padding会加宽盒子的宽高使得列表或输入框超出容器造成页面在水平方向可以拖动。</p>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>
  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/box2.png" alt></p>
<h1 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h1><h2 id="margin-left、margin-right和width"><a href="#margin-left、margin-right和width" class="headerlink" title="margin-left、margin-right和width"></a>margin-left、margin-right和width</h2><p>&emsp;&emsp;margin-left、margin-right和width设置为auto时的影响。</p>
<h3 id="三者都设置为auto"><a href="#三者都设置为auto" class="headerlink" title="三者都设置为auto"></a>三者都设置为auto</h3><p>&emsp;&emsp;margin-left和margin-right会失效，都被设置为0，width尽可能大(即父元素宽度减去左右border和左右padding)。</p>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="parent"> 
  &lt;div class="box">块级元素&lt;/div> 
&lt;/div>

<span class="token class">.parent</span></span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#eeb3b3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#ffd800</span><span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span> 
  <span class="token property">width</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/box3.png" alt></p>
<h3 id="其中一个设置为auto"><a href="#其中一个设置为auto" class="headerlink" title="其中一个设置为auto"></a>其中一个设置为auto</h3><p>&emsp;&emsp;设置为auto的元素会自动调整自身宽度，使得三者的总宽度等于父元素的宽度。若是margin-left和right设为定值且没有指定width，也会默认width为auto。</p>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#ffd800</span><span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span> 
  <span class="token property">width</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/box4.png" alt></p>
<h3 id="其中两个设置为auto"><a href="#其中两个设置为auto" class="headerlink" title="其中两个设置为auto"></a>其中两个设置为auto</h3><ul>
<li>margin-lef和margin-right为auto：此时margin-left和margin-right相等，平分剩下的空间，达到水平居中的效果。</li>
</ul>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#ffd800</span><span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span> 
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/box5.png" alt></p>
<ul>
<li>width和其中一个margin为auto： 被设置为auto的那个margin变为0，width尽可能大。</li>
</ul>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#ffd800</span><span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span> 
  <span class="token property">width</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/box6.png" alt></p>
<h2 id="负margin"><a href="#负margin" class="headerlink" title="负margin"></a>负margin</h2><p>&emsp;&emsp;负margin同样可以使文档流中元素的位置发生偏移，和相对定位偏移的区别在于，相对定位的元素偏移后，仍然霸占着原先的位置，使文档流中其他元素无法占据该空间。而通过负margin偏移的元素，<strong>虽然元素大小不变，但会使文档流向左流或向上流(文档流只能往这两个方向移动)，造成了后面的元素可以占据这部分空间，会使得两个元素重叠</strong>(下文会详细说明)。</p>
<p>&emsp;&emsp;（我还有另一种理解，通过负margin偏移的元素，虽然元素大小不变，但会<strong>减小该元素在文档流中占据的空间</strong>，自然也会使文档流向左流或向上流，导致后面的元素移动。我觉得以这种观点去理解的话，这整篇文章所涉及的内容也都可以说得通，甚至可以更好的解释清楚。但我谷歌了一下，发现并没有关于 元素在文档流中占据的空间可不可以被减小 的相关文章，所以这里只当作一种个人的理解方式仅供参考）</p>
<h3 id="对static定位而且没有浮动的元素使用负margin"><a href="#对static定位而且没有浮动的元素使用负margin" class="headerlink" title="对static定位而且没有浮动的元素使用负margin"></a>对static定位而且没有浮动的元素使用负margin</h3><p><img src="/2019/03/12/CSS负边距/negative-margin.jpg" alt></p>
<ol>
<li><p>margin-top或margin-left为负值时，元素被拉向指定的方向(见上图)，即和设置margin-top和margin-left为正值时移动的方向相反。</p>
</li>
<li><p>margin-bottom或margin-right为负值时，元素本身不会偏移，但因为文档流向左/上移动了，所以后续的元素也会随之向左/上移动，和原来的元素重叠在一起。</p>
</li>
</ol>
<p><img src="/2019/03/12/CSS负边距/no-margin-bottom.png" alt><br><img src="/2019/03/12/CSS负边距/use-margin-bottom.png" alt>    </p>
<ol start="3">
<li>如果元素没有设置width或width为auto时，设置负的margin-left或margin-right，会增大元素的宽度，类似于padding。若是负的margin-left的话，则还会向左移动。</li>
</ol>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="container">
  &lt;div class="box">我没有设置宽高&lt;/div>
&lt;/div>

<span class="token class">.container</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">150</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">150</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#eee</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> -<span class="token number">50</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/margin-right.png" alt>    </p>
<ol start="4">
<li>这里单独再说一下负margin-bottom，负的margin-bottom不仅有上述第二点的影响外，更重要而且实用的一点是会<strong>减少元素框的高度</strong>。我在其他几个博客里看到有人把这说成是<strong>减少自身的供css读取的高度</strong>，但他们都没有解释什么叫做 “减少自身的供css读取的高度”，我谷歌了一下也没有发现什么解释，所以这里按照我个人的理解，使用 “减少元素框的高度” 这概念来解释。我们先来看几句代码和效果图：</li>
</ol>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="left">Coding Coding Coding Coding Coding&lt;/div>
&lt;/div>

<span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">60</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/1.png" alt></p>
<p>&emsp;&emsp;现在我们再给该元素设置<code>margin-bottom: -50px;</code>再来看看效果<br><img src="/2019/03/12/CSS负边距/2.png" alt><br>&emsp;&emsp;从图中我们可以发现，虽然控制台显示该元素的高度还是100px并且也全部都渲染出来了，但图中的橙色部分(貌似代表的是margin，但为了方便理解所以我把它当成<strong>元素框</strong>, 或者说是元素在文档流中占据的空间)缩小了一半。而CSS中的<code>overflow</code>属性判断元素是否溢出，不是根据我们给它设置好的height，而是根据元素框(图中的橙色框框)来判断的。只要元素内容超出这个元素框，给父容器设置了<code>overflow: hidden</code>后超出部分就会被隐藏，即使元素的高度是100px足够容纳元素内容。有图有真相：<br><img src="/2019/03/12/CSS负边距/3.png" alt></p>
<p>&emsp;&emsp;借助负margin-bottom这个特性我们就可以实现很多功能了，包括常见的两栏等高布局，栗子见下文。</p>
<h3 id="对浮动元素使用负margin"><a href="#对浮动元素使用负margin" class="headerlink" title="对浮动元素使用负margin"></a>对浮动元素使用负margin</h3><p>&emsp;&emsp;先看没有设置负margin时的原始样式和表现</p>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="fa">&lt;/div>
&lt;div class="fb">&lt;/div>
&lt;div class="fc">&lt;/div>

<span class="token class">.fa</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.fb</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.fc</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/float.png" alt></p>
<p>&emsp;&emsp;现在给每一个元素都设置<code>margin-right: -50px</code>，效果如下：<br><img src="/2019/03/12/CSS负边距/margin-right1.png" alt><br><img src="/2019/03/12/CSS负边距/margin-right2.png" alt><br>&emsp;&emsp;通过检查我们可以发现，三个元素的宽高并没有改变，还都是100px，那为什么fa，fb会被覆盖住呢？前面已经说过，通过负margin偏移后，元素在文档流中减小的那部分空间会被后面的元素占据上(这里是文档流左移了)，而自身的宽高不变。以fa为例(红色的方格)，本来fa占据了100px的空间，后面的元素只能紧挨着fa从100px后开始占位置，但现在给fa设置了<code>margin-right: -50px</code>，fa虽然宽还是100px，但fa在文档流中占据的空间减小了50px，所以这50px被后面的fb填充了，也就是图中的效果，fb重叠到了fa上面。至于fc和fb也是同样的道理。理解了这一点，下面这个也就懂了。</p>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="left">左浮动&lt;/div>
&lt;div class="right">也是左浮动&lt;/div>

<span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
<p><img src="/2019/03/12/CSS负边距/float1.png" alt><br>&emsp;&emsp;当给第一个元素添加<code>margin-bottom: -200px</code>时，就成了<br><img src="/2019/03/12/CSS负边距/float2.png" alt><br><img src="/2019/03/12/CSS负边距/float3.png" alt><br>&emsp;&emsp;其中第一个元素并没有消失，宽高也没有改变，只是被第二个元素挡住了而已，原因同上。</p>
<h2 id="负边距的应用"><a href="#负边距的应用" class="headerlink" title="负边距的应用"></a>负边距的应用</h2><h3 id="去除最后一个li的border-bottom"><a href="#去除最后一个li的border-bottom" class="headerlink" title="去除最后一个li的border-bottom"></a>去除最后一个li的border-bottom</h3><p>&emsp;&emsp;在一个列表中，我们经常会给每一个li设置border-bottom，并且外层的父元素也会设置border，代码和效果图如下：</p>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;ul>
    &lt;li>Hello World&lt;/li>
    &lt;li>Hello World&lt;/li>
    &lt;li>Hello World&lt;/li>
    &lt;li>Hello World&lt;/li>
    &lt;li>Hello World&lt;/li>
  &lt;/ul>
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.box</span> ul </span><span class="token punctuation">{</span>
  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.box</span> li </span><span class="token punctuation">{</span>
  <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
  <span class="token property">border-bottom</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/4.png" alt><br>&emsp;&emsp;很明显最后一个li的border-bottom和父元素的border靠在一起了，视觉效果很不美观。我在开发IOS仿网易云音乐的时候就经常遇到这个问题，不过我是把border-bottom的样式单独写在一个class里，如果不是最后一个li就给它绑定这个类，当然这是可行的，但这样终究麻烦了一点，现在我使用负margin实验了一下发现也可以达到同样的效果。只需要给li增加一句<code>margin-bottom: -1px</code>就可以了，<br><img src="/2019/03/12/CSS负边距/5.png" alt><br>&emsp;&emsp;这要怎么理解呢？前面也说过，<strong>使用负margin后会使元素框的高度减小，造成后面的元素上移</strong>。没错，除却第一个li外其余几个li都上移了，只是1px比较小看起来不是很明显而已，如果你调成-5px效果就很明显了，这里就不贴图了(有个小问题，为什么第一个li不会上移呢？因为虽然第一个li的元素框高度减小了，但影响到的是它后面的元素，对其自身是没什么影响的)。那为什么后面几个li上移了最后一个border-bottom就不会重叠了呢？代码中我们并没有给ul指定高度，所以ul会由子元素li撑起来，li的元素框高度减小后整个ul的高度也会随着减小(这里是减小了5px)，ul的border-bottom自然也会随着上移5px，而最后一个li是上移了4px。算上最后一个li自身border-bottom的1px，所以ul的border-bottom和最后一个li的border-bottom会重叠在一起！一开始我也不太理解，重叠在一起不是也会加粗了边框吗？后来实践得知，两个边框重叠和靠在一起是不同的概念的！两个边框靠在一起才会看起来像是加粗了，重叠在一起是不会有这种视觉效果的。想象一下，你正对着千手观音时，你觉得那是一个人还是N个人？这里我还是贴一下图说明吧。</p>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="test">&lt;/div>
&lt;div class="test">&lt;/div>

<span class="token class">.test</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/6.png" alt><br>&emsp;&emsp;上图两条边框靠在了一起，当我给下面的方格添加<code>margin-top: -1px</code>后，,两个边框便重叠起来了，效果是<br><img src="/2019/03/12/CSS负边距/7.png" alt><br>&emsp;&emsp;以上，就是我对使用负margin消除最后一个li的border-bottom的理解了。所以啊，以后就不要用class动态绑定啦，开始用负margin吧。</p>
<h3 id="实现两栏布局"><a href="#实现两栏布局" class="headerlink" title="实现两栏布局"></a>实现两栏布局</h3><p>&emsp;&emsp;利用浮动和负边距可以很神奇地实现两栏布局，即一栏作为侧边栏固定宽度，一栏宽度为100%自适应。先一步步来：</p>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div>
  &lt;div class="slider">
    &lt;p>slider&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;p>content&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.slider</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/example1.png" alt><br>&emsp;&emsp;在上图中因为content是100%宽度而且slider已经占据了100px，所以content被挤了下去，而要实现两栏布局我们首先要做的就是将slider和content放到同一行去。但两者挤不下要怎么办？我们可以想到使slider在文档流中不占据位置，这样就可以让content也占据slider原本的位置从而使两者同行排列，而方法自然是给slider绝对定位了。这是一种方法，但我们也还可以使用负margin。前面提到过，使用<strong>负margin偏移后会造成该元素在文档流中占据的空间减小</strong>，原先content需要在文档流中占据100%的宽度，现在我们给content添加<code>margin-right: -100px; // slider的宽度</code>，就可以使content在文档流中只需要占据100%-100px的宽度空间就够了。为了防止造成页面水平拖动，所以给最外层的div加上<code>overflow: hidden</code>。效果如下：<br><img src="/2019/03/12/CSS负边距/example2.png" alt><br>&emsp;&emsp;这里还有一个问题，我们虽然隐藏了content超出外层div的内容，但那一部分空间还是存在的，conten的内容还是会分布在那一部分位置上。所以我们还需要给content的子元素加上<code>.content p {margin-right: 100px}</code>，这样就大功告成了，最终效果如下：<br><img src="/2019/03/12/CSS负边距/example3.gif" alt><br>完整代码：</p>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div style="overflow: hidden">
  &lt;div class="slider">
    &lt;p>slider&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;p>content&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.slider</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> -<span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> p </span><span class="token punctuation">{</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="和绝对定位配合实现已知宽高元素的水平垂直居中"><a href="#和绝对定位配合实现已知宽高元素的水平垂直居中" class="headerlink" title="和绝对定位配合实现已知宽高元素的水平垂直居中"></a>和绝对定位配合实现已知宽高元素的水平垂直居中</h3><p>&emsp;&emsp;这应用是家常便饭了，就不赘述了。</p>
<h3 id="实现多列等高，双飞翼布局等"><a href="#实现多列等高，双飞翼布局等" class="headerlink" title="实现多列等高，双飞翼布局等"></a>实现多列等高，双飞翼布局等</h3><p>&emsp;&emsp;实现原理和上面的两栏布局差不多，具体的实现请<a href="http://blog.dangosky.com/%2F2019%2F03%2F07%2F%E6%9C%AA%E7%9F%A5%E5%AE%BD%E9%AB%98%E5%85%83%E7%B4%A0%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F#toc-heading-5">戳这里</a>。</p>
<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p>&emsp;&emsp;块级格式化上下文（Block Formatting Context，BFC），我的理解是：BFC 就是具有特定规则的一个容器，而且容器里面的元素不会在布局上影响到外面的元素。即不同的 BFC 区域之间是各自独立互不影响的。这里说的特定规则即下文要说到的垂直方向上 marin 会合并、子元素的 margin-top 会带跑父元素等。</p>
<!-- 一个BFC区域包含创建该上下文元素的所有子元素，但是不包括创建了新的BFC的子元素的内部元素。每一个BFC区域只包括其子元素，不包括其子元素的子元素。 -->
<p>&emsp;&emsp;只要满足下列任意一个条件即可触发 BFC：</p>
<ul>
<li>根元素，即 body</li>
<li>float 的值不为 none</li>
<li>overflow 的值不为 visible</li>
<li>display 的值为 inline-block、table-cell、table-caption</li>
<li>position 的值为 absolute 或 fixed </li>
</ul>
<p>&emsp;&emsp;我们通常可以利用两个 BFC 之间不会互相影响这个特性，来消除 BFC 区域带来的一些影响。</p>
<h2 id="防止垂直方向上的-margin-合并"><a href="#防止垂直方向上的-margin-合并" class="headerlink" title="防止垂直方向上的 margin 合并"></a>防止垂直方向上的 margin 合并</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="a">&lt;/div>
&lt;div class="b">&lt;/div>

<span class="token class">.a</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.b</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/10.png" alt></p>
<p>&emsp;&emsp;在上面的测试代码中，我们给两个兄弟 div 各设置了 50px 和 100px 的外边距。依我们原先的预期，这两个 div 在垂直方向上应该会相距 150px 才对，但从上图中我们可以发现它们只相距了 100px 而已，这就是在同一个 BFC 区域内（这里是 body），垂直方向上的 margin 会合并。具体的合并规则是：</p>
<ul>
<li>如果两个外边距都为正数，则最终的外边距为两者的最大值。</li>
<li>如果两个外边距一正一负，则最终的外边距为两者的和。</li>
<li>如果两个外边距都为负数，则最终的外边距为两者的最小值。</li>
</ul>
<p>&emsp;&emsp;总结成一句话就是：正正取大，正负相加，负负取小。读者可以<a href="https://jsfiddle.net/DangoSky/4a3bnev6/" target="_blank" rel="noopener">戳这里进行实验</a>。</p>
<p>&emsp;&emsp;为了防止 margin 合并，我们可以利用 BFC 来使两个 div 的布局不互相影响。可以给 div.a 或者 div.b 外层加一个父级 div 包裹，并触发父级 div 的 BFC，例如常用的<code>overflow: hidden</code>即可。</p>
<h2 id="防止-margin-塌陷"><a href="#防止-margin-塌陷" class="headerlink" title="防止 margin 塌陷"></a>防止 margin 塌陷</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="a">
  &lt;div class="b">&lt;/div>
&lt;/div>

<span class="token class">.a</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.b</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/11.png" alt></p>
<p>&emsp;&emsp;通过上面这段代码，我们预期中是想让子元素 b 距离父元素 a 顶部 50px 距离的，但结果却是子元素带着父元素一起偏离顶部 50px 了，它们的相对距离并没有改变，也就是子元素的 margin-top 带跑了父元素。解决办法也是利用 BFC 来使外层的 body 不影响到 div.a 和 div.b，同样给父元素添加 <code>overflow: hidden</code> 来触发 BFC。</p>
<p><img src="/2019/03/12/CSS负边距/16.png" alt></p>
<p>&emsp;&emsp;但需要注意的是，得子元素和父元素<strong>直接相接触</strong>才会导致 margin 塌陷，也就是说得满足几个条件：</p>
<ul>
<li>父元素没有设置 border 和 padding-top。</li>
<li>该子元素是父元素的第一个非空子元素。</li>
<li>如果父元素和该子元素之间存在其他空元素的话（比如空标签），若是行内元素则需保证没有设置水平方向的 margin、border 和 padding。若是块级元素则需保证没有设置垂直方向的 border 和 padding。</li>
</ul>
<p>&emsp;&emsp;总的来说，就是父元素和该子元素要相接触，之间不能存在其他障碍物阻拦，比如 border 或 padding 之类的。需要区分的是如果它们中间有其他空元素的话，行内元素和块级元素一个是要求水平不接触一个是要求垂直不接触。<a href="https://jsfiddle.net/DangoSky/2zho76f9/" target="_blank" rel="noopener">可以戳这里进行实验</a>。</p>
<h2 id="阻止元素被浮动元素覆盖"><a href="#阻止元素被浮动元素覆盖" class="headerlink" title="阻止元素被浮动元素覆盖"></a>阻止元素被浮动元素覆盖</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="a">&lt;/div>
&lt;div class="b">&lt;/div>

<span class="token class">.a</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.b</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/12.png" alt></p>
<p>&emsp;&emsp;平时写页面的时候常常会遇到上图这种情况，一个浮动元素会覆盖在它后面的元素上。以前我都是直接给后面的元素设置一个外边距来间隔开它们。但其实利用 BFC 可以更方便得达成目的，也就是触发 div.b 的 BFC，使外层 body 的 BFC 不影响到 div.b。</p>
<p><img src="/2019/03/12/CSS负边距/15.png" alt></p>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="a">
  &lt;div class="b">&lt;/div>
&lt;/div>

<span class="token class">.a</span> </span><span class="token punctuation">{</span>
  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.b</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/12/CSS负边距/13.png" alt></p>
<p>&emsp;&emsp;我们知道，设置了浮动的元素不会将高度计算进父元素中，也就无法撑高父元素。如上图，父元素 a 只剩下 2px 的边框高度了。但往往我们需要把浮动元素的高度也计算进父元素中，之前写仿网易云音乐时就没少遇到这个需求。但当时还不知道 BFC，只会撒撒地再给父元素设置一个高度，然而弊端就在于需要事先知道这个高度才行，这就很硬核了… 如果使用 BFC 的话，就可以清除子元素的浮动，从而使得浮动中的子元素也可以撑起父元素。还是照旧，给父元素添加 <code>overflow: hidden</code> 即可。</p>
<p><img src="/2019/03/12/CSS负边距/14.png" alt></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS常见的几种布局方式</title>
    <url>/2019/03/07/%E6%9C%AA%E7%9F%A5%E5%AE%BD%E9%AB%98%E5%85%83%E7%B4%A0%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="未知宽高元素的水平垂直居中"><a href="#未知宽高元素的水平垂直居中" class="headerlink" title="未知宽高元素的水平垂直居中"></a>未知宽高元素的水平垂直居中</h1><pre class=" language-css"><code class="language-css">&lt;div class=<span class="token string">"container"</span>>
  &lt;div class=<span class="token string">"ele"</span>>hello world&lt;/div>
&lt;/div>

<span class="token comment" spellcheck="true">/* 为了便于观察，先设置一些css样式:  */</span>
<span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#eee</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.ele</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgb</span><span class="token punctuation">(</span><span class="token number">179</span>, <span class="token number">174</span>, <span class="token number">174</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
<blockquote>
<p>将下面任一种方法的css样式分别添加到上面的代码中，都能得到下图这个效果。</p>
</blockquote>
<p><img src="/2019/03/07/未知宽高元素的水平垂直居中布局/center.png" alt></p>
<h2 id="方法一：绝对定位-平移"><a href="#方法一：绝对定位-平移" class="headerlink" title="方法一：绝对定位 + 平移"></a>方法一：绝对定位 + 平移</h2><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.contaienr</span> </span><span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.ele</span> </span><span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-<span class="token number">50%</span>, -<span class="token number">50%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  // 若宽高已知，还可以使用margin-left，margin-right代替
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-css"><code class="language-css"><span class="token selector">// 若是ele指定了宽高，还可以设置距上下左右都为0再自动间隔
// 若没有设置宽高就直接使用的话，ele的宽高都会是父元素的100%
<span class="token class">.ele</span> </span><span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="方法二：tabel布局"><a href="#方法二：tabel布局" class="headerlink" title="方法二：tabel布局"></a>方法二：tabel布局</h2><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.ele</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>  // 可选，若不加则ele的宽度将是父元素的<span class="token number">100%</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="方法三：-flex布局"><a href="#方法三：-flex布局" class="headerlink" title="方法三： flex布局"></a>方法三： flex布局</h2><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="两栏等高"><a href="#两栏等高" class="headerlink" title="两栏等高"></a>两栏等高</h1><p><img src="/2019/03/07/未知宽高元素的水平垂直居中布局/1.png" alt></p>
<h2 id="padding内补偿法"><a href="#padding内补偿法" class="headerlink" title="padding内补偿法"></a>padding内补偿法</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="left">
    &lt;p>左浮动&lt;/p>
    &lt;p>左浮动&lt;/p>
    &lt;p>左浮动&lt;/p>
  &lt;/div>
  &lt;div class="right">
    &lt;p>也是左浮动&lt;/p> 
    &lt;p>也是左浮动&lt;/p> 
    &lt;p>也是左浮动&lt;/p> 
    &lt;p>也是左浮动&lt;/p> 
    &lt;p>也是左浮动&lt;/p> 
    &lt;p>也是左浮动&lt;/p> 
  &lt;/div> 
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span> 
  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 <span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">padding-bottom</span><span class="token punctuation">:</span> <span class="token number">2000</span>px<span class="token punctuation">;</span>
  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> -<span class="token number">2000</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">padding-bottom</span><span class="token punctuation">:</span> <span class="token number">2000</span>px<span class="token punctuation">;</span>
  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> -<span class="token number">2000</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>两栏等高的原理是，给每一栏都设置一个很大的<code>padding-bottom</code>的值，以此来弥补高度较小的那一栏。再使用一个等大的负的<code>margin-bottom</code>来收缩，像在<a href="http://blog.dangosky.com/2019/03/12/css-fu-bian-ju/#toc-heading-9">另一篇文章</a>里我解释的，使用负margin-bottom收缩后，虽然元素自身的宽高没有改变，但它的元素框会随着减小，最终元素框的高度取决于两栏中较高一栏。这时如果给它们的父元素添加<code>overflow: hidden</code>，则会隐藏掉溢出元素框的部分内容，于是就达到了高度较低的一栏和较高的一栏等高的效果。</p>
</blockquote>
<blockquote>
<p>但是使用padding内补偿法有一个缺陷，如果每一栏设置了border的话，因为每一栏的高被padding撑高而且隐藏了超出的内容，所以<strong>border-bottom是显示不出来的</strong>。解决办法是，再在每一栏的最后一个子元素<strong>设置一个div来模仿border-bottom</strong>。记得还要给父元素box设置为相对定位，才能让伪border-bottom定位到那一栏的底部。</p>
</blockquote>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.border</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">52</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">2</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>使用div模仿border-bottom还是有一个限制，就是必须先设置好那一栏的宽度，才好给border设置width。使用<code>width: calc(100% + 2px)</code>是没用的，因为每一栏都没有相对定位，所以100%是参考box而言的。如果要给每一栏设置相对定位，则border的绝对定位是相对于每一栏而言的，显示的边框又会被隐藏掉了。</p>
</blockquote>
<h2 id="tabel布局"><a href="#tabel布局" class="headerlink" title="tabel布局"></a>tabel布局</h2><blockquote>
<p>利用表格（table）中每个单元格（table-cell）等高的特性</p>
</blockquote>
<pre class=" language-css"><code class="language-css"><span class="token selector">// IE8以下不支持
<span class="token class">.box</span> </span><span class="token punctuation">{</span> 
  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="js-jq动态设置"><a href="#js-jq动态设置" class="headerlink" title="js / jq动态设置"></a>js / jq动态设置</h2><blockquote>
<p>在js代码里去获取box里每一栏的高度并取它们的最大值，再将每一栏的高度设置为该最大值。但这不可避免会操作到DOM，难免对性能造成影响。</p>
</blockquote>
<h1 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h1><blockquote>
<p>左栏固定宽度，右栏自适应。</p>
</blockquote>
<p><img src="/2019/03/07/未知宽高元素的水平垂直居中布局/2.gif" alt></p>
<h3 id="利用负margin"><a href="#利用负margin" class="headerlink" title="利用负margin"></a>利用负margin</h3><blockquote>
<p>实现逻辑请看<a href="http://blog.dangosky.com/2019/03/12/CSS%E8%B4%9F%E8%BE%B9%E8%B7%9D/#toc-heading-14">盒模型和负margin</a>这篇文章里的解释。</p>
</blockquote>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;!-- content放在slider后面 -->
&lt;div class="box">
  &lt;div class="slider">
    &lt;p>slider&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.slider</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> -<span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> p </span><span class="token punctuation">{</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;!-- content放在slider前面 -->
&lt;div class="box">
  &lt;div class="content">
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
  &lt;/div>
  &lt;div class="slider">
    &lt;p>slider&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.slider</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100%</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> p </span><span class="token punctuation">{</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-css"><code class="language-css"><span class="token selector">// 或者更简单点，使用BFC 
&lt;div class="box">
  &lt;div class="slider">
    &lt;p>slider&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.slider</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">255</span>, <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">100%</span> - <span class="token number">100</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  // 使用BFC阻止content被浮动元素覆盖
  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><blockquote>
<p>两栏都绝对定位并使用calc计算自适应那一栏的宽度</p>
</blockquote>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="slider">
    &lt;p>slider&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.slider</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">100%</span> - <span class="token number">100</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="tabel布局-1"><a href="#tabel布局-1" class="headerlink" title="tabel布局"></a>tabel布局</h2><blockquote>
<p>利用表格的宽度等于所有单元格宽度之和的特性</p>
</blockquote>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="slider">
    &lt;p>slider&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.slider</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="flex布局-1"><a href="#flex布局-1" class="headerlink" title="flex布局"></a>flex布局</h2><blockquote>
<p>flex大法真香</p>
</blockquote>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="slider">
    &lt;p>slider&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.slider</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="slider">
    &lt;p>slider&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
    &lt;p>content&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token number">100</span>px auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.slider</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h1><blockquote>
<p>跟两栏布局差不多，三栏布局是左右两栏固定宽度，中间栏自适应宽度（即固比固布局）。</p>
</blockquote>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="left">
    &lt;p>我是左导航栏我是左导航栏我是左导航栏&lt;/p>
  &lt;/div>
  &lt;div class="right">
    &lt;p>我是右导航栏我是右导航栏我是右导航栏&lt;/p>
  &lt;/div> 
  &lt;div class="content">
    &lt;div class="inner-content">
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
    &lt;/div>
  &lt;/div>
&lt;/div>
&lt;!-- 注意，中间元素要放最后，使左右两栏先渲染，否则右栏会被挤压在下面 -->

<span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.inner-content</span> </span><span class="token punctuation">{</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>
  <span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/03/07/未知宽高元素的水平垂直居中布局/3.gif" alt></p>
<blockquote>
<p>从效果图中可以看出，使用浮动实现三栏布局在中间栏容纳得下内容时是可以正常工作的，但内容一旦超出，中间栏就会向下扩展。如果给它们指定 height 的话自然就不存在这问题了，不过内容还是会溢出来的（见下图）。当然我们可以选择给外层容器box设置<code>overflow: hidden</code>来隐藏，但如果我们要显示全部内容的话要怎么办？答案是给左中右三个元素使用padding内补偿法，使它们三栏等高。（当浏览器宽度小于左右两栏的宽度和时，右栏会被挤下来，这时要也只能去给 body 设置<code>min-width</code>了，这点跟圣杯布局一样）。</p>
</blockquote>
<p><img src="/2019/03/07/未知宽高元素的水平垂直居中布局/4.gif" alt></p>
<h2 id="绝对定位-1"><a href="#绝对定位-1" class="headerlink" title="绝对定位"></a>绝对定位</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="left">
    &lt;p>我是左导航栏我是左导航栏我是左导航栏&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;div class="inner-content">
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
    &lt;/div>
  &lt;/div>
  &lt;div class="right">
    &lt;p>我是右导航栏我是右导航栏我是右导航栏&lt;/p>
  &lt;/div> 
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.inner-content</span> </span><span class="token punctuation">{</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>也存在内容大于中间栏宽度，中间栏会向下扩展的问题。</p>
</blockquote>
<h2 id="flex布局-2"><a href="#flex布局-2" class="headerlink" title="flex布局"></a>flex布局</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="left">
    &lt;p>我是左导航栏我是左导航栏我是左导航栏&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;div class="inner-content">
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
    &lt;/div>
  &lt;/div>
  &lt;div class="right">
    &lt;p>我是右导航栏我是右导航栏我是右导航栏&lt;/p>
  &lt;/div> 
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>对高度会自适应，内容超出时三栏会自动调整高度。</p>
</blockquote>
<h2 id="tabel布局-2"><a href="#tabel布局-2" class="headerlink" title="tabel布局"></a>tabel布局</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="left">
    &lt;p>我是左导航栏我是左导航栏我是左导航栏&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;div class="inner-content">
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
    &lt;/div>
  &lt;/div>
  &lt;div class="right">
    &lt;p>我是右导航栏我是右导航栏我是右导航栏&lt;/p>
  &lt;/div> 
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>对高度会自适应，内容超出时三栏会自动调整高度。</p>
</blockquote>
<h2 id="grid布局-1"><a href="#grid布局-1" class="headerlink" title="grid布局"></a>grid布局</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="left">
    &lt;p>我是左导航栏我是左导航栏我是左导航栏&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;div class="inner-content">
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
    &lt;/div>
  &lt;/div>
  &lt;div class="right">
    &lt;p>我是右导航栏我是右导航栏我是右导航栏&lt;/p>
  &lt;/div> 
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token number">100</span>px auto <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>对高度会自适应，内容超出时三栏会自动调整高度。</p>
</blockquote>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="content">
    &lt;div class="inner-content">
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
    &lt;/div>
  &lt;/div>
  &lt;div class="left">
    &lt;p>我是左导航栏我是左导航栏我是左导航栏&lt;/p>
  &lt;/div>
  &lt;div class="right">
    &lt;p>我是右导航栏我是右导航栏我是右导航栏&lt;/p>
  &lt;/div> 
&lt;/div>

<span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100%</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.inner-content</span> </span><span class="token punctuation">{</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>同样是使用浮动，但双飞翼布局是对负margin的应用，实现详情请看<a href="http://blog.dangosky.com/2019/03/12/CSS%E8%B4%9F%E8%BE%B9%E8%B7%9D/#toc-heading-4">负margin实现两栏布局</a>。同样的是，在HTML代码部分也是把content放到left和right前面的优先渲染 ，否则left放前面的话会造成left被content覆盖或是内容超出视图，也存在前面的那两个问题。听说双飞翼布局是淘宝创造的？</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1747023-4b4ebc49181a2e4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="content">
    &lt;div class="inner-content">
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
    &lt;/div>
  &lt;/div>
  &lt;div class="left">
    &lt;p>我是左导航栏我是左导航栏我是左导航栏&lt;/p>
  &lt;/div>
  &lt;div class="right">
    &lt;p>我是右导航栏我是右导航栏我是右导航栏&lt;/p>
  &lt;/div> 
&lt;/div>

body </span><span class="token punctuation">{</span>
  <span class="token property">min-width</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span> 
  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">100</span>px <span class="token number">0</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> -<span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> -<span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>圣杯布局和双飞翼布局同样是对负margin的应用，区别在于解决中间栏内容不被左右侧边栏遮挡的方法不同。双飞翼布局是直接给content设置一个子div，利用margin-left和margin-right来间隔开彼此。而圣杯布局给父容器box设置padding来间隔开content主体内容和左右的距离，再给左右两栏分别相对定位设置left和right使其回到原先的位置。圣杯布局潜在的问题是，但浏览器缩小到一定程度后，左右两栏会被挤下来，不过可以给body设置<code>min-width</code>来解决这个问题。个人比较推荐双飞翼布局，两者实现的效果是一样的，而圣杯布局又要用到相对定位甚至min-width，为什么不简单点直接用margin解决同样的问题呢，不仅思路简单些代码也简洁。</p>
</blockquote>
<h1 id="三栏布局总结"><a href="#三栏布局总结" class="headerlink" title="三栏布局总结"></a>三栏布局总结</h1><ul>
<li><p>普通的浮动布局和双飞翼布局圣杯布局：<br>在 HTML 代码上普通的浮动是把中间栏放到最后，左右两栏分别左右浮动后中间空出来的空间给中间栏。而双飞翼布局和圣杯布局是把中间栏放在最前面使其先渲染，让三栏都左浮动后再利用左栏<code>margin-left: -100%</code>，右栏<code>margin-left: -100px</code>使其都并排布局。因为普通浮动里是把中间栏放到最后才渲染的，所以当页面内容较多时可能会影响用户体验。</p>
</li>
<li><p>对高度的适应性：<br>如果没有设置高度，flex布局，table布局，grid布局对三栏的高度变化有适应性，即使内容超出了三栏会都自动扩大自身高度来适应。而浮动和绝对定位两种方法内容一旦超出，中间栏则会向下扩展，双飞翼布局也一样有这问题，可以直接设置height来避免这问题。或者使用padding内补偿法使三栏都等高。</p>
</li>
<li><p>局限性：<br>浮动和绝对定位脱离文档流，需要处理好和其他元素的位置关系，不过兼容性比较好。</p>
</li>
</ul>
<p>&emsp;&emsp;flex布局和grid布局是新生的布局方式，功能强大对高度的适应性好，但对浏览器的兼容性不是很好。</p>
<p>&emsp;&emsp;table布局适应性好，对浏览器的兼容性也好，但table布局好像一直受人诟病，似乎毛病很多？我没在项目里用到过，也不知道真假。</p>
<h1 id="三栏布局之固定高度中间自适应"><a href="#三栏布局之固定高度中间自适应" class="headerlink" title="三栏布局之固定高度中间自适应"></a>三栏布局之固定高度中间自适应</h1><p><img src="/2019/03/07/未知宽高元素的水平垂直居中布局/5.gif" alt></p>
<blockquote>
<p>上下固定高度，中间自适应。都需要使用<code>overflow: scroll</code>来使中间栏溢出的部分在内部滚动，否则中间栏会扩展自身高度把底栏挤出视图，这我也不知道有什么更好的解决办法了。</p>
</blockquote>
<h2 id="绝对定位-2"><a href="#绝对定位-2" class="headerlink" title="绝对定位"></a>绝对定位</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="top">
    &lt;p>我是头部&lt;/p>
    &lt;p>我是头部&lt;/p>
    &lt;p>我是头部&lt;/p>
    &lt;p>我是头部&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;div class="inner_content">
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
    &lt;/div>
  &lt;/div> 
  &lt;div class="bottom">
      &lt;p>我是底部&lt;/p>
      &lt;p>我是底部&lt;/p>
      &lt;p>我是底部&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>vh<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">overflow</span><span class="token punctuation">:</span> scroll<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.top</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.bottom</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.inner_content</span> </span><span class="token punctuation">{</span>
  <span class="token property">padding-top</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>此处使用绝对定位有一个局限，需要事先知道顶部栏的高度，才好给中间栏的内容部分设置<code>padding-top</code>，否则内容会被顶部栏遮住。对于中间栏需要使用<code>overflow: scroll</code>来使溢出部分在中间栏里滚动，否则中间栏会向下扩展。</p>
</blockquote>
<h2 id="flex布局-3"><a href="#flex布局-3" class="headerlink" title="flex布局"></a>flex布局</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="top">
    &lt;p>我是头部&lt;/p>
    &lt;p>我是头部&lt;/p>
    &lt;p>我是头部&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;div class="inner_content">
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
    &lt;/div>
  &lt;/div> 
  &lt;div class="bottom">
      &lt;p>我是底部&lt;/p>
      &lt;p>我是底部&lt;/p>
      &lt;p>我是底部&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span> 
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>vh<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
  <span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">overflow</span><span class="token punctuation">:</span> scroll<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.top</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.bottom</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>中间栏同样需要使用<code>overflow: scroll</code>。</p>
</blockquote>
<h2 id="grid布局-2"><a href="#grid布局-2" class="headerlink" title="grid布局"></a>grid布局</h2><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="box">
  &lt;div class="top">
    &lt;p>我是头部&lt;/p>
    &lt;p>我是头部&lt;/p>
    &lt;p>我是头部&lt;/p>
  &lt;/div>
  &lt;div class="content">
    &lt;div class="inner_content">
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
      &lt;p>我是内容主题部分&lt;/p>
    &lt;/div>
  &lt;/div> 
  &lt;div class="bottom">
      &lt;p>我是底部&lt;/p>
      &lt;p>我是底部&lt;/p>
      &lt;p>我是底部&lt;/p>
  &lt;/div>
&lt;/div>

<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>vh<span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> <span class="token number">100</span>px auto <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.top</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.bottom</span> </span><span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>中间栏同样需要使用<code>overflow: scroll</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端点击的300ms延迟</title>
    <url>/2019/03/03/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%82%B9%E5%87%BB%E7%9A%84300ms%E5%BB%B6%E8%BF%9F/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="有300ms延迟的原因"><a href="#有300ms延迟的原因" class="headerlink" title="有300ms延迟的原因"></a>有300ms延迟的原因</h1><p>&emsp;&emsp;之所以移动端click会有300ms的延迟，主要是为了让用户在双击屏幕时可以对视图进行放大缩小，而这300ms就是用于判断在这时间范围之内是否有第二次点击，有则双击，否则就是单击。若每次单击屏幕都会延迟300ms才触发事件，很明显这对于用户体验来说是极其不友好的。</p>
<h1 id="解决300ms延迟的办法"><a href="#解决300ms延迟的办法" class="headerlink" title="解决300ms延迟的办法"></a>解决300ms延迟的办法</h1><h2 id="zepto-js"><a href="#zepto-js" class="headerlink" title="zepto.js"></a>zepto.js</h2><p>&emsp;&emsp;在zepto.js这个JavaScript库里，使用touch事件封装了tap事件，模仿了click的实现，并且不会有300ms的延迟。实现思路是：给目标元素添加touch监听事件，只要满足touch的时间不超过规定的超时时间(防止长按)，并且touch过程不发生移动则在touchend时触发tap事件。(touchend事件是冒泡到document时才触发目标元素绑定的tap事件的)</p>
<p> <img src="/2019/03/03/移动端点击的300ms延迟/2.png" alt> </p>
<h3 id="zepto-js的穿透bug"><a href="#zepto-js的穿透bug" class="headerlink" title="zepto.js的穿透bug"></a>zepto.js的穿透bug</h3><p>&emsp;&emsp;zepto.js虽然使用tap事件模拟click避开了300ms延迟，但存在一个bug，即点击穿透。这里需要先说明的是，当用户手指触摸到屏幕的时候，系统会生成两个事件，一个是touch，另一个是click，<strong>执行顺序依次为：touchstart、touchmove、touchend、click</strong>。其中touch事件会优先处理，经过捕获、处理,、冒泡一系列流程完成后才回去触发click事件。</p>
<p>&emsp;&emsp;所谓的点击穿透，是指当用户在上层有一个模态框或覆盖层（诸如蒙版）时，当触发tap事件关闭掉模态框或覆盖层后，此时事件只进行到touchend阶段，而300ms后将会触发的click事件在上层失去了目标元素，若此时下层的位置上恰好有元素绑定了click事件或是click时会触发事件，诸如input输入框在focus时会弹出键盘，a标签会跳转链接等的元素时，则会触发其绑定的click事件。</p>
<h3 id="解决穿透的办法"><a href="#解决穿透的办法" class="headerlink" title="解决穿透的办法"></a>解决穿透的办法</h3><p>&emsp;&emsp;1：在touch事件里面，调用<strong>e.preventDefault()</strong>可以阻止本次点击触发的click事件，而且不会阻止后续的touch事件。<br>&emsp;&emsp;2： 对tap事件做一下延迟，加一个setTimeout来使上层的模态框或覆盖层等click事件触发后再消失，这样下层的元素就不会被暴露出来了，click事件自然也不会作用到下层元素上去。<br>&emsp;&emsp;3：使用css的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/pointer-events#%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">pointer-events</a>给下层那个会触发到click的元素添加<strong>pointer-events:none</strong>属性，这会使得该元素永远不会成为click事件的目标。需要的话可以再添加一个setTimeout再把 pointer-event 的值设回auto。</p>
<h2 id="fastclick"><a href="#fastclick" class="headerlink" title="fastclick"></a>fastclick</h2><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><p>   &emsp;&emsp;监听touchstart事件获取目标元素。监听到touchend事件后，使用e.preventDefault()取消掉300ms后的click，合成相应的click事件并立即触发达到fastclick的目的。(合成事件的三步骤：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createEvent" target="_blank" rel="noopener">创建事件</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/initMouseEvent" target="_blank" rel="noopener">初始化鼠标事件</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent" target="_blank" rel="noopener">给目标元素分发事件</a>)<br><img src="/2019/03/03/移动端点击的300ms延迟/3.png" alt></p>
<h3 id="不需要使用fastclick的场景"><a href="#不需要使用fastclick的场景" class="headerlink" title="不需要使用fastclick的场景"></a>不需要使用fastclick的场景</h3><h2 id><a href="#" class="headerlink" title></a><img src="/2019/03/03/移动端点击的300ms延迟/1.png" alt></h2><p>(上述图片来源于网络)</p>
]]></content>
      <categories>
        <category>踩坑指南</category>
      </categories>
      <tags>
        <tag>踩坑指南</tag>
      </tags>
  </entry>
  <entry>
    <title>0.1 + 0.2 !== 0.3</title>
    <url>/2019/03/02/0-1-0-2-0-3/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&emsp;&emsp;众所周知的是，计算机中对十进制数字的运算是先把十进制数字转换为二进制再进行运算的（至于为什么，呃，如果我没记错的话，大致是因为早期计算机只支持二进制？正如之前看到的一句话，二进制是世界的本源）。对于二进制浮点数的转换而言，还牵扯到了一个<strong>IEEE754</strong>(<a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">二进制浮点数算术标准</a>)。   </p>
<p>&emsp;&emsp;十进制小数转化为二进制小数的具体做法是，将十进制小数乘以 2，得到积后将取出整数部分，再将剩余的小数部分继续乘以 2，反复循环上述过程(<strong>乘二取整</strong>)，直至小数部分为零或达到所要求的精度为止。举个例子，0.5 转换为二进制是 0.1，刚刚好可以既快且准地表示出来。而 0.1 转换为二进制后为 0.0001100110011…，是一个无限循环的二进制小数。又由于位数的限制（ JS 使用的是 64 位双精度浮点数编码，最多只有 52 位有效数字，见下图），所以从第 53 位后的位数会被舍掉（如果是 1 就向前一位进 1，如果是 0 就舍弃），造成了浮点数精确度损失。因此<strong>一部分</strong>二进制小数是不等于原来的十进制小数的！</p>
<p>&emsp;&emsp;至于解决办法，最好的自然是避免对浮点数进行比较操作，不然的话也可以界定浮点数的精确度，使用 <code>toFixed()</code> 保留小数点前几位，或者直接借用第三方库（刚才看了下有好几个这类库，虽然我没用过）。</p>
<p> <img src="/2019/03/02/0-1-0-2-0-3/1.png" alt>  </p>
<p>&emsp;&emsp;这里还有一个问题，<code>0.1 + 0.1</code> 是等于 0.2 的，很奇怪，这时候就没有精度损失了？Segmentfault 上有人说是:</p>
<blockquote>
<p>两个有舍入误差的值在求和时，相互抵消了，但这种“负负得正，相互抵消”不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消。  </p>
</blockquote>
<p>&emsp;&emsp;说得也不是很确切就是了，但也没有看到更多的答案了。</p>
<p>&emsp;&emsp;就先粗略地做这些笔记吧，以后再有更多的认识再补充。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>==中的类型转换</title>
    <url>/2019/02/28/==%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><pre class=" language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// false</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">// true</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">==</span> <span class="token operator">!</span><span class="token punctuation">{</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// false</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">!</span><span class="token punctuation">{</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// true</span>
<span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// false  </span>
<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">==</span> <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">// VM1896:1 Uncaught SyntaxError: Unexpected token ==</span>
<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token comment" spellcheck="true">// false   </span>
</code></pre>
<p>&emsp;&emsp;刚开始看到这几道题有点懵，好吧，js基础还是不太好。经过一番谷歌，算是应该弄懂了吧。涉及到各种ECMAScript规定，所以直接放总结出干货了。    </p>
<h3 id="的运算规则："><a href="#的运算规则：" class="headerlink" title="==的运算规则："></a>==的运算规则：</h3><ol>
<li>String/Boolean == Number，String/Boolean先转换为Number。    </li>
<li>String == Boolean，两个操作数都先转换为Number。   </li>
<li>Object == Primitive，Object先转为Primitive。</li>
</ol>
<p>&emsp;&emsp;以经典的<code>[]==![]</code>为例，可以拆解为一下几个过程：（1）<code>[] == ![]</code>, 先对[]进行取非逻辑运算，而 ![] 转换成的无疑是false，因为 [] 和 {} 都为true（见犀牛书P49，规定是这么规定，我觉得是因为[]和{}虽然是空的，但里面本来就包含了各种数据类型方法。会转化为false的就只有五个: undefined, null, 0, NaN, ‘’)。（2）<code>[] == false</code>,根据ECMAScript规定，此时先将false转化为数字，即0。（3）<code>[] == 0</code>, toPrimitive([]）将空数组转换为原始数据类型’’（详细过程见下，toPrimitive({})则转化为[object Object]）。(4)<code>&#39;&#39; == 0</code>, 显然先将可以得到 <code>0 == 0</code>,即最后结果true了。</p>
<h3 id="toPrimitive-："><a href="#toPrimitive-：" class="headerlink" title="toPrimitive()："></a>toPrimitive()：</h3><p>&emsp;&emsp;将对象转化为原始数据类型，接受两个参数。第一个是要转化的对象，第二个是要转化成的类型（Number, String），默认是Number（犀牛书P52）   </p>
<ol>
<li>转化为字符串： 先调用toString(),如果没有toString方法或返回的不是一个原始值，则再调用valueOf()。若得到一个原始值则返回，否则抛出异常。   </li>
<li>转化为数字： 先调用valueOf(),如果没有valueOf方法或返回的不是一个原始值，则再调用toString()。若得到一个原始值则返回，否则抛出异常。</li>
<li><p>默认的valueOf方法简单地返回对象本身,数组、函数和正则表达式使用默认的valueOf方法，所以valueOf([])放回一个空字符串。</p>
<p><img src="/2019/02/28/==中的类型转换/1.png" alt>  </p>
</li>
</ol>
<p>&emsp;&emsp;同理可得其他的运算结果，要注意的是:<br><code>![]=={}   //false</code>    和  <code>{}==![]   //VM1896:1 Uncaught SyntaxError: Unexpected token</code>。刚开始看的时候我也是觉得很奇怪，就左右互换了个位置而已，咋就报错了呢？我没想到的是，在<code>{}==![]</code>里{}被当作是代码块来处理了，所以自然就报错了。根据StackOverflow里某位daolao的回复，就是如果代码是以 { 开头以 } 结尾，就会被解析成表达式，否则就是代码块了，而以!开头的都会被认为是表达式。详情见下图：<br> <img src="/2019/02/28/==中的类型转换/2.png" alt>  </p>
<hr>
<p>本节完，如果有后续再另行补充。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue全家桶仿iOS版网易云音乐</title>
    <url>/2019/02/25/vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%BFiOS%E7%89%88%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;使用vue全家桶开发这个仿网易云音乐进行实操。因所学有限，项目所包含的内容可能会比较简单，并没有涉及到服务器搭建以及webpack配置等，但整体的业务逻辑还是有的。(还是要多加学习啊，加油！)。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><blockquote>
<p>使用的是学生服务器,带宽较小，初次体验可能会加载得比较慢 </p>
</blockquote>
<p>&emsp;&emsp;<a href="https://github.com/DangoSky/cloud-music" target="_blank" rel="noopener">项目地址</a><br>&emsp;&emsp;<a href="vue全家桶仿iOS版网易云音乐/QRcode.png">在线体验</a></p>
<blockquote>
<p>PC端推荐使用chrome或firefox预览</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/10/1696339dfe78e0d4?w=320&amp;h=319&amp;f=png&amp;s=7499" alt></p>
<blockquote>
<p>移动端推荐使用Android手机微信扫码预览,暂不支持iOS播放   </p>
</blockquote>
<h2 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h2><pre><code>克隆项目     
git clone https://github.com/DangoSky/cloud-music.git

安装依赖   
npm install   

开发环境运行    
npm run serve   

生产环境构建   
npm run build 
</code></pre><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>&emsp;&emsp;vue2 + vue-cli3 + vue-router + vuex + axios</p>
<h2 id="使用到的工具"><a href="#使用到的工具" class="headerlink" title="使用到的工具"></a>使用到的工具</h2><p>&emsp;&emsp;<code>vue-lazyload</code>: 实现图片懒加载<br>&emsp;&emsp;<code>fastclick</code>: 解决移动端点击300ms延迟<br>&emsp;&emsp;<code>Iconfont</code>: 本项目包含的所有图标均来源于此<br>&emsp;&emsp;(本项目未使用UI框架)</p>
<h2 id="api调用"><a href="#api调用" class="headerlink" title="api调用"></a>api调用</h2><p>  &emsp;&emsp;<a href="https://github.com/Binaryify/NeteaseCloudMusicApi" target="_blank" rel="noopener">网易云音乐 NodeJS 版 API</a><br>  &emsp;&emsp;<a href="https://zhuanlan.zhihu.com/p/30246788" target="_blank" rel="noopener">网易云音乐（Cloudmusic）API</a>   </p>
<h2 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a>项目截图</h2><p><img src="https://user-gold-cdn.xitu.io/2019/3/10/169633ba1c662491?w=279&amp;h=502&amp;f=png&amp;s=183089" alt><br><img src="https://user-gold-cdn.xitu.io/2019/3/10/169633bc0bda3c19?w=281&amp;h=504&amp;f=png&amp;s=191437" alt><br><img src="https://user-gold-cdn.xitu.io/2019/3/10/169633bcc1b60036?w=280&amp;h=503&amp;f=png&amp;s=48341" alt><br><img src="https://user-gold-cdn.xitu.io/2019/3/10/169633bdf34cdbdd?w=279&amp;h=500&amp;f=png&amp;s=252193" alt><br><img src="https://user-gold-cdn.xitu.io/2019/3/10/169633be8170cd45?w=279&amp;h=500&amp;f=png&amp;s=217948" alt></p>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><ul>
<li>ios版网易云音乐界面的五个模块</li>
<li>基本的播放暂停、上下一曲</li>
<li>播放顺序调整、进度条拖拽</li>
<li>歌词滚动   </li>
<li>音乐搜索</li>
<li>推荐歌单  </li>
<li>推荐MV  </li>
<li>增删改查歌单(使用localStorage存储，右滑可以删除歌单或将歌曲移出歌单)  <blockquote>
<p>因要开始准备学校挑战杯，所以本项目开发暂告一顿落，等以后有时间还会继续开发新功能，预期添加的功能包括：查看歌曲评论、用户登陆、每日推荐、查看动态…</p>
</blockquote>
</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><pre><code>src  
|—— api 调用api
|—— assets 图标库
|—— components 组件库
|   |——base 基础组件
|   |——explore 发现页面
|   |——video 视频页面
|   |——myself 我的页面
|   |——friend 朋友页面
|   |——user 账号页面
|—— css 各个组件的样式 
|   |——base
|   |——explore
|   |——video
|   |——myself
|   |——friend
|   |——user
|—— router  路由配置
|—— store  vuex状态管理
|—— App.vue  根组件
|—— main.js 入口
</code></pre><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><ol>
<li><p>iOS上无法播放音乐，不论是用微信打开还是用safari、Firefox打开都没有声音，测试了一下是取得到音乐的url的。问题应该是audiod的paly方法失效了，原因未明，谷歌也未果，而且我看GitHub上别人的仿网易云貌似没有这个问题，未解。安卓的情况比较复杂，拿了几台手机测试，在微信上打开全部功能都正常运行。用浏览器则一些型号的手机可以，一些不可以，而且有的手机用UC打开无法播放，用系统自带的浏览器则可以播放。原因也未明，不过这倒是在意料之中，因为在代码中还没有做兼容性处理，等以后有时间再继续完善吧。</p>
</li>
<li><p>偶尔会出现疑似跨域资源共享的问题(见下图)，说疑似是因为这个报错只有小概率会出现，而且即使出现了只要过一会再刷新就不会报错了，不像是跨域的问题。因为api是别人写好的，也不知道是不是后端接口的问题，原因未接。在GitHub上有和一个也在做仿网易云的人交流过，他也偶尔会出现这个cors问题，但也不知道怎么解决。<br><img src="/2019/02/25/vue全家桶仿iOS版网易云音乐/cors.png" alt></p>
</li>
<li><p>fixed定位的问题。网易云很多个界面上都有一个用于路由跳转的footer，并且是固定定位的。因为固定定位在文档流中不占据位置，所以会造成上面排版下来的元素会被footer覆盖住，设置z-index也不管用（如果footer有背景色的话，则footer无法被完全覆盖住）。我的解决办法是使用一个空的div或一个伪元素占位，把宽高设得和footer一样加上相对定位，这样就可以把fixed定位的空间补回来了。但我感觉这只是一种hack，并没有根本上解决问题，每次在一个页面中遇到这种问题都得手动再去新增一个伪元素和空div，而且这样一个空div不太符合语义化。但fixed定位本就规定了在文档流中不占据位置，貌似也没有更好的解决办法了。</p>
</li>
</ol>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.userBar</span><span class="token pseudo-element">::after</span> </span><span class="token punctuation">{</span>   
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>    
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;有一个项目开发进行实操，有时候确实比一直看文档要有用的多。看文档和一些技术贴有时候会因为尚未接触到那些问题而没有什么想法，边在实操中发现问题边针对性地学习有时候不失为一种好的学习方法。本项目的开发过程也遇到过不少问题，几乎思考一阵子或是求助于Google和StackOverflow就可以解决掉了，也算是锻炼了一下在项目开发中发现问题和解决问题的能力吧。有些可惜的是，因所学有限，该项目尚未进行性能优化以及兼容性处理，可能在不同的设备和浏览器上会有意料之外的效果，等以后学到了更多后再陆续优化吧，目前得把时间投入到新任务中去了，现在写下这篇总结算是对这阵子开发的收官吧。</p>
<p>&emsp;&emsp;如果您发现有什么问题或是有什么想法，欢迎issues和PR。    </p>
<p>&emsp;&emsp;如果您觉得这个仿网易云音乐还算不错，可以在<a href="https://github.com/DangoSky/cloud-music" target="_blank" rel="noopener">GitHub</a>上点个star，非常感谢您的认可和鼓励，谢谢~</p>
<hr>
<p><strong>后话</strong>：<br>&emsp;&emsp;接下来就开始向react进军了，虽然是打算等暑假或是大三再学习react的，但挑战杯的项目需要，既然决定要用react native开发app了，就顺道一起把react学了吧。其实还是很满意这个进程的，使用react native进行app开发挺契合我原先的技术栈的，而且这样就不用原生的app开发那一套，也就不用学Java啦，几乎没有额外的学习成本。所以啊，要继续加油啦，保持这几个月来的学习状态，继续前进吧！接下来这阵子的学习目标，边学习react后开始练手react native弄个demo熟悉熟悉，边巩固原先的js基础好为之后的实习僧面试做准备(暑假应该找得到实习吧，不知道外面的行情怎么样)。还得注意下时间准备做小程序了，虽然还有一个多月的时间，用mpvue搭建也几乎和用vue没啥差别，但还是得先安排好时间，免得到时出了什么岔子才行啊。   </p>
<p>&emsp;&emsp;以上。   </p>
<p>&emsp;&emsp;向前有路，未来可期！</p>
]]></content>
      <categories>
        <category>Web Project</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web Project</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS制作各种图形</title>
    <url>/2018/12/25/CSS%E5%88%B6%E4%BD%9C%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>&emsp;&emsp;有时候代码和效果图可以比文字更清楚地表达我们想说明的意思，所以我们先上一段样式再看看效果。</p>
<pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div class="square">&lt;/div>  

<span class="token class">.square</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">20</span>px solid<span class="token punctuation">;</span>
  <span class="token property">border-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/0.png" alt><br>&emsp;&emsp;从图中我们好像并没有发现什么异常，这不就是普普通通地给一个div设置边框吗？这和三角形有什么关系？这样看确实是很平常，那是因为我们设置border都是左右上下四条边框都是同一种颜色的，如果我们把它们设置为四种不同的颜色呢？现在我们把<code>border-color: red</code>换为<code>border-color: yellow blue pink green</code>再来看看效果。<br><img src="/2018/12/25/CSS制作三角形/1.png" alt><br>&emsp;&emsp;现在有没有发现什么问题了？四条边框都是显示为等腰梯形的，并不是长方形！刚才我们看到的那个红色边框其实也是由四个等腰梯形拼成的，只是它们都是同一种颜色所以我们看不出来而已。我猜想之所以如此是为了让四条边框都可以等大而且分布在各自的位置上不至于混乱（想象一下如果四条都是长方形的话要怎么才能做到等大且均匀分布在上下左右）。现在我们再把这个div的宽高都调为 0 看看有什么变化。<br><img src="/2018/12/25/CSS制作三角形/2.png" alt><br>&emsp;&emsp;因为div的宽高为 0，且又存在着边框，所以原本是等腰梯形的四条边框会从开始延伸，在中心交为一点，于是就成了四个三角形。但我们只是要一个三角形而已，要怎么去掉其余三个呢？答案是我们可以给其余几条边框设置为透明色来隐藏掉它们。我们再把边框样式更换为<code>border-color: transparent transparent red transparent</code>试试看。（边框设置为透明不等于不设置边框，详见下文的注意点。）<br><img src="/2018/12/25/CSS制作三角形/3.png" alt><br>&emsp;&emsp;于是乎，一个三角形就出来了！理解了上述制造三角形的原理后，我们自然就可以随心所欲去变化三角形的指向和样式了。通过指定不同方向上的边框为透明色来改变三角形的方向，比如我们要得到一个指向左边的三角形，就应该把上下左边框都设置为透明色，即<code>border-color: transparent pink transparent transparent</code>。（想象一下三角形是由原本方位上的等腰梯形延伸而成的就行了）<br><img src="/2018/12/25/CSS制作三角形/4.png" alt><br>&emsp;&emsp;如果我们要得到指向西北的三角形呢？（见下图）我们可以把它进行拆分，即由一个指向下和一个指向右的三角形组合而成（想象一下），所以只需要把边框样式改为<code>border-color: pink transparent  transparent pink</code>就成了，其他的同理。<br><img src="/2018/12/25/CSS制作三角形/5.png" alt></p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>&emsp;&emsp;<strong>如果没有设置全部四条边框，可能会出现断层效果。</strong></p>
<ol>
<li>只设置两条边框</li>
</ol>
<ul>
<li>该两条边框相邻时</li>
</ul>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid red<span class="token punctuation">;</span>
  <span class="token property">border-right</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/8.png" alt><br>&emsp;&emsp;可以看到，因为没有设置左边框和下边框，所以上边框和右边框的部分也没有显示出来。（从中可以得到：<strong>四个顶角处的那部分边框是属于相邻两个边框的，只要其中一个边框没有设置，顶角处的那部分边框就不会显示</strong>。）<br>&emsp;&emsp;现在我们把宽高都设为0再看看效果。从下图可以发现，当div的宽高都为0时，原本延伸的那部分边框会收缩回去，最后两个三角形拼成了正方形。<br><img src="/2018/12/25/CSS制作三角形/9.png" alt></p>
<ul>
<li>该两条边框不相邻时</li>
</ul>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid red<span class="token punctuation">;</span>
  <span class="token property">border-bottom</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/10.png" alt><br>&emsp;&emsp;原因同上，因为左右边框都没有设置，所以上下边框和左右边框相交的那部分也就不会显示了。和相邻边框不同的是，如果把宽高都设为0，则上下两个边框也会收缩回去，但最后直接收缩没了。<strong>相邻边框收缩后拼成了一个正方形是因为那是由边框自己的大小拼凑而成的</strong>，不依赖于div的宽高。而<strong>不相邻的边框（即上下边框或左右边框）依赖于div的宽高</strong>，它们中间那正方形的部分是随div的宽高来延长的（想象一下那画面就成了）。</p>
<ol start="2">
<li>设置三条边框<br>设置三条边框和设置不相邻的两条边框的情况是一样的，这里就只贴图和代码不解释了。</li>
</ol>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid red<span class="token punctuation">;</span>
  <span class="token property">border-right</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid yellow<span class="token punctuation">;</span>
  <span class="token property">border-left</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/11.png" alt></p>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid red<span class="token punctuation">;</span>
  <span class="token property">border-left</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid blue<span class="token punctuation">;</span>
  <span class="token property">border-right</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid yellow<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/12.png" alt></p>
<h1 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h1><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">// 或者通过边框来撑起圆的大小
<span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid lightgreen<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/14.png" alt></p>
<p>&emsp;&emsp;或者使用 <strong>canvas</strong> 来画圆。</p>
<pre class=" language-css"><code class="language-css">&lt;canvas id=<span class="token string">"canvas"</span> width=<span class="token string">"300"</span> height=<span class="token string">"300"</span>>&lt;/canvas>
&lt;script>
  let canvas = document<span class="token number">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  let context = canvas<span class="token number">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"2d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  context<span class="token number">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  context<span class="token number">.</span><span class="token function">arc</span><span class="token punctuation">(</span><span class="token number">100</span>, <span class="token number">100</span>, <span class="token number">50</span>, <span class="token number">0</span>, Math<span class="token number">.</span>PI * <span class="token number">2</span>, true<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  context<span class="token number">.</span>fillStyle = <span class="token string">"red"</span><span class="token punctuation">;</span>
  context<span class="token number">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
&lt;/script>
</code></pre>
<h1 id="半圆"><a href="#半圆" class="headerlink" title="半圆"></a>半圆</h1><p>&emsp;&emsp;设置半圆的时候宽高比是一比二或二比一（取决于半圆的方向）。而边框圆角，我们需要知道的是，设置<code>border-raidus</code>时是可以分开来设置四个方位的圆角的，依次顺序分别是左上，右上，右下，左下，所以半圆我们只需要设置相应的相邻两个边框圆角就行了。</p>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.semicircle</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">100</span>px <span class="token number">100</span>px <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* 还可以如下分开设置 */</span>
  <span class="token comment" spellcheck="true">/* border-top-left-radius: 100px;
  border-top-right-radius: 100px; */</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/6.png" alt></p>
<p>&emsp;&emsp;通过设置不同边框的样式，我们还可以设置出这么一个东西来，破了壳的蛋？食人花？如果想象力足够，CSS真的能够做出很多不可思议的玩样出来，比如人家IE的logo。Orz…</p>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.pac-man</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">0</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span>px<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">60</span>px solid<span class="token punctuation">;</span> 
  <span class="token property">border-color</span><span class="token punctuation">:</span> red transparent red red <span class="token punctuation">;</span> 
  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/15.png" alt></p>
<h1 id="椭圆形"><a href="#椭圆形" class="headerlink" title="椭圆形"></a>椭圆形</h1><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.oval</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/18.png" alt></p>
<h1 id="扇形"><a href="#扇形" class="headerlink" title="扇形"></a>扇形</h1><p>&emsp;&emsp;扇形和半圆其实是同一个道理，只是扇形的宽高要相等，并且只需要设置一个边框圆角就行了。</p>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.fan-shaped</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">100%</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/7.png" alt></p>
<h1 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h1><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.parallelogram</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">skew</span><span class="token punctuation">(</span><span class="token number">45</span>deg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/19.png" alt></p>
<h1 id="六角星"><a href="#六角星" class="headerlink" title="六角星"></a>六角星</h1><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.sixStar</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> <span class="token number">100</span>px solid red<span class="token punctuation">;</span>
  <span class="token property">border-right</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid transparent<span class="token punctuation">;</span>
  <span class="token property">border-left</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid transparent<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.sixStar</span><span class="token pseudo-element">::after</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">border-bottom</span><span class="token punctuation">:</span> <span class="token number">100</span>px solid red<span class="token punctuation">;</span>
  <span class="token property">border-right</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid transparent<span class="token punctuation">;</span>
  <span class="token property">border-left</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid transparent<span class="token punctuation">;</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> -<span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> -<span class="token number">135</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/13.png" alt><br>&emsp;&emsp;说白了，六角星就是由两个指向相反的三角形组合成的，只不过其中一个是通过伪元素来设置的，并使用绝对定位把它移动到合适的位置上去而已。需要注意的是，要调整好边框的大小，否则得到的六角星会达不到效果。</p>
<h1 id="聊天框气泡"><a href="#聊天框气泡" class="headerlink" title="聊天框气泡"></a>聊天框气泡</h1><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.talkBubble</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">120</span>px<span class="token punctuation">;</span> 
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.talkBubble</span><span class="token pseudo-element">::before</span> </span><span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">25%</span><span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> <span class="token number">10</span>px solid transparent<span class="token punctuation">;</span>
  <span class="token property">border-right</span><span class="token punctuation">:</span> <span class="token number">20</span>px solid lightgreen<span class="token punctuation">;</span>
  <span class="token property">border-bottom</span><span class="token punctuation">:</span> <span class="token number">10</span>px solid transparent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/16.png" alt><br>&emsp;&emsp;说白了，就是一个长方形和一个三角形，其中三角形通过伪元素设置再绝对定位移动到左边而已，瞅着倒是挺好看的。</p>
<h1 id="阴阳图"><a href="#阴阳图" class="headerlink" title="阴阳图"></a>阴阳图</h1><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#eee</span><span class="token punctuation">;</span>
  <span class="token property">border-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>
  <span class="token property">border-width</span><span class="token punctuation">:</span> <span class="token number">2</span>px <span class="token number">2</span>px <span class="token number">50</span>px <span class="token number">2</span>px<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.box</span><span class="token pseudo-element">::before</span> </span><span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#eee</span><span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">20</span>px solid red<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.box</span><span class="token pseudo-element">::after</span> </span><span class="token punctuation">{</span>
  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">10</span>px<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>
  <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">20</span>px solid <span class="token hexcode">#eee</span><span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2018/12/25/CSS制作三角形/17.png" alt><br>&emsp;&emsp;这个阴阳图的制作很巧妙，之所以这么说是因为代码对borde运用地很灵活。整体的圆形其实并不只是一个圆形，它的上半部分是一个椭圆形，下半部分是由border来撑开的，这样就做到了上下两半是两种颜色。而中间那两个小圆也利用到了border，伪元素自身的宽高用来制作小圆，同时还设置了border来制作小圆外层的圆形，这样就达到了那弧形效果，最后还是绝对定位修改一下位置就大功告成了。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>还是小白</title>
    <url>/2018/11/04/%E8%BF%98%E6%98%AF%E5%B0%8F%E7%99%BD/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&emsp;&emsp;今天发现了许多前端的学习资源，各位大牛的博客、Github，各处前端的学习社区以及腾讯百度等的前端团队······然后，越发觉得自己好菜啊，到现在还只是小白入门。哎，谁说前端技术含量不如后端的，我给他丢几个前端社区网址再加张前端知识图谱压压他先，前端的水也是很深啊。</p>
<p>&emsp;&emsp;今天chrome的书签栏目又更新了一波，现在连微信公众号都被前端占了小半边天了。看着今天fork的三四个仓库，嗯，要更好好学习了！</p>
<p>&emsp;&emsp;昨天看完了Ajax，emmm，算是入了门吧？（以后查看网页源代码就看不到我的密码了，当初说的现在隔了一个多月终于做到了。）接下来先顺带把HTML5和xml一些东西看了后就可以准备看书了，现在手机里可是放了好几本JavaScript和CSS的书，先巩固巩固js和css的知识，毕竟这是根本内容，后面估计就开始学vue了吧。呃，突然想起来前两天想到的要做个网易云播放界面，或者网页版太空战机啥的，好像也没啥时间做耶。emmm，先学着看看吧。哎，都是时间不够的错，真的得努力学习啊！！！</p>
]]></content>
      <categories>
        <category>生活日记</category>
      </categories>
      <tags>
        <tag>生活日记</tag>
      </tags>
  </entry>
  <entry>
    <title>我写的第一个WebGame--2048</title>
    <url>/2018/10/27/%E6%88%91%E5%86%99%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAWebGame--2048/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&emsp;&emsp;<a href="http://dangosky.com/2048/index.html" target="_blank" rel="noopener">这是一个到2048空间的传送门。</a></p>
<p>&emsp;&emsp;记录下2048的制作思路，emmm，其实是有一段时间没有更新博客了，写一篇来充充数。（说明我是有更新blog的！）</p>
<p>&emsp;&emsp;好像也没啥好写的，2048也不怎么难做，没啥算法含量的里面。只要把过程理清，就是css+js的事而已了。还是写写监听键盘从而决定格子的移动状态好了，当作理理思路。以向左移动为例，向右向上向下类同。</p>
<p>&emsp;&emsp;当event.keyCode=37时调用moveLeft()：</p>
<p>&emsp;&emsp;1.首先得先判断是否可以向左移动，得满足两个格子之间存有空格或者中间的格子有与其相同数值的格子，才能进行向左移动。</p>
<p>&emsp;&emsp;2.两个for循环遍历所有的行列，对于一个有数值的格子a，对其所在行的第一个格子到a自身进行遍历（如果是向右移动的话，则从所在行的最后一个格子到a自身进行遍历。向上向下移动亦是如此，这个顺序很关键），遍历过程出现以下三种情况则进行移动：</p>
<p>&emsp;&emsp;（1）遍历到的格子b还没有数值（空格），而且两个格子之间没有障碍物（即有数值的格子）存在。则把a移动到b的位置（引用jQuery的animate函数，所以说已经有jQuery了为什么还要自己再去封装一个缓动动画函数呢？就当作是了解怎么用js原生态语句做缓动动画了，这就是原理？）<br><img src="/2018/10/27/我写的第一个WebGame--2048/2048.1.png" alt="The requested content cannot be loaded."></p>
<p>&emsp;&emsp;（2） 遍历到的格子b和a有相同的数值，而且两个格子之间没有障碍物。如果b已经是合并过了的，那a和b不合并，a移动到b的右手边相邻空格处。<br><img src="/2018/10/27/我写的第一个WebGame--2048/2048.2.png" alt="The requested content cannot be loaded."><br><img src="/2018/10/27/我写的第一个WebGame--2048/2048.3.png" alt="The requested content cannot be loaded."></p>
<p>&emsp;&emsp;如图，如果不去判断格子是否已经合并过了的话，结果则会是8 0 0 0，但是游戏规则是同一次移动中不能有合并</p>
<p>&emsp;&emsp;（3）遍历到的格子b和a有相同的数值，而且两个格子之间没有障碍物。如果b还没有合并过，则a移动到b的位置，a和b合并，两者数值相加。因为遍历的顺序是从其所在行的第一个格子到a自身，所以左边的格子2会先左移到第一列，随后右边的格子2再左移与其合并。</p>
<p>&emsp;&emsp;大致就这些了吧，其他的比如产生随机数、动态布局、缓动动画这些就纯js操作了，不是啥大问题，详情就戳<a href="https://github.com/DangoSky/2048" target="_blank" rel="noopener">Github</a>看源码吧。</p>
<p>&emsp;&emsp;还有就是，之前学js都是静态地直接在.html里添加class和id属性，但这确实太固定不灵活了，可以先写好class的样式，再在js里面动态给div增加class和id。用jQuery的addClass（）或$().attr(“id”，“idName”)，位置布局和各种属性也是动态用jQuery已经封装好了的方法去修改。就一句话，能放.css和.js的就别放.html里，jQuery里已经封装好了的就别多此一举去用js原生的。</p>
<p>&emsp;&emsp;以上。</p>
<hr>
<p>&emsp;&emsp;这应该算是自己做的第一个游戏了吧（如果不算上大一用橙光做的仙剑四的话），挺有趣的（还能给你想给的人玩哦），而且在做的过程中又学到了许多新的东西，算做是学js的一个阶段性总结了。接下来就先搁置下js了，虽然《JavaScript高级程序设计》《css揭秘》这几本书还没看（也都还没借到书耶，愈发不想买专业书了，贵啊，而且也渐渐习惯了用网上资源学习，网易云课堂慕课网w3c菜鸟教程等等）。打算先把Ajax学了，之后还有canvas，至于vue框架（所以是选择vue而不是react了是吧？）就等学期末或是寒假了，还有node.js、PHP、MySQL在排队，Linux就默默排最后去好了。有些想学Python耶，爬取数据也很好玩的，可惜lightyear说微信的聊天数据爬不了，不然以后我就不用去备份和某人的聊天记录了，以及来比力和网易云这些聊天记录，一张张截图挺麻烦的好吗QWQ。</p>
<p>&emsp;&emsp;噢对，这个2048固定了宽高是475px，电脑上没问题，在手机上就gg了。不过加个媒体查询给手机屏幕指定另一个宽高应该就可以解决了，但又是一件费时的工作;( 算了不管这个了，反正也只能用电脑玩，手机怎么监听滑动我也不会，做成响应式的也没多大用处，一起等以后会监听手机滑动事件了再改好了（现在其实也可以先学了的，但还是先学Ajax吧，你们是要排队的不能随便插队）。</p>
<p>&emsp;&emsp;前两天还想着等学会了Ajax后就尝试看看微信小程序是怎么开发的，也想做个小程序出来玩玩（也可以直接把2048做成小程序吼）。但小程序的工作量估计要大得多了，不知道有没有那个时间。哎，明天都第九周了，期末考试也不远了啊orz。这学期是真的没学那物理数学了，但求考前两周的临阵磨枪能让我不挂了。</p>
<p>&emsp;&emsp;还有个想法，想自己构思个网页版的小游戏，emmm，还想着这个游戏还是只有我们俩才能玩的，Js给我一种在前端上无所不能的感觉，应该可以成吧。但问题在于要做什么游戏，现在都没想到什么ideas啊。哎，估计又是拖拖拖了，等N天后或许就有ideas了。</p>
<p>&emsp;&emsp;对了，最后还要鸣谢lightyear提的issues和PullRequests :）</p>
]]></content>
      <categories>
        <category>Web Project</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web Project</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>皮一下很开心</title>
    <url>/2018/10/12/%E7%9A%AE%E4%B8%80%E4%B8%8B%E5%BE%88%E5%BC%80%E5%BF%83/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><link rel="stylesheet" href="/css/date.css"></p>
<p><script type="text/javascript" src="/js/date.js"></script></p>
<p></p><p style="text-align: center; font-size: 20px; font-weight: bold;">等32号我有空了一定来换个皮肤<a id="more"></a><br><br></p>
<p></p><p style="text-align: center; color: red; font-size: 20px">明明什么都还没做就<span style="font-weight: bold;">已经</span></p>
<p><div id="box"><br>    <div id="date"><br>        <aname id="weekend"></aname><br>        <aname id="inTop"></aname><br>        <aname id="inBottom"></aname><br>    </div><br></div><br>    <div id="clock"><br>        <div id="hour"></div><br>        <div id="minute"></div><br>        <div id="second"></div><br>    </div></p>
<p></p><p style="text-align:center; color: red; font-size: 20px ">了</p>
<p></p><p style="text-align:center; color: #ccc;  font-size: 20px">QAQ</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>一点情绪</title>
    <url>/2018/10/08/%E4%B8%80%E7%82%B9%E6%83%85%E7%BB%AA/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&emsp;&emsp;现在是2018.10.8.01:17，距离大二开学也已经过了一个多月，好像说短不短说长也不长的。之前大一快结束前就想着大二要好好学习不能再浪费时间了，嗯，这一个月来我也自认为没有辜负时光收获颇丰。光是这三十多天的时间就已经从Git，到HTML、JavaScript、JQuery，Bootstrap，以及拥有了自己的域名和云服务器了。此外还建好了一个只有两个人的小世界（也就是几个网页啦），并成功地升级为响应式虽然还不够完善，以及搭建成了我的blog。不可否认的是这些成果已经大大超出了开学前我的计划，甚至是之前的我无法预料到的。但有时还是会有一种想法，或者说是情绪，觉得自己的学习进度还是太慢了，现在自己学的只是别人几个月前就已经做好了的，还有很多新的东西等着自己去学。会有一种懊悔，觉得自己以前浪费了很多时间没能早日找到现在这种学习和生活状态以至于自己起步比别人晚了许多，有点像是“知识焦虑症”吧，或者说是“恐岁月往矣，不知书”。</p>
<p>&emsp;&emsp;慢就慢了点吧，只要我走的这条路没错。下午走在路上的时候这样想着，算是自我安慰吧。</p>
<p>&emsp;&emsp;前阵子忙着搞响应式设计和搭建博客，到现在也基本上完工了，可以再次投入到我的学习之旅上啦。嗯，再学学JavaScript，之前虽然也学了一些，但只学了点皮毛，现在再加深巩固下并且学些高阶的东西。不知道能不能用这一两周的时间把网易云课堂上的JavaScript看完并做些成品出来，之后再进军Canvas。唉，估计有点凉，接下来这几天晚上都有课，上完课还得跟软工182的四个小伙伴出来讨论辩题带他们打新生赛。虽然当初是想着体验下带队的过程也从中锻炼自己，但是真的占用我时间啊:(噢，之前还想着要在codepen上也跟着做一两张图的，看起来挺好玩的。还想着要给仙剑做个网页宣传呢，现在估计都得凉了orz</p>
<p>&emsp;&emsp;等明天起床再开电脑发到博客上好了，懒得下床。好像每次都是这样吧，要写些什么东西都是等晚上宿舍熄灯后上床用手机写的，然后屏幕一关眼睛一闭过一会就睡着了，省时高效。呃，但这样好像有些对不起我的眼睛耶，emmm，也只能先让我的眼睛吃些苦了，就当做加班吧QAQ。</p>
<p>&emsp;&emsp;说刚才不是已经要睡觉了吗，怎么就突然写起了这篇日记来？emmm，管他呢，一有写点东西的冲动就写了呗，现在没有想法了刚好可以睡觉。<del>明天是八点钟的闹钟，我要看看到时会不会赖床，希望不会吧。嗯，就看明天这篇日记在博客上的发布时间就可以了。</del>八点零三分我就起来了哦，只赖了三分钟。</p>
<p>&emsp;&emsp;那，晚安了，这个世界。</p>
<p>&emsp;&emsp;还有你呀，略略略。</p>
<p>&emsp;&emsp;以上。</p>
]]></content>
      <categories>
        <category>生活日记</category>
      </categories>
      <tags>
        <tag>生活日记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2018/10/03/Hello%20hexo/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&emsp;&emsp;2018.10.3，DangoSky的博客终于搭建好了，也还只是出了个大概而已，还差了许多:(    </p>
<p>&emsp;&emsp;有些坎坷，_config.yml文件里冒号和属性值之间需要有一个空格才可以，然而一开始看的那两篇博客都没着重提到，这个坑让我掉了一个多小时。。。我。。。认栽了orz。搭个博客觉得还是选择主题麻烦，看了这个觉得这个好，看到那个又觉得那个好，选择纠结症。。。  </p>
<p>&emsp;&emsp;好像搭个博客就只是为了玩玩，体验体验搭建博客是个啥过程，小白一枚的我写不了啥技术文，也好像没啥精力和时间去写些心路历程的(如果没有那个写的冲动的话),而且说实话，真要写些自己的心事的话不是还有公众号？？所以这个博客估计得凉凉的，周更？月更？但觉得博客对于程序员来说就像公众号对于自媒体，哦不，我这样说把GitHub置于何地了？？   </p>
<p>&emsp;&emsp;好吧，其实我也不知道要写什么，在这第一篇博客文里。也因为这两天回家后心情不太好，有些闷闷不乐没啥好事的。就这样了，以上。</p>
]]></content>
      <categories>
        <category>生活日记</category>
      </categories>
      <tags>
        <tag>生活日记</tag>
      </tags>
  </entry>
</search>
